<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PointSampler library (C++): ps Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PointSampler library (C++)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceps.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ps Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1GridND.html">GridND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size N-dimensional point/vector class.  <a href="structps_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a" id="r_ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">KDTree</a> = nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;</td></tr>
<tr class="separator:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d453a5cb2885c1a8d264ff96303f627" id="r_a5d453a5cb2885c1a8d264ff96303f627"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a5d453a5cb2885c1a8d264ff96303f627"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5d453a5cb2885c1a8d264ff96303f627">dbscan_clustering</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">eps</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">min_pts</a>)</td></tr>
<tr class="memdesc:a5d453a5cb2885c1a8d264ff96303f627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Density-Based Spatial Clustering of Applications with Noise (DBSCAN).  <br /></td></tr>
<tr class="separator:a5d453a5cb2885c1a8d264ff96303f627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94" id="r_ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad1f4a1110a40bf1c6a687182db6b4b94">distance_rejection_filter</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">min_dist</a>)</td></tr>
<tr class="memdesc:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a set of points using a greedy distance-based rejection.  <br /></td></tr>
<tr class="separator:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632" id="r_af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">distance_rejection_filter_warped</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">base_min_dist</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>)</td></tr>
<tr class="memdesc:af23d114903fd5cb3ccb19d3e64183632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points based on spatially-varying minimal distance constraints.  <br /></td></tr>
<tr class="separator:af23d114903fd5cb3ccb19d3e64183632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4055582214237ee9f21369133e6194" id="r_a0e4055582214237ee9f21369133e6194"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </td></tr>
<tr class="memitem:a0e4055582214237ee9f21369133e6194"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0e4055582214237ee9f21369133e6194">function_rejection_filter</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">density_fn</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a0e4055582214237ee9f21369133e6194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points based on a spatial probability (density) function.  <br /></td></tr>
<tr class="separator:a0e4055582214237ee9f21369133e6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a" id="r_a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">gaussian_clusters</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">cluster_centers</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points_per_cluster</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">spread</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a913ab9d687ee42d04488e5eb0373e23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates clustered points around provided cluster centers using a Gaussian distribution.  <br /></td></tr>
<tr class="separator:a913ab9d687ee42d04488e5eb0373e23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d" id="r_a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0efaff8017d5a171ffdf0ed0201bd65d">gaussian_clusters</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">cluster_count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points_per_cluster</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">spread</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates clustered points around random centers uniformly sampled in a bounding box.  <br /></td></tr>
<tr class="separator:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b" id="r_aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa8c3b3b3367276f9a194938599d2463b">halton_sequence</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">shift</a>)</td></tr>
<tr class="separator:aa8c3b3b3367276f9a194938599d2463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524" id="r_a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">halton</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a81b18395a05f0bb4d483406e79aa9524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of quasi-random points using the Halton sequence in N dimensions.  <br /></td></tr>
<tr class="separator:a81b18395a05f0bb4d483406e79aa9524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3" id="r_ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae21a8c51533330ead4ebe76eed3e72b3">hammersley_sequence</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">shift</a>)</td></tr>
<tr class="separator:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6" id="r_aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aad0cc7bc81f7cac9f0be26177b9986a6">hammersley</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of quasi-random points using the Hammersley sequence in N dimensions.  <br /></td></tr>
<tr class="separator:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b" id="r_a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a932640b18d76a7e336fc760e9cf5511b">importance_resampling</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">oversampling_ratio</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">density_fn</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a932640b18d76a7e336fc760e9cf5511b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point set via importance resampling from a quasi-random oversampled grid.  <br /></td></tr>
<tr class="separator:a932640b18d76a7e336fc760e9cf5511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8" id="r_ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad8525c124fef24618bf574b9b7b1ece8">jittered_grid</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">jitter_amount</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">stagger_ratio</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ad8525c124fef24618bf574b9b7b1ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point set on a jittered and optionally staggered grid.  <br /></td></tr>
<tr class="separator:ad8525c124fef24618bf574b9b7b1ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714" id="r_ae90df8db8e751ff4b61298114f092714"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae90df8db8e751ff4b61298114f092714">jittered_grid</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:ae90df8db8e751ff4b61298114f092714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a jittered grid of points with full jitter and no stagger.  <br /></td></tr>
<tr class="separator:ae90df8db8e751ff4b61298114f092714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef03daefffe13bd08b9b4c0952c00d" id="r_acbef03daefffe13bd08b9b4c0952c00d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:acbef03daefffe13bd08b9b4c0952c00d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#acbef03daefffe13bd08b9b4c0952c00d">kmeans_clustering</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k_clusters</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">normalize_data</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_iterations</a>=100)</td></tr>
<tr class="memdesc:acbef03daefffe13bd08b9b4c0952c00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform k-means clustering on a set of points.  <br /></td></tr>
<tr class="separator:acbef03daefffe13bd08b9b4c0952c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca14831de223ff62a6c3ec93e96a7c0" id="r_a9ca14831de223ff62a6c3ec93e96a7c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:a9ca14831de223ff62a6c3ec93e96a7c0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a9ca14831de223ff62a6c3ec93e96a7c0">latin_hypercube_sampling</a> (std::size_t <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">sample_count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a9ca14831de223ff62a6c3ec93e96a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates samples using Latin Hypercube Sampling (LHS).  <br /></td></tr>
<tr class="separator:a9ca14831de223ff62a6c3ec93e96a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96771d03336a56988d82df95e8a797a" id="r_ae96771d03336a56988d82df95e8a797a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae96771d03336a56988d82df95e8a797a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae96771d03336a56988d82df95e8a797a">angle_distribution_neighbors</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bin_width</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k_neighbors</a>=8)</td></tr>
<tr class="memdesc:ae96771d03336a56988d82df95e8a797a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the angular distribution function (ADF) using nearest neighbors.  <br /></td></tr>
<tr class="separator:ae96771d03336a56988d82df95e8a797a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a824a8963ef7b15c01da0f1f9c90eee" id="r_a9a824a8963ef7b15c01da0f1f9c90eee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a9a824a8963ef7b15c01da0f1f9c90eee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a9a824a8963ef7b15c01da0f1f9c90eee">distance_to_boundary</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>)</td></tr>
<tr class="memdesc:a9a824a8963ef7b15c01da0f1f9c90eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance of each point to the domain boundary.  <br /></td></tr>
<tr class="separator:a9a824a8963ef7b15c01da0f1f9c90eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a0bac33731ed899845c6081c117db2" id="r_a91a0bac33731ed899845c6081c117db2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a91a0bac33731ed899845c6081c117db2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a91a0bac33731ed899845c6081c117db2">first_neighbor_distance_squared</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>)</td></tr>
<tr class="memdesc:a91a0bac33731ed899845c6081c117db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance to the nearest neighbor for each point.  <br /></td></tr>
<tr class="separator:a91a0bac33731ed899845c6081c117db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc008d79bdad63b0acf9a4e627cc479" id="r_accc008d79bdad63b0acf9a4e627cc479"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:accc008d79bdad63b0acf9a4e627cc479"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#accc008d79bdad63b0acf9a4e627cc479">local_density_knn</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k</a>=8)</td></tr>
<tr class="memdesc:accc008d79bdad63b0acf9a4e627cc479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute local point density based on k-nearest neighbors in N dimensions.  <br /></td></tr>
<tr class="separator:accc008d79bdad63b0acf9a4e627cc479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29744e12116f882d8a620a3fd02d72d" id="r_ac29744e12116f882d8a620a3fd02d72d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac29744e12116f882d8a620a3fd02d72d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">nearest_neighbors_indices</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k_neighbors</a>=8)</td></tr>
<tr class="memdesc:ac29744e12116f882d8a620a3fd02d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest neighbors for each point in a set.  <br /></td></tr>
<tr class="separator:ac29744e12116f882d8a620a3fd02d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d80a56ea4774726e748b48e1ecf0a8d" id="r_a8d80a56ea4774726e748b48e1ecf0a8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a8d80a56ea4774726e748b48e1ecf0a8d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a8d80a56ea4774726e748b48e1ecf0a8d">radial_distribution</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bin_width</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_distance</a>)</td></tr>
<tr class="memdesc:a8d80a56ea4774726e748b48e1ecf0a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalized radial distribution function g(r).  <br /></td></tr>
<tr class="separator:a8d80a56ea4774726e748b48e1ecf0a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340aa5c812057b97017e88a974e452d8" id="r_a340aa5c812057b97017e88a974e452d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a340aa5c812057b97017e88a974e452d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a340aa5c812057b97017e88a974e452d8">percolation_clustering</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">connection_radius</a>)</td></tr>
<tr class="memdesc:a340aa5c812057b97017e88a974e452d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze percolation clusters from a set of points using a radius-based neighbor graph.  <br /></td></tr>
<tr class="separator:a340aa5c812057b97017e88a974e452d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0" id="r_af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af9ee1cf5d335276b7fabe6f1daddf1b0">operator+</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1" id="r_aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa369956286bc3f09dfdc146a5b2a49f1">operator-</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b" id="r_a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6fd3a6df3727a04f9baba3b8b87a903b">operator*</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e" id="r_a585704d3f738c5eb899810fc9308a60e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a585704d3f738c5eb899810fc9308a60e">operator/</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:a585704d3f738c5eb899810fc9308a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f" id="r_a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a366ef094d65da865384b6fb77aac5d5f">operator+</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>)</td></tr>
<tr class="separator:a366ef094d65da865384b6fb77aac5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f" id="r_a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79196b5b8a95ad9d3bc2ad698425944f">operator-</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>)</td></tr>
<tr class="separator:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b" id="r_acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#acd4dc781f43ba8a50daa139682846d4b">operator*</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>)</td></tr>
<tr class="separator:acd4dc781f43ba8a50daa139682846d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580" id="r_a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6663b4f1e9c5ee48e2bf6e1896430580">operator/</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>)</td></tr>
<tr class="separator:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4" id="r_abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#abfd6fe71db1c4df607bfdace9dffb5b4">operator*</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>)</td></tr>
<tr class="separator:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804" id="r_afe774cb61bde6358f8a7024c42db9804"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#afe774cb61bde6358f8a7024c42db9804">operator+</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scalar</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>)</td></tr>
<tr class="separator:afe774cb61bde6358f8a7024c42db9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b" id="r_ace7642868199df621df9139e5179767b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:ace7642868199df621df9139e5179767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c" id="r_a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>)</td></tr>
<tr class="separator:a7c3e161560ad3000aa4e2218291b169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746" id="r_a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">length</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>)</td></tr>
<tr class="separator:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914" id="r_a7de6090e2c8291401816be9bc6cda914"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7de6090e2c8291401816be9bc6cda914">normalized</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>)</td></tr>
<tr class="separator:a7de6090e2c8291401816be9bc6cda914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808" id="r_aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aecf2b150ec16bf286e6a7b462c4d5808">distance_squared</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11" id="r_ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac0b74f22d427d199ab0df8f6942d3b11">distance</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>)</td></tr>
<tr class="separator:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa" id="r_a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79914e9fc2dd02bacd38e9bd32e21baa">lerp</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">a</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">b</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">t</a>)</td></tr>
<tr class="separator:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28" id="r_adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#adb0bd4806c7e79eddef0e1263740ae28">clamp</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">min_val</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_val</a>)</td></tr>
<tr class="separator:adb0bd4806c7e79eddef0e1263740ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af" id="r_aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aedb5908eae325f054e4f3dd6b9b223af">in_neighborhood</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">grid</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">base_min_dist</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>)</td></tr>
<tr class="separator:aedb5908eae325f054e4f3dd6b9b223af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8" id="r_a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a898bca65491a14a41bfdd50fdc6230b8">generate_random_point_around</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">center</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">base_min_dist</a>, std::mt19937 &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">gen</a>, std::function&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;)&gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>)</td></tr>
<tr class="separator:a898bca65491a14a41bfdd50fdc6230b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8" id="r_a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5b1e932ba8a20e05cd8c113179aa77c8">poisson_disk_sampling</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">base_min_dist</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">new_points_attempts</a>=30)</td></tr>
<tr class="memdesc:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of Poisson disk samples in N-dimensional space, possibly with a warped metric.  <br /></td></tr>
<tr class="separator:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e" id="r_a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6f7ab76c5d0a395aa78b85bad488e94e">poisson_disk_sampling_uniform</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">base_min_dist</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">new_points_attempts</a>=30)</td></tr>
<tr class="memdesc:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate uniformly distributed Poisson disk samples in N-dimensional space.  <br /></td></tr>
<tr class="separator:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcc5685aa1520492658cb55fcd1a3dc" id="r_a0dcc5685aa1520492658cb55fcd1a3dc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">RadiusGen</a> &gt; </td></tr>
<tr class="memitem:a0dcc5685aa1520492658cb55fcd1a3dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0dcc5685aa1520492658cb55fcd1a3dc">poisson_disk_sampling_distance_distribution</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">n_points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">RadiusGen</a> &amp;&amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">radius_gen</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_attempts</a>=30)</td></tr>
<tr class="memdesc:a0dcc5685aa1520492658cb55fcd1a3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random points with a variable-radius Poisson disk sampling.  <br /></td></tr>
<tr class="separator:a0dcc5685aa1520492658cb55fcd1a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935f8e02f68dbf9667c6d544f7e3e2c" id="r_a0935f8e02f68dbf9667c6d544f7e3e2c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a0935f8e02f68dbf9667c6d544f7e3e2c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0935f8e02f68dbf9667c6d544f7e3e2c">poisson_disk_sampling_power_law</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">n_points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dist_min</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dist_max</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">alpha</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_attempts</a>=30)</td></tr>
<tr class="memdesc:a0935f8e02f68dbf9667c6d544f7e3e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate N-dimensional points using Poisson disk sampling with a power-law radius distribution.  <br /></td></tr>
<tr class="separator:a0935f8e02f68dbf9667c6d544f7e3e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca24167c8ae5bcbb056c30a1c0866f" id="r_a1bca24167c8ae5bcbb056c30a1c0866f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a1bca24167c8ae5bcbb056c30a1c0866f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a1bca24167c8ae5bcbb056c30a1c0866f">poisson_disk_sampling_weibull</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">n_points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">lambda</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_attempts</a>=30)</td></tr>
<tr class="memdesc:a1bca24167c8ae5bcbb056c30a1c0866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate N-dimensional points using Poisson disk sampling with a Weibull-distributed radius.  <br /></td></tr>
<tr class="separator:a1bca24167c8ae5bcbb056c30a1c0866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e070ffe5d2fcf926ceda2c0fec00e2d" id="r_a2e070ffe5d2fcf926ceda2c0fec00e2d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a2e070ffe5d2fcf926ceda2c0fec00e2d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a2e070ffe5d2fcf926ceda2c0fec00e2d">poisson_disk_sampling_weibull</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">n_points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">lambda</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dist_min</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">max_attempts</a>=30)</td></tr>
<tr class="memdesc:a2e070ffe5d2fcf926ceda2c0fec00e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson disk sampling in N dimensions with radii drawn from a Weibull distribution, enforcing a minimum exclusion distance.  <br /></td></tr>
<tr class="separator:a2e070ffe5d2fcf926ceda2c0fec00e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69" id="r_a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">random</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a10763ef2a872aa9eddb48ea341cd6f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a specified number of uniformly distributed random points in N-dimensional space.  <br /></td></tr>
<tr class="separator:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab818126518017939773c8a43bd92fc42" id="r_ab818126518017939773c8a43bd92fc42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:ab818126518017939773c8a43bd92fc42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ab818126518017939773c8a43bd92fc42">random_rejection_filter</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, std::size_t <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">target_count</a>)</td></tr>
<tr class="memdesc:ab818126518017939773c8a43bd92fc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly retains a fixed number of points from the input set.  <br /></td></tr>
<tr class="separator:ab818126518017939773c8a43bd92fc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66183362443c104da098224df9bcd2a1" id="r_a66183362443c104da098224df9bcd2a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:a66183362443c104da098224df9bcd2a1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a66183362443c104da098224df9bcd2a1">random_rejection_filter</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">float</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">keep_fraction</a>)</td></tr>
<tr class="memdesc:a66183362443c104da098224df9bcd2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly retains a fraction of the input points.  <br /></td></tr>
<tr class="separator:a66183362443c104da098224df9bcd2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a1e19fa663340b68ad9f74e740a6c0" id="r_a54a1e19fa663340b68ad9f74e740a6c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a54a1e19fa663340b68ad9f74e740a6c0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a54a1e19fa663340b68ad9f74e740a6c0">random_walk_filaments</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">n_filaments</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filament_count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">step_size</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">persistence</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0.8), <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">gaussian_sigma</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0), <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">gaussian_samples</a>=0, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; *<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p_distances</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">nullptr</a>)</td></tr>
<tr class="memdesc:a54a1e19fa663340b68ad9f74e740a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate random walk filaments in N dimensions with optional Gaussian thickness.  <br /></td></tr>
<tr class="separator:a54a1e19fa663340b68ad9f74e740a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df" id="r_a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a9c8c5679d987d3023b9d3beffd81e6df">filter_points_in_range</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>)</td></tr>
<tr class="memdesc:a9c8c5679d987d3023b9d3beffd81e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points that lie within the specified axis-aligned bounding box.  <br /></td></tr>
<tr class="separator:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a" id="r_a5350b843397a5bf2a748115108ffa21a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Func</a> &gt; </td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5350b843397a5bf2a748115108ffa21a">filter_points_function</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Func</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">fn</a>)</td></tr>
<tr class="memdesc:a5350b843397a5bf2a748115108ffa21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points using a user-provided function.  <br /></td></tr>
<tr class="separator:a5350b843397a5bf2a748115108ffa21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862" id="r_a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a2b8197901114d1c4fd6cfe19efcd3862">refit_points_to_range</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">target_ranges</a>)</td></tr>
<tr class="memdesc:a2b8197901114d1c4fd6cfe19efcd3862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly remap a set of points to fit within the specified axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850" id="r_a7addf1455112b7895f8de7c475eed850"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">rescale_points</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>)</td></tr>
<tr class="memdesc:a7addf1455112b7895f8de7c475eed850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales normalized points (in [0, 1]) to specified axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a7addf1455112b7895f8de7c475eed850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527" id="r_a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a29ab0a94bbe26a22cb87bf8f44703527">rejection_sampling</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">axis_ranges</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">density_fn</a>, std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">seed</a>=std::nullopt)</td></tr>
<tr class="memdesc:a29ab0a94bbe26a22cb87bf8f44703527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random points using rejection sampling based on a user-defined density function.  <br /></td></tr>
<tr class="separator:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18" id="r_aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aed8a3217a801c5b5706f4bcc3306bb18">relaxation_ktree</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k_neighbors</a>=8, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">step_size</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0.1), <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">iterations</a>=10)</td></tr>
<tr class="memdesc:aed8a3217a801c5b5706f4bcc3306bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree.  <br /></td></tr>
<tr class="separator:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002" id="r_a802637e81218193c0e65266c8075f002"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a802637e81218193c0e65266c8075f002">save_points_to_csv</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filename</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">write_header</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a>)</td></tr>
<tr class="memdesc:a802637e81218193c0e65266c8075f002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a set of N-dimensional points to a CSV file.  <br /></td></tr>
<tr class="separator:a802637e81218193c0e65266c8075f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b92b660faab5030374ba2dee9f89810" id="r_a5b92b660faab5030374ba2dee9f89810"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; </td></tr>
<tr class="memitem:a5b92b660faab5030374ba2dee9f89810"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5b92b660faab5030374ba2dee9f89810">save_vector_to_csv</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filename</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">values</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">write_header</a>=<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">header_name</a>=&quot;value&quot;)</td></tr>
<tr class="memdesc:a5b92b660faab5030374ba2dee9f89810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a 1D vector of values to a CSV file.  <br /></td></tr>
<tr class="separator:a5b92b660faab5030374ba2dee9f89810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964f314c19f0b1300d513bce618c5954" id="r_a964f314c19f0b1300d513bce618c5954"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a964f314c19f0b1300d513bce618c5954"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a>+1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a964f314c19f0b1300d513bce618c5954">add_dimension</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">new_dimension</a>)</td></tr>
<tr class="memdesc:a964f314c19f0b1300d513bce618c5954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension to a set of points.  <br /></td></tr>
<tr class="separator:a964f314c19f0b1300d513bce618c5954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b8f3f26e63374a7a724a0cd3d9356" id="r_ac42b8f3f26e63374a7a724a0cd3d9356"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac42b8f3f26e63374a7a724a0cd3d9356"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac42b8f3f26e63374a7a724a0cd3d9356">extract_clusters</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a>)</td></tr>
<tr class="memdesc:ac42b8f3f26e63374a7a724a0cd3d9356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract clusters of points given DBSCAN (or any clustering) labels.  <br /></td></tr>
<tr class="separator:ac42b8f3f26e63374a7a724a0cd3d9356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677f90d97b1dcfeaa2ecc299ee37f5bf" id="r_a677f90d97b1dcfeaa2ecc299ee37f5bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a677f90d97b1dcfeaa2ecc299ee37f5bf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a677f90d97b1dcfeaa2ecc299ee37f5bf">merge_by_dimension</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">components</a>)</td></tr>
<tr class="memdesc:a677f90d97b1dcfeaa2ecc299ee37f5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a list of N-dimensional points from N separate coordinate vectors.  <br /></td></tr>
<tr class="separator:a677f90d97b1dcfeaa2ecc299ee37f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172358f05108b5cabdac4e43ab309ab2" id="r_a172358f05108b5cabdac4e43ab309ab2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:a172358f05108b5cabdac4e43ab309ab2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a172358f05108b5cabdac4e43ab309ab2">normalize_points</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>)</td></tr>
<tr class="memdesc:a172358f05108b5cabdac4e43ab309ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the coordinates of a set of points along each axis to the range [0, 1].  <br /></td></tr>
<tr class="separator:a172358f05108b5cabdac4e43ab309ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b" id="r_af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af6737277b9cc05d5f2ab248f17baea3b">split_by_dimension</a> (<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>)</td></tr>
<tr class="memdesc:af6737277b9cc05d5f2ab248f17baea3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a list of N-dimensional points into N separate coordinate vectors.  <br /></td></tr>
<tr class="separator:af6737277b9cc05d5f2ab248f17baea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9ecfd54020ea95c133d1fc99cf4f75a" name="ac9ecfd54020ea95c133d1fc99cf4f75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ecfd54020ea95c133d1fc99cf4f75a">&#9670;&#160;</a></span>KDTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">using</a> <a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">ps::KDTree</a> = <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typedef</a> nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a>&gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a>&gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a964f314c19f0b1300d513bce618c5954" name="a964f314c19f0b1300d513bce618c5954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964f314c19f0b1300d513bce618c5954">&#9670;&#160;</a></span>add_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a>+1 &gt; &gt; ps::add_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new dimension to a set of points. </p>
<p>This function takes a vector of points of dimension N and appends a new coordinate to each point, producing a new vector of points of dimension N+1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type of the coordinates (e.g., float, double, int). </td></tr>
    <tr><td class="paramname">N</td><td>Current number of dimensions in the input points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of input points of dimension N. </td></tr>
    <tr><td class="paramname">new_dimension</td><td>Vector of values for the new dimension. Must have the same size as <code>points</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of points of dimension N+1, with the new dimension appended.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_errorifthesizeof`points`and`new_dimension`donotmatch.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function creates a new vector of points with an increased dimension count, since the type Point&lt;T, N&gt; is distinct from <a class="el" href="structps_1_1Point.html" title="A fixed-size N-dimensional point/vector class.">Point</a>&lt;T, N+1&gt;.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = { {{1.0f, 2.0f}}, {{3.0f, 4.0f}}};</div>
<div class="line">std::vector&lt;float&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">z_values</a> = { 10.0f, 20.0f };</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points3D</a> = <a class="code hl_function" href="namespaceps.html#a964f314c19f0b1300d513bce618c5954">add_dimension</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">z_values</a>);</div>
<div class="line"><span class="comment">// points3D now contains {{1.0f, 2.0f, 10.0f}}, {{3.0f, 4.0f, 20.0f}}</span></div>
<div class="ttc" id="anamespaceps_html_a10763ef2a872aa9eddb48ea341cd6f69"><div class="ttname"><a href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; random(size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdoc">Generates a specified number of uniformly distributed random points in N-dimensional space.</div><div class="ttdef"><b>Definition</b> random.hpp:66</div></div>
<div class="ttc" id="anamespaceps_html_a964f314c19f0b1300d513bce618c5954"><div class="ttname"><a href="namespaceps.html#a964f314c19f0b1300d513bce618c5954">ps::add_dimension</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N+1 &gt; &gt; add_dimension(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::vector&lt; T &gt; &amp;new_dimension)</div><div class="ttdoc">Add a new dimension to a set of points.</div><div class="ttdef"><b>Definition</b> utils.hpp:142</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae96771d03336a56988d82df95e8a797a" name="ae96771d03336a56988d82df95e8a797a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96771d03336a56988d82df95e8a797a">&#9670;&#160;</a></span>angle_distribution_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &gt; ps::angle_distribution_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>bin_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>k_neighbors</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the angular distribution function (ADF) using nearest neighbors. </p>
<p>The angular distribution function (ADF) measures the distribution of bond angles formed by a point and pairs of its nearest neighbors.</p>
<ul>
<li>Flat distribution → random uniform points.</li>
<li>Peaks at characteristic angles → local order (e.g. hexagonal lattice peaks at 60°).</li>
<li>Depletions → angular avoidance due to constraints or repulsion.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (float, double, ...) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of points (N &gt;= 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points </td></tr>
    <tr><td class="paramname">bin_width</td><td>Width of angle bins (in radians) </td></tr>
    <tr><td class="paramname">k_neighbors</td><td>Number of neighbors used for angle calculation (default: 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt;<ul>
<li>First: bin centers (angles in radians)</li>
<li>Second: normalized ADF values</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;double, 2&gt;&gt; pts = {</div>
<div class="line">    {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">theta</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">g_theta</a>] = <a class="code hl_function" href="namespaceps.html#ae96771d03336a56988d82df95e8a797a">angle_distribution_neighbors</a>(pts, 0.1, 6);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> = 0; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> &lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">theta</a>.size(); ++<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>)</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;θ=&quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">theta</a>[<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>] &lt;&lt; <span class="stringliteral">&quot;g(θ)=&quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">g_theta</a>[<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>] &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceps_html_ae96771d03336a56988d82df95e8a797a"><div class="ttname"><a href="namespaceps.html#ae96771d03336a56988d82df95e8a797a">ps::angle_distribution_neighbors</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt; angle_distribution_neighbors(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, T bin_width, size_t k_neighbors=8)</div><div class="ttdoc">Compute the angular distribution function (ADF) using nearest neighbors.</div><div class="ttdef"><b>Definition</b> metrics.hpp:48</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb0bd4806c7e79eddef0e1263740ae28" name="adb0bd4806c7e79eddef0e1263740ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bd4806c7e79eddef0e1263740ae28">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; ps::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d453a5cb2885c1a8d264ff96303f627" name="a5d453a5cb2885c1a8d264ff96303f627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d453a5cb2885c1a8d264ff96303f627">&#9670;&#160;</a></span>dbscan_clustering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; ps::dbscan_clustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>min_pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Density-Based Spatial Clustering of Applications with Noise (DBSCAN). </p>
<p>Groups points into clusters based on density: a point is a core if it has at least <code>min_pts</code> neighbors within distance <code>eps</code>. Clusters are formed by expanding from core points. Noise points remain unclustered.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (float/double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input point cloud. </td></tr>
    <tr><td class="paramname">eps</td><td>Neighborhood radius for density check. </td></tr>
    <tr><td class="paramname">min_pts</td><td>Minimum neighbors (including self) to be a core point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cluster labels (-1 = noise, 0..k = cluster IDs).</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dbscan&lt;double,2&gt;</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, 0.05, 5);</div>
</div><!-- fragment --></dd></dl>
<p>This assigns each 2D point either to a cluster ID or -1 (noise).</p>
<div class="image">
<img src="metrics_dbscan_clustering.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="ac0b74f22d427d199ab0df8f6942d3b11" name="ac0b74f22d427d199ab0df8f6942d3b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b74f22d427d199ab0df8f6942d3b11">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> ps::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f4a1110a40bf1c6a687182db6b4b94" name="ad1f4a1110a40bf1c6a687182db6b4b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4a1110a40bf1c6a687182db6b4b94">&#9670;&#160;</a></span>distance_rejection_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::distance_rejection_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a set of points using a greedy distance-based rejection. </p>
<p>Points are added one by one. If a point is at least <code>min_dist</code> away from all previously accepted points, it is kept. Otherwise, it is rejected.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of candidate points </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum allowed distance between two accepted points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; of filtered points</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random&lt;float, 2&gt;</a>(1000, {{0,1},{0,1}});</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filtered</a> = <a class="code hl_function" href="namespaceps.html#ad1f4a1110a40bf1c6a687182db6b4b94">ps::distance_rejection_filter</a>(pts, 0.05f);</div>
<div class="ttc" id="anamespaceps_html_ad1f4a1110a40bf1c6a687182db6b4b94"><div class="ttname"><a href="namespaceps.html#ad1f4a1110a40bf1c6a687182db6b4b94">ps::distance_rejection_filter</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; distance_rejection_filter(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, T min_dist)</div><div class="ttdoc">Filters a set of points using a greedy distance-based rejection.</div><div class="ttdef"><b>Definition</b> distance_rejection_filter.hpp:35</div></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_distance_rejection_filter.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="af23d114903fd5cb3ccb19d3e64183632" name="af23d114903fd5cb3ccb19d3e64183632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d114903fd5cb3ccb19d3e64183632">&#9670;&#160;</a></span>distance_rejection_filter_warped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::distance_rejection_filter_warped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points based on spatially-varying minimal distance constraints. </p>
<p>A scale function is used to modulate the minimum allowed distance for each point. The base distance <code>base_min_dist</code> is scaled by the value returned by <code>scale_fn(p)</code>, allowing for adaptive sampling densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
    <tr><td class="paramname">ScaleFn</td><td>Callable returning a scalar scale factor for a given point</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of candidate points </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Base minimum allowed distance </td></tr>
    <tr><td class="paramname">scale_fn</td><td>Function providing a local scale factor per point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A filtered set of points with variable spacing</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a> = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a>&amp; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> 0.5f + 0.5f * std::sin(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] * 3.1415f); <span class="comment">// Varies between 0.5 and 1</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random&lt;float, 2&gt;</a>(1000, {{0,1},{0,1}});</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filtered</a> = <a class="code hl_function" href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">ps::distance_rejection_filter_warped</a>(pts, 0.05f, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>);</div>
<div class="ttc" id="anamespaceps_html_af23d114903fd5cb3ccb19d3e64183632"><div class="ttname"><a href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">ps::distance_rejection_filter_warped</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; distance_rejection_filter_warped(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, T base_min_dist, ScaleFn scale_fn)</div><div class="ttdoc">Filters points based on spatially-varying minimal distance constraints.</div><div class="ttdef"><b>Definition</b> distance_rejection_filter.hpp:101</div></div>
<div class="ttc" id="astructps_1_1Point_html"><div class="ttname"><a href="structps_1_1Point.html">ps::Point</a></div><div class="ttdoc">A fixed-size N-dimensional point/vector class.</div><div class="ttdef"><b>Definition</b> point.hpp:39</div></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_distance_rejection_filter_warped.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="aecf2b150ec16bf286e6a7b462c4d5808" name="aecf2b150ec16bf286e6a7b462c4d5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf2b150ec16bf286e6a7b462c4d5808">&#9670;&#160;</a></span>distance_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> ps::distance_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a824a8963ef7b15c01da0f1f9c90eee" name="a9a824a8963ef7b15c01da0f1f9c90eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a824a8963ef7b15c01da0f1f9c90eee">&#9670;&#160;</a></span>distance_to_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; ps::distance_to_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance of each point to the domain boundary. </p>
<p>The domain is defined by axis-aligned ranges in each dimension. For each point, the returned distance is the smallest Euclidean distance to any boundary plane of the domain.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type. </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points to evaluate. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Vector of size N, where each element is a std::pair&lt;min, max&gt; defining the domain limits in that dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; Distances of each point to the nearest domain boundary.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assumes the domain is a rectangular box aligned with the coordinate axes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;double, 2&gt;&gt; pts = { {0.2, 0.8}, {0.9, 0.1} };</div>
<div class="line">std::vector&lt;std::pair&lt;double, double&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = { {0.0, 1.0}, {0.0, 1.0} };</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">distances</a> = <a class="code hl_function" href="namespaceps.html#a9a824a8963ef7b15c01da0f1f9c90eee">distance_to_boundary</a>(pts, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>);</div>
<div class="line"><span class="comment">// distances[0] -&gt; 0.2</span></div>
<div class="line"><span class="comment">// distances[1] -&gt; 0.1</span></div>
<div class="ttc" id="anamespaceps_html_a9a824a8963ef7b15c01da0f1f9c90eee"><div class="ttname"><a href="namespaceps.html#a9a824a8963ef7b15c01da0f1f9c90eee">ps::distance_to_boundary</a></div><div class="ttdeci">std::vector&lt; T &gt; distance_to_boundary(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges)</div><div class="ttdoc">Compute the distance of each point to the domain boundary.</div><div class="ttdef"><b>Definition</b> metrics.hpp:151</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ace7642868199df621df9139e5179767b" name="ace7642868199df621df9139e5179767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7642868199df621df9139e5179767b">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> ps::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac42b8f3f26e63374a7a724a0cd3d9356" name="ac42b8f3f26e63374a7a724a0cd3d9356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42b8f3f26e63374a7a724a0cd3d9356">&#9670;&#160;</a></span>extract_clusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &gt; ps::extract_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract clusters of points given DBSCAN (or any clustering) labels. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">N</td><td>Dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input point cloud. </td></tr>
    <tr><td class="paramname">labels</td><td>Cluster labels (-2 = noise, -1 = unvisited, 0..k = cluster IDs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of clusters, each cluster is a vector of points.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a>   = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dbscan&lt;double,2&gt;</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, 0.05, 5);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">clusters</a> = <a class="code hl_function" href="namespaceps.html#ac42b8f3f26e63374a7a724a0cd3d9356">extract_clusters</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a>);</div>
<div class="ttc" id="anamespaceps_html_ac42b8f3f26e63374a7a724a0cd3d9356"><div class="ttname"><a href="namespaceps.html#ac42b8f3f26e63374a7a724a0cd3d9356">ps::extract_clusters</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Point&lt; T, N &gt; &gt; &gt; extract_clusters(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::vector&lt; int &gt; &amp;labels)</div><div class="ttdoc">Extract clusters of points given DBSCAN (or any clustering) labels.</div><div class="ttdef"><b>Definition</b> utils.hpp:180</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5350b843397a5bf2a748115108ffa21a" name="a5350b843397a5bf2a748115108ffa21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5350b843397a5bf2a748115108ffa21a">&#9670;&#160;</a></span>filter_points_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Func</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::filter_points_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Func</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points using a user-provided function. </p>
<p>Keeps only the points for which the provided function <code>fn(p)</code> does not return zero. This can be used to apply custom masks, implicit surface functions, etc.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates. </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">Func</td><td>Callable that takes a Point&lt;T, N&gt; and returns a value convertible to T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of input points. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function that returns a non-zero value if the point should be kept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of filtered points.</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.f, 0.f}, {1.f, 1.f}, {2.f, 2.f}};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">lambda</a> = [](<span class="keyword">const</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Point&lt;float, 2&gt;</a> &amp;<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] + <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[1] &lt; 2.5f) ? 1.f : 0.f;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filtered</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::filter_points_function&lt;float, 2&gt;</a>(pts, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">lambda</a>);</div>
<div class="line"><span class="comment">// Keeps only { {0.f, 0.f}, {1.f, 1.f} }</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9c8c5679d987d3023b9d3beffd81e6df" name="a9c8c5679d987d3023b9d3beffd81e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8c5679d987d3023b9d3beffd81e6df">&#9670;&#160;</a></span>filter_points_in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::filter_points_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points that lie within the specified axis-aligned bounding box. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of input points to filter. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box ranges for each dimension (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing only the points that lie within all specified axis ranges.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentifaxis_rangesareill-formed(e.g.,min</td><td>&gt; max).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.5f, 0.5f}, {2.f, 3.f}, {-1.f, 0.f} };</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">filtered</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::filter_points_in_range&lt;float, 2&gt;</a>(pts, {{{0.f, 1.f},</div>
<div class="line">                                                           {0.f, 1.f}}});</div>
<div class="line"><span class="comment">// filtered now contains only { {0.5f, 0.5f} }</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91a0bac33731ed899845c6081c117db2" name="a91a0bac33731ed899845c6081c117db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a0bac33731ed899845c6081c117db2">&#9670;&#160;</a></span>first_neighbor_distance_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; ps::first_neighbor_distance_squared </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the squared distance to the nearest neighbor for each point. </p>
<p>This function builds a KD-tree from a given set of N-dimensional points and computes, for each point, the squared distance to its closest neighbor.</p>
<p>The KD-tree search uses <code>nanoflann</code> for efficient nearest neighbor queries.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of N-dimensional points. Note:** This vector is passed by non-const reference because the KD-tree adaptor may require mutable access, but the function does not modify the contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the squared distances to the first neighbor for each point, in the same order as the input points.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Point3f</a> = <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 3&gt;</a>;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point3f&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = {</div>
<div class="line">    {0.0f, 0.0f, 0.0f},</div>
<div class="line">    {1.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 1.0f, 0.0f},</div>
<div class="line">    {1.0f, 1.0f, 0.0f}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;float&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">distances_sq</a> = <a class="code hl_function" href="namespaceps.html#a91a0bac33731ed899845c6081c117db2">first_neighbor_distance_squared</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// distances_sq[i] contains the squared distance to the closest neighbor of points[i].</span></div>
<div class="ttc" id="anamespaceps_html_a91a0bac33731ed899845c6081c117db2"><div class="ttname"><a href="namespaceps.html#a91a0bac33731ed899845c6081c117db2">ps::first_neighbor_distance_squared</a></div><div class="ttdeci">std::vector&lt; T &gt; first_neighbor_distance_squared(std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points)</div><div class="ttdoc">Computes the squared distance to the nearest neighbor for each point.</div><div class="ttdef"><b>Definition</b> metrics.hpp:217</div></div>
</div><!-- fragment --><div class="image">
<img src="metrics_first_neighbor_distance.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a0e4055582214237ee9f21369133e6194" name="a0e4055582214237ee9f21369133e6194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4055582214237ee9f21369133e6194">&#9670;&#160;</a></span>function_rejection_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::function_rejection_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a>&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points based on a spatial probability (density) function. </p>
<p>Each point is accepted with a probability given by <code>density_fn(p)</code>, which should return a value in [0, 1]. This is useful for sampling from a non-uniform spatial distribution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
    <tr><td class="paramname">DensityFn</td><td>Callable type with signature <code>T(const <a class="el" href="structps_1_1Point.html" title="A fixed-size N-dimensional point/vector class.">Point</a>&lt;T, N&gt;&amp;)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input candidate points </td></tr>
    <tr><td class="paramname">density_fn</td><td>Function returning acceptance probability for each point </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for reproducibility </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; of accepted points</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">field</a> = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a>&amp; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> 0.5f + 0.5f * std::sin(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] * 10.0f); <span class="comment">// Spatial density</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">accepted</a> = <a class="code hl_function" href="namespaceps.html#a0e4055582214237ee9f21369133e6194">ps::function_rejection_filter</a>(pts, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">field</a>);</div>
<div class="ttc" id="anamespaceps_html_a0e4055582214237ee9f21369133e6194"><div class="ttname"><a href="namespaceps.html#a0e4055582214237ee9f21369133e6194">ps::function_rejection_filter</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; function_rejection_filter(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, DensityFn density_fn, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdoc">Filters points based on a spatial probability (density) function.</div><div class="ttdef"><b>Definition</b> function_rejection_filter.hpp:36</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0efaff8017d5a171ffdf0ed0201bd65d" name="a0efaff8017d5a171ffdf0ed0201bd65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efaff8017d5a171ffdf0ed0201bd65d">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>cluster_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates clustered points around random centers uniformly sampled in a bounding box. </p>
<p>Cluster centers are randomly sampled within the provided <code>axis_ranges</code>, and each cluster then has <code>points_per_cluster</code> points sampled from a Gaussian distribution centered at the cluster's location, with a specified standard deviation <code>spread</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_count</td><td>Number of cluster centers to generate </td></tr>
    <tr><td class="paramname">points_per_cluster</td><td>Number of points per cluster </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box ranges for each dimension </td></tr>
    <tr><td class="paramname">spread</td><td>Standard deviation of the Gaussian spread </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of clustered points</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">clustered</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::gaussian_clusters&lt;float, 2&gt;</a>(</div>
<div class="line">    5, 100,</div>
<div class="line">    {{{0,1}, {0,1}}}, 0.03f</div>
<div class="line">);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a913ab9d687ee42d04488e5eb0373e23a" name="a913ab9d687ee42d04488e5eb0373e23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913ab9d687ee42d04488e5eb0373e23a">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>cluster_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates clustered points around provided cluster centers using a Gaussian distribution. </p>
<p>For each cluster center, this function generates <code>points_per_cluster</code> points where each coordinate is sampled from a normal distribution centered at the coordinate of the cluster center with standard deviation <code>spread</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_centers</td><td>A vector of cluster center points </td></tr>
    <tr><td class="paramname">points_per_cluster</td><td>Number of points to generate per cluster </td></tr>
    <tr><td class="paramname">spread</td><td>Standard deviation of the Gaussian spread </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of clustered points</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">centers</a> = {</div>
<div class="line">    {0.2f, 0.2f},</div>
<div class="line">    {0.8f, 0.8f}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">clustered</a> = <a class="code hl_function" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">ps::gaussian_clusters</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">centers</a>, 100, 0.05f);</div>
<div class="ttc" id="anamespaceps_html_a913ab9d687ee42d04488e5eb0373e23a"><div class="ttname"><a href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">ps::gaussian_clusters</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; gaussian_clusters(std::vector&lt; Point&lt; T, N &gt; &gt; cluster_centers, size_t points_per_cluster, T spread, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdoc">Generates clustered points around provided cluster centers using a Gaussian distribution.</div><div class="ttdef"><b>Definition</b> gaussian_clusters.hpp:42</div></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_gaussian_clusters_wrapped.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a898bca65491a14a41bfdd50fdc6230b8" name="a898bca65491a14a41bfdd50fdc6230b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898bca65491a14a41bfdd50fdc6230b8">&#9670;&#160;</a></span>generate_random_point_around()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; ps::generate_random_point_around </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81b18395a05f0bb4d483406e79aa9524" name="a81b18395a05f0bb4d483406e79aa9524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b18395a05f0bb4d483406e79aa9524">&#9670;&#160;</a></span>halton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::halton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of quasi-random points using the Halton sequence in N dimensions. </p>
<p>This function generates <code>count</code> points in the unit hypercube using the Halton sequence, then rescales them to fit within the specified axis-aligned bounding box. An optional <code>seed</code> is used as a starting index offset (i.e., a shift) in the sequence to decorrelate multiple calls.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box for each dimension, as min/max pairs </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed that offsets the sequence start index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The generated Halton points rescaled to the bounding box</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::halton&lt;float, 2&gt;</a>(</div>
<div class="line">    1000,</div>
<div class="line">    {{{0, 1}, {0, 1}}}, 42</div>
<div class="line">);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_halton.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="aa8c3b3b3367276f9a194938599d2463b" name="aa8c3b3b3367276f9a194938599d2463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c3b3b3367276f9a194938599d2463b">&#9670;&#160;</a></span>halton_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::halton_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad0cc7bc81f7cac9f0be26177b9986a6" name="aad0cc7bc81f7cac9f0be26177b9986a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cc7bc81f7cac9f0be26177b9986a6">&#9670;&#160;</a></span>hammersley()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::hammersley </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of quasi-random points using the Hammersley sequence in N dimensions. </p>
<p>This function generates <code>count</code> points in the unit hypercube using the Hammersley sequence, then rescales them to fit within the specified axis-aligned bounding box. An optional <code>seed</code> can be used as a starting index offset (i.e., a shift) to decorrelate multiple calls or introduce variation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box for each dimension, as min/max pairs </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed that offsets the sequence start index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The generated Hammersley points rescaled to the bounding box</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::hammersley&lt;float, 3&gt;</a>(</div>
<div class="line">    512,</div>
<div class="line">    {{{-1, 1}, {-1, 1}, {0, 1}}}, 7</div>
<div class="line">);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_hammersley.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="ae21a8c51533330ead4ebe76eed3e72b3" name="ae21a8c51533330ead4ebe76eed3e72b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21a8c51533330ead4ebe76eed3e72b3">&#9670;&#160;</a></span>hammersley_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::hammersley_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a932640b18d76a7e336fc760e9cf5511b" name="a932640b18d76a7e336fc760e9cf5511b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932640b18d76a7e336fc760e9cf5511b">&#9670;&#160;</a></span>importance_resampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::importance_resampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>oversampling_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a>&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a point set via importance resampling from a quasi-random oversampled grid. </p>
<p>This function uses a Halton sequence to create an oversampled set of candidate points in the domain. Each point is assigned a weight based on the provided density function. A discrete distribution is then used to resample <code>count</code> points according to these weights.</p>
<p>The higher the <code>oversampling_ratio</code>, the better the approximation to the target density, at the cost of performance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
    <tr><td class="paramname">DensityFn</td><td>A callable with signature <code>T(const <a class="el" href="structps_1_1Point.html" title="A fixed-size N-dimensional point/vector class.">Point</a>&lt;T, N&gt;&amp;)</code> returning a non-negative density value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to return after resampling </td></tr>
    <tr><td class="paramname">oversampling_ratio</td><td>Number of candidate points to generate as a multiple of <code>count</code> </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the domain of the points </td></tr>
    <tr><td class="paramname">density_fn</td><td>Function mapping a point to a (non-negative) density value </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed to control the random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The resulting resampled point set</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">density</a> = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a> &amp;<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::exp(-10.0f * (<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0]*<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] + <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[1]*<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[1]));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::importance_resampling&lt;float, 2&gt;</a>(</div>
<div class="line">    500, 5,</div>
<div class="line">    {{{-1, 1}, {-1, 1}}}, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">density</a>, 42</div>
<div class="line">);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_importance_resampling.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="aedb5908eae325f054e4f3dd6b9b223af" name="aedb5908eae325f054e4f3dd6b9b223af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb5908eae325f054e4f3dd6b9b223af">&#9670;&#160;</a></span>in_neighborhood()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> ps::in_neighborhood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8525c124fef24618bf574b9b7b1ece8" name="ad8525c124fef24618bf574b9b7b1ece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8525c124fef24618bf574b9b7b1ece8">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>jitter_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stagger_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a point set on a jittered and optionally staggered grid. </p>
<p>This function divides the domain into a grid and places one point in each selected cell. Each point is jittered within its cell, and staggered offsets may be applied depending on the index of higher-dimensional axes. The result is a semi-regular sampling pattern with randomness.</p>
<p>Jittering prevents aliasing, and staggering introduces a controlled shift between alternating cells to improve uniformity and avoid alignment artifacts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of output points (best effort, may be capped by total available cells) </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the sampling domain </td></tr>
    <tr><td class="paramname">jitter_amount</td><td>Per-dimension jitter factor ∈ [0, 1]. A value of 1.0 means full jitter in the cell. </td></tr>
    <tr><td class="paramname">stagger_ratio</td><td>Per-dimension stagger ratio, indicating how much to offset points based on higher dimension parity </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for deterministic jittering and shuffling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; Sampled points</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;float, float&gt;, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a> = {{{0.0f, 1.0f}, {0.0f, 1.0f}}};</div>
<div class="line">std::array&lt;float, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">jitter</a> = {0.8f, 0.8f};</div>
<div class="line">std::array&lt;float, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">stagger</a> = {0.2f, 0.0f};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">samples</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::jittered_grid&lt;float, 2&gt;</a>(256, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">jitter</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">stagger</a>, 42);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_jittered_grid.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="ae90df8db8e751ff4b61298114f092714" name="ae90df8db8e751ff4b61298114f092714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90df8db8e751ff4b61298114f092714">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a jittered grid of points with full jitter and no stagger. </p>
<p>This overload defaults to jittering each dimension fully within its cell and applies no staggering. It is equivalent to calling the full version with <code>jitter_amount</code> filled with 1.0 and <code>stagger_ratio</code> filled with 0.0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the sampling domain </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for deterministic jittering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; Jittered point samples</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;double, double&gt;, 3&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a> = {{{0, 1}, {0, 1}, {0, 1}}};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::jittered_grid&lt;double, 3&gt;</a>(1000, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a>, 1234);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acbef03daefffe13bd08b9b4c0952c00d" name="acbef03daefffe13bd08b9b4c0952c00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbef03daefffe13bd08b9b4c0952c00d">&#9670;&#160;</a></span>kmeans_clustering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> &gt; &gt; ps::kmeans_clustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>k_clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td>
          <td class="paramname"><em>normalize_data</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform k-means clustering on a set of points. </p>
<p>Uses the <code>dkm</code> library to cluster points into <code>k</code> groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type. </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points to cluster. </td></tr>
    <tr><td class="paramname">k_clusters</td><td>Number of clusters. </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Maximum number of iterations for k-means. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt; std::vector&lt;Point&lt;T, N&gt;&gt;, std::vector&lt;size_t&gt; &gt;<ul>
<li>First element: vector of cluster centroids.</li>
<li>Second element: cluster index assignment for each point.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = {</div>
<div class="line">    {0.1f, 0.2f}, {0.15f, 0.22f}, {0.8f, 0.75f}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">centroids</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a>] = <a class="code hl_function" href="namespaceps.html#acbef03daefffe13bd08b9b4c0952c00d">kmeans_clustering</a>(pts, 2);</div>
<div class="line"><span class="comment">// centroids.size() == 2</span></div>
<div class="line"><span class="comment">// labels.size() == pts.size()</span></div>
<div class="ttc" id="anamespaceps_html_acbef03daefffe13bd08b9b4c0952c00d"><div class="ttname"><a href="namespaceps.html#acbef03daefffe13bd08b9b4c0952c00d">ps::kmeans_clustering</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; Point&lt; T, N &gt; &gt;, std::vector&lt; size_t &gt; &gt; kmeans_clustering(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, size_t k_clusters, bool normalize_data=true, size_t max_iterations=100)</div><div class="ttdoc">Perform k-means clustering on a set of points.</div><div class="ttdef"><b>Definition</b> kmeans_clustering.hpp:41</div></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="metrics_kmeans_clustering.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a9ca14831de223ff62a6c3ec93e96a7c0" name="a9ca14831de223ff62a6c3ec93e96a7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca14831de223ff62a6c3ec93e96a7c0">&#9670;&#160;</a></span>latin_hypercube_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::latin_hypercube_sampling </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>sample_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates samples using Latin Hypercube Sampling (LHS). </p>
<p>This function produces <code>sample_count</code> evenly stratified samples across each dimension defined in <code>axis_ranges</code>. Each dimension is divided into equal intervals (strata), and one point is randomly selected from each stratum with added jitter. The strata are randomly permuted across dimensions to avoid correlation.</p>
<p>This method ensures uniform coverage of the space while maintaining randomness, making it useful in Monte Carlo integration, surrogate modeling, and probabilistic sampling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Array of N (min, max) pairs defining the domain in each dimension </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for reproducible randomness</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; of LHS-sampled points</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;float, float&gt;, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">range</a> = {{{0.0f, 1.0f}, {0.0f, 1.0f}}};</div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">latin_hypercube_sampling&lt;float, 2&gt;</a>(1000, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">range</a>);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_latin_hypercube_sampling.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a38d89dd8b52a63eabb39ef5e425d5746" name="a38d89dd8b52a63eabb39ef5e425d5746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d89dd8b52a63eabb39ef5e425d5746">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> ps::length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3e161560ad3000aa4e2218291b169c" name="a7c3e161560ad3000aa4e2218291b169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3e161560ad3000aa4e2218291b169c">&#9670;&#160;</a></span>length_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> ps::length_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79914e9fc2dd02bacd38e9bd32e21baa" name="a79914e9fc2dd02bacd38e9bd32e21baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79914e9fc2dd02bacd38e9bd32e21baa">&#9670;&#160;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; ps::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accc008d79bdad63b0acf9a4e627cc479" name="accc008d79bdad63b0acf9a4e627cc479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc008d79bdad63b0acf9a4e627cc479">&#9670;&#160;</a></span>local_density_knn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; ps::local_density_knn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>k</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute local point density based on k-nearest neighbors in N dimensions. </p>
<p>The density at each point is estimated as:  </p><p class="formulaDsp">
\[
\rho_i = \frac{k}{V_N r_i^N}
\]
</p>
<p> where (r_i) is the distance to the k-th nearest neighbor, (V_N) is the volume of the unit N-ball:  </p><p class="formulaDsp">
\[
V_N = \frac{\pi^{N/2}}{\Gamma(N/2 + 1)}
\]
</p>
<p> and (\Gamma) is the gamma function. This generalizes to any dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points in N-dimensional space. </td></tr>
    <tr><td class="paramname">k</td><td>Number of nearest neighbors to use for density estimation (should be &gt;= 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of local densities for each point.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;double,3&gt;&gt; pts = ...; <span class="comment">// 3D points</span></div>
<div class="line"><span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k</a> = 8;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">densities</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">local_density_knn&lt;double,3&gt;</a>(pts, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">k</a>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Works in any dimension (N).</li>
<li>High k gives smoother density estimates, low k captures local fluctuations.</li>
<li>The resulting density units are “points per unit volume” in N dimensions.</li>
</ul>
</dd></dl>
<div class="image">
<img src="metrics_local_density_knn.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a677f90d97b1dcfeaa2ecc299ee37f5bf" name="a677f90d97b1dcfeaa2ecc299ee37f5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677f90d97b1dcfeaa2ecc299ee37f5bf">&#9670;&#160;</a></span>merge_by_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::merge_by_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs a list of N-dimensional points from N separate coordinate vectors. </p>
<p>This function takes N vectors—each representing one coordinate axis—and combines them into a single vector of N-dimensional points. It is the inverse operation of <code>split_by_dimension</code>.</p>
<p>All coordinate vectors must have the same length.</p>
<p>For example, given:</p><ul>
<li>dimension 0: [1, 4, 7]</li>
<li>dimension 1: [2, 5, 8]</li>
<li>dimension 2: [3, 6, 9]</li>
</ul>
<p>The result will be: [(1,2,3), (4,5,6), (7,8,9)]</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">components</td><td>An array of N vectors, each containing values for one coordinate axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of N-dimensional points reconstructed from the coordinate vectors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentifthecoordinatevectorsdonotallhavethesame</td><td>length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::vector&lt;float&gt;, 3&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">components</a> = {{</div>
<div class="line">    {1.0f, 4.0f, 7.0f},  <span class="comment">// x</span></div>
<div class="line">    {2.0f, 5.0f, 8.0f},  <span class="comment">// y</span></div>
<div class="line">    {3.0f, 6.0f, 9.0f}   <span class="comment">// z</span></div>
<div class="line">}};</div>
<div class="line">std::vector&lt;Point&lt;float, 3&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a677f90d97b1dcfeaa2ecc299ee37f5bf">merge_by_dimension</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">components</a>);</div>
<div class="ttc" id="anamespaceps_html_a677f90d97b1dcfeaa2ecc299ee37f5bf"><div class="ttname"><a href="namespaceps.html#a677f90d97b1dcfeaa2ecc299ee37f5bf">ps::merge_by_dimension</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; merge_by_dimension(const std::array&lt; std::vector&lt; T &gt;, N &gt; &amp;components)</div><div class="ttdoc">Reconstructs a list of N-dimensional points from N separate coordinate vectors.</div><div class="ttdef"><b>Definition</b> utils.hpp:245</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac29744e12116f882d8a620a3fd02d72d" name="ac29744e12116f882d8a620a3fd02d72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29744e12116f882d8a620a3fd02d72d">&#9670;&#160;</a></span>nearest_neighbors_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> &gt; &gt; ps::nearest_neighbors_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>k_neighbors</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest neighbors for each point in a set. </p>
<p>This function uses a KD-tree to search for the k nearest neighbors of each point in the input set, returning their indices. The search excludes the query point itself.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of N-dimensional points. </td></tr>
    <tr><td class="paramname">k_neighbors</td><td>Number of nearest neighbors to return for each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector where each element is a vector of indices representing the nearest neighbors of the corresponding point in <code>points</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The KD-tree is rebuilt internally for the search.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 3&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = {</div>
<div class="line">    {0.0f, 0.0f, 0.0f},</div>
<div class="line">    {1.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 1.0f, 0.0f},</div>
<div class="line">    {1.0f, 1.0f, 0.0f}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">neighbors</a> = <a class="code hl_function" href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">nearest_neighbors_indices</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>, 2);</div>
<div class="line"><span class="comment">// neighbors[0] might contain {1, 2}</span></div>
<div class="line"><span class="comment">// neighbors[1] might contain {0, 3}</span></div>
<div class="ttc" id="anamespaceps_html_ac29744e12116f882d8a620a3fd02d72d"><div class="ttname"><a href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">ps::nearest_neighbors_indices</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; size_t &gt; &gt; nearest_neighbors_indices(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, size_t k_neighbors=8)</div><div class="ttdoc">Finds the nearest neighbors for each point in a set.</div><div class="ttdef"><b>Definition</b> metrics.hpp:359</div></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="metrics_nearest_neighbors_indices.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a172358f05108b5cabdac4e43ab309ab2" name="a172358f05108b5cabdac4e43ab309ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172358f05108b5cabdac4e43ab309ab2">&#9670;&#160;</a></span>normalize_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a> ps::normalize_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the coordinates of a set of points along each axis to the range [0, 1]. </p>
<p>This function finds the minimum and maximum value for each axis across all points and rescales each coordinate so that the minimum becomes 0 and the maximum becomes 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type of the coordinates (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions in each point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points to normalize. The points are modified in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If all points have the same value along a given axis, the corresponding normalized coordinate will be set to 0 for that axis.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 3&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = {</div>
<div class="line">    {{1.0f, 5.0f, 10.0f}},</div>
<div class="line">    {{3.0f, 15.0f, 20.0f}}</div>
<div class="line">};</div>
<div class="line"><a class="code hl_function" href="namespaceps.html#a172358f05108b5cabdac4e43ab309ab2">normalize_points</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>);</div>
<div class="line"><span class="comment">// Now points coordinates are scaled in [0, 1] along each axis</span></div>
<div class="ttc" id="anamespaceps_html_a172358f05108b5cabdac4e43ab309ab2"><div class="ttname"><a href="namespaceps.html#a172358f05108b5cabdac4e43ab309ab2">ps::normalize_points</a></div><div class="ttdeci">void normalize_points(std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points)</div><div class="ttdoc">Normalize the coordinates of a set of points along each axis to the range [0, 1].</div><div class="ttdef"><b>Definition</b> utils.hpp:298</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7de6090e2c8291401816be9bc6cda914" name="a7de6090e2c8291401816be9bc6cda914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6090e2c8291401816be9bc6cda914">&#9670;&#160;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; ps::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fd3a6df3727a04f9baba3b8b87a903b" name="a6fd3a6df3727a04f9baba3b8b87a903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd3a6df3727a04f9baba3b8b87a903b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd4dc781f43ba8a50daa139682846d4b" name="acd4dc781f43ba8a50daa139682846d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4dc781f43ba8a50daa139682846d4b">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd6fe71db1c4df607bfdace9dffb5b4" name="abfd6fe71db1c4df607bfdace9dffb5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6fe71db1c4df607bfdace9dffb5b4">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9ee1cf5d335276b7fabe6f1daddf1b0" name="af9ee1cf5d335276b7fabe6f1daddf1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ee1cf5d335276b7fabe6f1daddf1b0">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a366ef094d65da865384b6fb77aac5d5f" name="a366ef094d65da865384b6fb77aac5d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ef094d65da865384b6fb77aac5d5f">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe774cb61bde6358f8a7024c42db9804" name="afe774cb61bde6358f8a7024c42db9804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe774cb61bde6358f8a7024c42db9804">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa369956286bc3f09dfdc146a5b2a49f1" name="aa369956286bc3f09dfdc146a5b2a49f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa369956286bc3f09dfdc146a5b2a49f1">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79196b5b8a95ad9d3bc2ad698425944f" name="a79196b5b8a95ad9d3bc2ad698425944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79196b5b8a95ad9d3bc2ad698425944f">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a585704d3f738c5eb899810fc9308a60e" name="a585704d3f738c5eb899810fc9308a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585704d3f738c5eb899810fc9308a60e">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6663b4f1e9c5ee48e2bf6e1896430580" name="a6663b4f1e9c5ee48e2bf6e1896430580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6663b4f1e9c5ee48e2bf6e1896430580">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a340aa5c812057b97017e88a974e452d8" name="a340aa5c812057b97017e88a974e452d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340aa5c812057b97017e88a974e452d8">&#9670;&#160;</a></span>percolation_clustering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt; ps::percolation_clustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>connection_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze percolation clusters from a set of points using a radius-based neighbor graph. </p>
<p>Builds a graph where edges exist if points are within <code>connection_radius</code>, then finds connected components (clusters).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input set of points. </td></tr>
    <tr><td class="paramname">connection_radius</td><td>Maximum distance for connectivity between points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cluster labels, size = points.size(). Label = -1 if unassigned.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;double,2&gt;&gt; pts = { {0.1,0.2}, {0.15,0.22}, {0.9,0.9}};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">labels</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">analyze_percolation_clusters&lt;double,2&gt;</a>(pts, 0.1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// labels might be {0,0,1}, meaning the first two form a cluster, third is separate.</span></div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="metrics_percolation_clustering.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a5b1e932ba8a20e05cd8c113179aa77c8" name="a5b1e932ba8a20e05cd8c113179aa77c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1e932ba8a20e05cd8c113179aa77c8">&#9670;&#160;</a></span>poisson_disk_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a set of Poisson disk samples in N-dimensional space, possibly with a warped metric. </p>
<p>This function uses Bridson's algorithm to generate evenly spaced points according to a minimum base distance, which can be warped using a user-defined scaling function (e.g., density or metric warping).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the sampling space. </td></tr>
    <tr><td class="paramname">ScaleFn</td><td>Callable type returning a scaling factor at a given point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of points (will attempt to generate up to this many). </td></tr>
    <tr><td class="paramname">ranges</td><td>Coordinate axis ranges (bounding box) for each of the N dimensions. </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Base minimum distance between any two points (before scaling). </td></tr>
    <tr><td class="paramname">scale_fn</td><td>Function that returns a distance scaling factor at a given point. This enables warped-space or non-uniform Poisson sampling. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed for reproducibility. </td></tr>
    <tr><td class="paramname">new_points_attempts</td><td>Number of candidate points to try around each active point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of sample points satisfying the scaled Poisson distance constraint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = std::array&lt;std::pair&lt;float, float&gt;, 2&gt;{{ {0.f, 1.f}, {0.f, 1.f} }};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a> = [](<span class="keyword">const</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Point&lt;float, 2&gt;</a> &amp;<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>) -&gt; <span class="keywordtype">float</span> {</div>
<div class="line">    <span class="keywordflow">return</span> 1.0f + 0.5f * std::sin(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] * 6.2831f);  <span class="comment">// Vary distance with x</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">poisson_disk_sampling&lt;float, 2&gt;</a>(100, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, 0.05f, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">scale_fn</a>, 42);</div>
</div><!-- fragment --></dd></dl>
<p>s</p><div class="image">
<img src="out_poisson_disk_sampling.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a0dcc5685aa1520492658cb55fcd1a3dc" name="a0dcc5685aa1520492658cb55fcd1a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcc5685aa1520492658cb55fcd1a3dc">&#9670;&#160;</a></span>poisson_disk_sampling_distance_distribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">RadiusGen</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling_distance_distribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">RadiusGen</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>radius_gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>max_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate random points with a variable-radius Poisson disk sampling. </p>
<p>Radius is defined by an input distribution.</p>
<p>This algorithm enforces a minimum separation between points based on radii drawn from a user-specified distribution. Two points \(p_i\), \(p_j\) with radii \(r_i\), \(r_j\) must satisfy:  </p><p class="formulaDsp">
\[
  \| p_i - p_j \| &gt; r_i + r_j
\]
</p>
<p>This produces point sets where local spacing reflects the size distribution: many small radii yield dense clusters, while large radii produce local depletion zones.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g. float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the points. </td></tr>
    <tr><td class="paramname">RadiusGen</td><td>Callable returning radii sampled from the target distribution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_points</td><td>Number of points to generate. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Ranges for each axis, defining the sampling domain. </td></tr>
    <tr><td class="paramname">radius_gen</td><td>Generator functor/lambda returning the next radius. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed for reproducibility. </td></tr>
    <tr><td class="paramname">max_attempts</td><td>Maximum attempts per point before giving up (controls density). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of generated points satisfying the variable-radius exclusion rule.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Larger <code>max_attempts</code> increases the chance of filling the domain but also increases runtime.</li>
<li>For efficiency, use a spatial grid or tree if generating many points.</li>
<li>Radii are drawn independently per point; correlations can be introduced by adapting <code>radius_gen</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line">std::mt19937 <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">rng</a>{std::random_device{}()};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2D unit square</span></div>
<div class="line">std::array&lt;std::pair&lt;double,double&gt;,2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">box</a> = { { {0,1}, {0,1} } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Log-normal radius distribution</span></div>
<div class="line">std::lognormal_distribution&lt;double&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">logn</a>(0.0, 0.5);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">variable_radius_poisson_disk&lt;double,2&gt;</a>(</div>
<div class="line">    200,</div>
<div class="line">    <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">box</a>,</div>
<div class="line">    [&amp;](){ <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">logn</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">rng</a>); }</div>
<div class="line">);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_poisson_disk_sampling_distance_distribution.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a0935f8e02f68dbf9667c6d544f7e3e2c" name="a0935f8e02f68dbf9667c6d544f7e3e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0935f8e02f68dbf9667c6d544f7e3e2c">&#9670;&#160;</a></span>poisson_disk_sampling_power_law()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling_power_law </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>dist_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>dist_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>max_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate N-dimensional points using Poisson disk sampling with a power-law radius distribution. </p>
<p>This function generates <code>n_points</code> in N-dimensional space such that each point is separated by a local radius sampled from a power-law distribution: </p><p class="formulaDsp">
\[ p(r) \propto
r^{-\alpha}, \quad r \in [\text{dist\_min}, \text{dist\_max}] \]
</p>
<p> Smaller radii are more probable than larger ones, creating denser clusters with occasional larger gaps.</p>
<p>The sampling respects the axis ranges specified in <code>axis_ranges</code> and can optionally use a fixed random seed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type for coordinates (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_points</td><td>Number of points to generate. </td></tr>
    <tr><td class="paramname">dist_min</td><td>Minimum radius for the power-law distribution. </td></tr>
    <tr><td class="paramname">dist_max</td><td>Maximum radius for the power-law distribution. </td></tr>
    <tr><td class="paramname">alpha</td><td>Power-law exponent ( \(\alpha &gt; 0\)). Larger \(\alpha\) favors smaller distances. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Array of N pairs specifying min/max range along each axis. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for reproducibility. </td></tr>
    <tr><td class="paramname">max_attempts</td><td>Maximum attempts to place a point before skipping (default 30). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of N-dimensional points satisfying the Poisson disk criteria with power-law distances.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Works in arbitrary dimension N.</li>
<li>Uses <code>poisson_disk_sampling_distance_distribution</code> internally with a dynamically sampled radius.</li>
<li>Smaller <code>alpha</code> produces more uniform spacing; larger <code>alpha</code> produces clustered patterns.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;double,double&gt;,3&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = {{{0,1},{0,1},{0,1}}};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">poisson_disk_sampling_power_law&lt;double,3&gt;</a>(200, 0.01, 0.2, 1.2, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_poisson_disk_sampling_power_law.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a6f7ab76c5d0a395aa78b85bad488e94e" name="a6f7ab76c5d0a395aa78b85bad488e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7ab76c5d0a395aa78b85bad488e94e">&#9670;&#160;</a></span>poisson_disk_sampling_uniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate uniformly distributed Poisson disk samples in N-dimensional space. </p>
<p>This is a convenience wrapper over <code>poisson_disk_sampling</code> using a constant distance scale (i.e., uniform metric).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the sampling space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of points (will attempt to generate up to this many). </td></tr>
    <tr><td class="paramname">ranges</td><td>Coordinate axis ranges (bounding box) for each of the N dimensions. </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Minimum distance between any two points. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed for reproducibility. </td></tr>
    <tr><td class="paramname">new_points_attempts</td><td>Number of candidate points to try around each active point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of uniformly spaced sample points.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = std::array&lt;std::pair&lt;float, float&gt;, 2&gt;{{ {0.f, 1.f}, {0.f, 1.f} }};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">poisson_disk_sampling_uniform&lt;float, 2&gt;</a>(200, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, 0.03f, 1234);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1bca24167c8ae5bcbb056c30a1c0866f" name="a1bca24167c8ae5bcbb056c30a1c0866f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca24167c8ae5bcbb056c30a1c0866f">&#9670;&#160;</a></span>poisson_disk_sampling_weibull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling_weibull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>max_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate N-dimensional points using Poisson disk sampling with a Weibull-distributed radius. </p>
<p>This function generates <code>n_points</code> in N-dimensional space such that each point is separated by a local radius sampled from a Weibull distribution: </p><p class="formulaDsp">
\[ p(r; k, \lambda) =
\frac{k}{\lambda} \left(\frac{r}{\lambda}\right)^{k-1}
\exp\left[-\left(\frac{r}{\lambda}\right)^k\right], \quad r \geq 0
\]
</p>
<p>The Weibull distribution allows flexible control over radius distribution:</p><ul>
<li>Shape parameter \(k &gt; 0\) controls skewness (e.g. \(k &lt; 1\) heavy-tail, \(k &gt;
1\) peaked).</li>
<li>Scale parameter \(\lambda &gt; 0\) sets the typical radius scale.</li>
</ul>
<p>The sampling respects the axis ranges specified in <code>axis_ranges</code> and can optionally use a fixed random seed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type for coordinates (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_points</td><td>Number of points to generate. </td></tr>
    <tr><td class="paramname">lambda</td><td>Scale parameter of the Weibull distribution. </td></tr>
    <tr><td class="paramname">k</td><td>Shape parameter of the Weibull distribution. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Array of N pairs specifying min/max range along each axis. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed for reproducibility. </td></tr>
    <tr><td class="paramname">max_attempts</td><td>Maximum attempts to place a point before skipping (default 30). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of N-dimensional points satisfying the Poisson disk criteria with Weibull-distributed distances.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Works in arbitrary dimension N.</li>
<li>Uses <code>poisson_disk_sampling_distance_distribution</code> internally with radii sampled from Weibull distribution.</li>
<li>Low shape ( \(k &lt; 1\)) produces heavy-tailed spacing with more small radii.</li>
<li>High shape ( \(k &gt; 1\)) produces more peaked, nearly Gaussian-like spacing.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;double,double&gt;,2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = {{{0,10},{0,10}}};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">poisson_disk_sampling_weibull&lt;double,2&gt;</a>(500, 1.0, 2.0, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_poisson_disk_sampling_weibull.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a2e070ffe5d2fcf926ceda2c0fec00e2d" name="a2e070ffe5d2fcf926ceda2c0fec00e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e070ffe5d2fcf926ceda2c0fec00e2d">&#9670;&#160;</a></span>poisson_disk_sampling_weibull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::poisson_disk_sampling_weibull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>dist_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>max_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poisson disk sampling in N dimensions with radii drawn from a Weibull distribution, enforcing a minimum exclusion distance. </p>
<p>Each point has an exclusion radius r = max(r_weibull, min_dist). The Weibull distribution is parameterized by scale λ and shape k.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point scalar type. </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_points</td><td>Maximum number of points to attempt to place. </td></tr>
    <tr><td class="paramname">lambda</td><td>Weibull scale parameter (&gt;0). </td></tr>
    <tr><td class="paramname">k</td><td>Weibull shape parameter (&gt;0). </td></tr>
    <tr><td class="paramname">min_dist</td><td>Minimum exclusion distance enforced globally. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box for the domain. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed. </td></tr>
    <tr><td class="paramname">max_attempts</td><td>Max attempts to place each point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of sampled points.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Each point is at least min_dist away from others.</li>
<li>Radii are Weibull-distributed, but truncated below by min_dist.</li>
<li>The effective distribution is Weibull(k, λ) left-truncated at min_dist.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>example</dt><dd><div class="fragment"><div class="line">std::array&lt;std::pair&lt;double,double&gt;, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">domain</a> = {{{0.0, 1.0}, {0.0, 1.0}}};</div>
<div class="line"><span class="keyword">auto</span> pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">poisson_disk_sampling_weibull&lt;double,2&gt;</a>(</div>
<div class="line">               200, 0.2, 1.5, 0.05, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">domain</a>, 42);</div>
</div><!-- fragment --></dd></dl>
<div class="image">
<img src="out_poisson_disk_sampling_weibull_min_dist.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a8d80a56ea4774726e748b48e1ecf0a8d" name="a8d80a56ea4774726e748b48e1ecf0a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d80a56ea4774726e748b48e1ecf0a8d">&#9670;&#160;</a></span>radial_distribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &gt; ps::radial_distribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>bin_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>max_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normalized radial distribution function g(r). </p>
<p>The radial distribution function (RDF) describes how the density of points varies as a function of distance from a reference point.</p>
<ul>
<li>g(r) ≈ 1 → uniform / random distribution at distance r</li>
<li>g(r) &gt; 1 → clustering / aggregation (excess probability of finding neighbors)</li>
<li>g(r) &lt; 1 → depletion / exclusion (points repel or avoid each other)</li>
</ul>
<p>This function normalizes the observed pair distances against the expected density in the domain (given by axis_ranges).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (float, double, ...) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned domain ranges for each dimension </td></tr>
    <tr><td class="paramname">bin_width</td><td>Width of distance bins </td></tr>
    <tr><td class="paramname">max_distance</td><td>Maximum distance to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt;<ul>
<li>First: radii (bin centers)</li>
<li>Second: normalized RDF values g(r)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;double, 2&gt;&gt; pts = {</div>
<div class="line">    {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::array&lt;std::pair&lt;double,double&gt;,2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = {</div>
<div class="line">    std::make_pair(0.0, 1.0), std::make_pair(0.0, 1.0)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">r</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">g</a>] = <a class="code hl_function" href="namespaceps.html#a8d80a56ea4774726e748b48e1ecf0a8d">radial_distribution</a>(pts, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, 0.1, 2.0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> = 0; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> &lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">r</a>.size(); ++<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>)</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;r=&quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">r</a>[<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>] &lt;&lt; <span class="stringliteral">&quot; g(r)=&quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">g</a>[<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>] &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceps_html_a8d80a56ea4774726e748b48e1ecf0a8d"><div class="ttname"><a href="namespaceps.html#a8d80a56ea4774726e748b48e1ecf0a8d">ps::radial_distribution</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt; radial_distribution(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, T bin_width, T max_distance)</div><div class="ttdoc">Compute the normalized radial distribution function g(r).</div><div class="ttdef"><b>Definition</b> metrics.hpp:434</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a10763ef2a872aa9eddb48ea341cd6f69" name="a10763ef2a872aa9eddb48ea341cd6f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10763ef2a872aa9eddb48ea341cd6f69">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::random </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a specified number of uniformly distributed random points in N-dimensional space. </p>
<p>This function creates <code>count</code> random points where each coordinate is independently sampled from a uniform distribution defined by <code>axis_ranges</code> per dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric type for coordinates (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>The dimensionality of the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of random points to generate. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>An array of N pairs specifying the min and max range for each axis. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for the random number generator. If not provided, a nondeterministic random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing <code>count</code> randomly generated points within the specified axis ranges.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentIfanyaxisrangehasmin&gt;max.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The points are generated independently per axis using uniform_real_distribution.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="random_8hpp.html">point_sampler/random.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dim</a> = 3;</div>
<div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a> = 5;</div>
<div class="line">  std::array&lt;std::pair&lt;float, float&gt;, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dim</a>&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a> = {{{0.f, 1.f},</div>
<div class="line">                                                      {0.f, 2.f},</div>
<div class="line">                                                      {-1.f, 1.f}}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Generate points with a fixed seed for reproducibility</span></div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random&lt;float, dim&gt;</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">count</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ranges</a>, 42);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a> : <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> = 0; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a> &lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">dim</a>; ++<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>) std::cout &lt;&lt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">i</a>] &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="arandom_8hpp_html"><div class="ttname"><a href="random_8hpp.html">random.hpp</a></div></div>
</div><!-- fragment --><div class="image">
<img src="out_random.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a66183362443c104da098224df9bcd2a1" name="a66183362443c104da098224df9bcd2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66183362443c104da098224df9bcd2a1">&#9670;&#160;</a></span>random_rejection_filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::random_rejection_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">float</a>&#160;</td>
          <td class="paramname"><em>keep_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly retains a fraction of the input points. </p>
<p>This is a convenience overload of <code>random_rejection_filter</code> that accepts a floating-point <code>keep_fraction</code> instead of an absolute count. Internally, it computes the number of points to retain and calls the count-based version.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input vector of points </td></tr>
    <tr><td class="paramname">keep_fraction</td><td>Fraction of points to retain (between 0.0 and 1.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; containing <code>keep_fraction * points.size()</code> randomly selected points</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;double, 3&gt;&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">cloud</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random&lt;double, 3&gt;</a>(10000,</div>
<div class="line">{{-1,1},{-1,1},{-1,1}}); <span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">sparse</a> = <a class="code hl_function" href="namespaceps.html#ab818126518017939773c8a43bd92fc42">ps::random_rejection_filter</a>(<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">cloud</a>, 0.25); <span class="comment">//</span></div>
<div class="line"><a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">Keep</a> 25% <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">of</a> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">the</a> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">points</a></div>
<div class="ttc" id="anamespaceps_html_ab818126518017939773c8a43bd92fc42"><div class="ttname"><a href="namespaceps.html#ab818126518017939773c8a43bd92fc42">ps::random_rejection_filter</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; random_rejection_filter(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, std::size_t target_count)</div><div class="ttdoc">Randomly retains a fixed number of points from the input set.</div><div class="ttdef"><b>Definition</b> random_rejection_filter.hpp:37</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab818126518017939773c8a43bd92fc42" name="ab818126518017939773c8a43bd92fc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab818126518017939773c8a43bd92fc42">&#9670;&#160;</a></span>random_rejection_filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::random_rejection_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly retains a fixed number of points from the input set. </p>
<p>This function returns a subset of the input points of size <code>target_count</code>, selected uniformly at random without replacement. If <code>target_count</code> is greater than or equal to the number of input points, the full input is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input vector of points </td></tr>
    <tr><td class="paramname">target_count</td><td>Desired number of points in the output (≤ points.size()) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; containing <code>target_count</code> randomly selected points</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::random&lt;float, 2&gt;</a>(1000, {{0,1},{0,1}});</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">reduced</a> = <a class="code hl_function" href="namespaceps.html#ab818126518017939773c8a43bd92fc42">ps::random_rejection_filter</a>(pts, 300); <span class="comment">// Keep 300 points</span></div>
</div><!-- fragment --><div class="image">
<img src="out_random_rejection_filter.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a54a1e19fa663340b68ad9f74e740a6c0" name="a54a1e19fa663340b68ad9f74e740a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a1e19fa663340b68ad9f74e740a6c0">&#9670;&#160;</a></span>random_walk_filaments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::random_walk_filaments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>n_filaments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>filament_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>persistence</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0.8)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>gaussian_sigma</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>gaussian_samples</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; *&#160;</td>
          <td class="paramname"><em>p_distances</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate random walk filaments in N dimensions with optional Gaussian thickness. </p>
<p>Each filament starts at a random seed and grows step by step, where each step is a random direction with a persistence factor to avoid sharp turns. Around each step, additional points can be sampled from a Gaussian distribution to form a "thick" filament.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_filaments</td><td>Number of separate filaments. </td></tr>
    <tr><td class="paramname">filament_count</td><td>Number of points per filament. </td></tr>
    <tr><td class="paramname">step_size</td><td>Average step length. </td></tr>
    <tr><td class="paramname">ranges</td><td>Bounding box for clamping. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed. </td></tr>
    <tr><td class="paramname">persistence</td><td>Correlation between steps (0 = totally random, 1 = straight line). </td></tr>
    <tr><td class="paramname">gaussian_sigma</td><td>Standard deviation of Gaussian scatter around the filament (0 = no scatter, &gt;0 = thick filament). </td></tr>
    <tr><td class="paramname">gaussian_samples</td><td>Number of samples drawn per step for thickness. </td></tr>
    <tr><td class="paramname">p_distances</td><td>Optional output vector to store p_distances of each point from the filament center (0 for core filament points). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of generated filament points.</dd></dl>
<div class="image">
<img src="out_random_rejection_filter.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a2b8197901114d1c4fd6cfe19efcd3862" name="a2b8197901114d1c4fd6cfe19efcd3862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8197901114d1c4fd6cfe19efcd3862">&#9670;&#160;</a></span>refit_points_to_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a> ps::refit_points_to_range </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly remap a set of points to fit within the specified axis-aligned ranges. </p>
<p>This function computes the axis-aligned bounding box (AABB) of the input points and linearly rescales each point so that all dimensions lie in the given <code>target_ranges</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>Vector of input points to modify in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_ranges</td><td>Desired output min/max per dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">generate_random_points&lt;float, 2&gt;</a>(100,</div>
<div class="line">     { {{0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"><span class="comment">// Refit to a new range: [10, 20] × [50, 100]</span></div>
<div class="line"><a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">refit_points_to_range&lt;float, 2&gt;</a>(pts, { { {10.f, 20.f}, {50.f, 100.f} } });</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a dimension has constant value (min == max), the center of the target range is used. </dd></dl>

</div>
</div>
<a id="a29ab0a94bbe26a22cb87bf8f44703527" name="a29ab0a94bbe26a22cb87bf8f44703527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ab0a94bbe26a22cb87bf8f44703527">&#9670;&#160;</a></span>rejection_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; ps::rejection_sampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">DensityFn</a>&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">unsigned</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates random points using rejection sampling based on a user-defined density function. </p>
<p>This function uniformly samples candidate points within the given axis-aligned bounds and retains them based on the output of a user-provided density function. The <code>density_fn</code> should return a probability in the range [0, 1] for each point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">DensityFn</td><td>Callable with signature T(Point&lt;T, N&gt;) returning a probability in [0, 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of accepted points. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Ranges for each axis in the form of an array of (min, max) pairs. </td></tr>
    <tr><td class="paramname">density_fn</td><td>Function that returns a probability for accepting a point. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for reproducibility.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of accepted points based on rejection sampling.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentifanyaxisrangeisinvalid(min&gt;max).</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rejection__sampling_8hpp.html">point_sampler/rejection_sampling.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">radial_density</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a>&amp; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">r2</a> = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] * <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[0] + <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[1] * <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">p</a>[1];</div>
<div class="line">    <span class="keywordflow">return</span> std::exp(-<a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">r2</a>); <span class="comment">// higher near origin, drops with radius</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">main</a>()</div>
<div class="line">{</div>
<div class="line">    std::array&lt;std::pair&lt;float, float&gt;, 2&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a> = { { {-2.0f, 2.0f},</div>
<div class="line">                                                        {-2.0f, 2.0f} }};</div>
<div class="line">    <span class="keyword">auto</span> pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::rejection_sampling&lt;float, 2&gt;</a>(1000, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bounds</a>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">radial_density</a>, 42);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generated &quot;</span> &lt;&lt; pts.size() &lt;&lt; <span class="stringliteral">&quot; points.\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="arejection__sampling_8hpp_html"><div class="ttname"><a href="rejection__sampling_8hpp.html">rejection_sampling.hpp</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Rejection sampling can be inefficient if <code>density_fn</code> returns low values over most of the domain, as many candidate samples will be discarded.</dd></dl>
<div class="image">
<img src="out_rejection_sampling.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="aed8a3217a801c5b5706f4bcc3306bb18" name="aed8a3217a801c5b5706f4bcc3306bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8a3217a801c5b5706f4bcc3306bb18">&#9670;&#160;</a></span>relaxation_ktree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a> ps::relaxation_ktree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>k_neighbors</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>&#160;</td>
          <td class="paramname"><em>step_size</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>(0.1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a>&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree. </p>
<p>This function performs iterative relaxation on a set of N-dimensional points by pushing each point away from its nearest neighbors. It uses a KD-tree for efficient neighbor lookup. The goal is to reduce clustering and obtain a more uniform or blue-noise-like distribution.</p>
<p>Each point is offset based on inverse-distance-weighted repulsion from its k-nearest neighbors, normalized and scaled by a step size. The point set is updated over a number of iterations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>The point set to relax. This vector will be modified in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k_neighbors</td><td>Number of neighbors to consider (default is 8). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>How far to move a point per iteration (default is 0.1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Number of relaxation iterations (default is 10).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The KD-tree is rebuilt on each iteration to reflect the updated positions.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation_8hpp.html">point_sampler/relaxation.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">generate_random_points&lt;float, 2&gt;</a>(</div>
<div class="line">    1000, { { {0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply 10 iterations of relaxation relaxation_ktree&lt;float, 2&gt;(pts, 8, 0.1f, 10);</span></div>
<div class="ttc" id="arelaxation_8hpp_html"><div class="ttname"><a href="relaxation_8hpp.html">relaxation.hpp</a></div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="autotoc_md0"></a>
How it works:</h3>
<ul>
<li>For each point:<ul>
<li>Find its <code>k_neighbors</code> nearest neighbors using a KD-tree.</li>
<li>Compute offset vectors from the current point to each neighbor.</li>
<li>Weight the vectors by the inverse square distance (stronger push from closer neighbors).</li>
<li>Accumulate the offset, normalize, and scale by <code>step_size</code>.</li>
<li>Apply the movement to each point.</li>
</ul>
</li>
<li>Repeat for <code>iterations</code> steps.</li>
</ul>
<div class="image">
<img src="out_relaxation_ktree_refit.csv.jpg" alt=""/>
</div>
 
</div>
</div>
<a id="a7addf1455112b7895f8de7c475eed850" name="a7addf1455112b7895f8de7c475eed850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addf1455112b7895f8de7c475eed850">&#9670;&#160;</a></span>rescale_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">void</a> ps::rescale_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::array&lt; std::pair&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales normalized points (in [0, 1]) to specified axis-aligned ranges. </p>
<p>Each coordinate in every point is mapped from [0, 1] to a new range defined per axis. This is useful after generating normalized samples (e.g., Poisson disk, jittered grid).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>Vector of normalized points to be modified in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranges</td><td>Target value ranges for each dimension.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.f, 0.f}, {1.f, 1.f}, {0.5f, 0.5f} };</div>
<div class="line"><a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">ps::rescale_points&lt;float, 2&gt;</a>(pts, { { {10.f, 20.f}, {100.f, 200.f} } });</div>
<div class="line"><span class="comment">// pts is now { {10.f, 100.f}, {20.f, 200.f}, {15.f, 150.f} }</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Assumes points are in [0, 1]^N. Does not check bounds. </dd></dl>

</div>
</div>
<a id="a802637e81218193c0e65266c8075f002" name="a802637e81218193c0e65266c8075f002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802637e81218193c0e65266c8075f002">&#9670;&#160;</a></span>save_points_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> ps::save_points_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td>
          <td class="paramname"><em>write_header</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a set of N-dimensional points to a CSV file. </p>
<p>The output file will contain one point per line, with each coordinate separated by commas. Optionally, a header row ("x0,x1,...,xN") can be written as the first line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the output CSV file. </td></tr>
    <tr><td class="paramname">points</td><td>Vector of points to be saved. </td></tr>
    <tr><td class="paramname">write_header</td><td>If true, writes a header row with column names ("x0,x1,...").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was successfully written, false otherwise. </dd></dl>

</div>
</div>
<a id="a5b92b660faab5030374ba2dee9f89810" name="a5b92b660faab5030374ba2dee9f89810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b92b660faab5030374ba2dee9f89810">&#9670;&#160;</a></span>save_vector_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a> ps::save_vector_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">bool</a>&#160;</td>
          <td class="paramname"><em>write_header</em> = <code><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">true</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>header_name</em> = <code>&quot;value&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a 1D vector of values to a CSV file. </p>
<p>This function writes a sequence of values to a CSV file with one value per row. The column name can be customized via the <code>header_name</code> parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the values (must be streamable to std::ostream). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the output CSV file. </td></tr>
    <tr><td class="paramname">values</td><td>The vector of values to write. </td></tr>
    <tr><td class="paramname">write_header</td><td>If true, writes a header line at the top of the file. </td></tr>
    <tr><td class="paramname">header_name</td><td>Name of the column header (only used if <code>write_header</code> is true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was successfully written, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The file will be overwritten if it already exists.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">std::vector&lt;double&gt; <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">data</a> = {1.0, 2.5, 3.7};</div>
<div class="line"><a class="code hl_function" href="namespaceps.html#a5b92b660faab5030374ba2dee9f89810">save_vector_to_csv</a>(<span class="stringliteral">&quot;data.csv&quot;</span>, <a class="code hl_function" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">data</a>, <span class="keyword">true</span>, <span class="stringliteral">&quot;measurement&quot;</span>);</div>
<div class="line"><span class="comment">// data.csv content:</span></div>
<div class="line"><span class="comment">// measurement</span></div>
<div class="line"><span class="comment">// 1.0</span></div>
<div class="line"><span class="comment">// 2.5</span></div>
<div class="line"><span class="comment">// 3.7</span></div>
<div class="ttc" id="anamespaceps_html_a5b92b660faab5030374ba2dee9f89810"><div class="ttname"><a href="namespaceps.html#a5b92b660faab5030374ba2dee9f89810">ps::save_vector_to_csv</a></div><div class="ttdeci">bool save_vector_to_csv(const std::string &amp;filename, const std::vector&lt; T &gt; &amp;values, bool write_header=true, const std::string &amp;header_name=&quot;value&quot;)</div><div class="ttdoc">Save a 1D vector of values to a CSV file.</div><div class="ttdef"><b>Definition</b> utils.hpp:96</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af6737277b9cc05d5f2ab248f17baea3b" name="af6737277b9cc05d5f2ab248f17baea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6737277b9cc05d5f2ab248f17baea3b">&#9670;&#160;</a></span>split_by_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">typename</a> <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> , <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a> &gt;, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; ps::split_by_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">T</a>, <a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges a list of N-dimensional points into N separate coordinate vectors. </p>
<p>This function decomposes a vector of N-dimensional points into N vectors, where each vector contains all the values from one coordinate dimension. Useful for plotting or statistical analysis.</p>
<p>For example, given 3D points: [(1,2,3), (4,5,6), (7,8,9)], the result will be:</p><ul>
<li>dimension 0: [1, 4, 7]</li>
<li>dimension 1: [2, 5, 8]</li>
<li>dimension 2: [3, 6, 9]</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of N-dimensional points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of N vectors, each containing the values for one coordinate axis. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceps.html">ps</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
