<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ps Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ps Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1GridND.html">GridND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size N-dimensional point/vector class.  <a href="structps_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a" id="r_ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">KDTree</a> = nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt;</td></tr>
<tr class="separator:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94" id="r_ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad1f4a1110a40bf1c6a687182db6b4b94">distance_rejection_filter</a> (<a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">min_dist</a>)</td></tr>
<tr class="separator:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632" id="r_af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">distance_rejection_filter_warped</a> (<a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">base_min_dist</a>, <a class="el" href="structps_1_1Point.html">ScaleFn</a> <a class="el" href="structps_1_1Point.html">scale_fn</a>)</td></tr>
<tr class="separator:af23d114903fd5cb3ccb19d3e64183632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a" id="r_a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">gaussian_clusters</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; <a class="el" href="structps_1_1Point.html">cluster_centers</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">points_per_cluster</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">spread</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a913ab9d687ee42d04488e5eb0373e23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d" id="r_a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0efaff8017d5a171ffdf0ed0201bd65d">gaussian_clusters</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">cluster_count</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">points_per_cluster</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">spread</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b" id="r_aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa8c3b3b3367276f9a194938599d2463b">halton_sequence</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">shift</a>)</td></tr>
<tr class="separator:aa8c3b3b3367276f9a194938599d2463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524" id="r_a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">halton</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a81b18395a05f0bb4d483406e79aa9524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3" id="r_ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae21a8c51533330ead4ebe76eed3e72b3">hammersley_sequence</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">shift</a>)</td></tr>
<tr class="separator:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6" id="r_aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aad0cc7bc81f7cac9f0be26177b9986a6">hammersley</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b" id="r_a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">DensityFn</a> &gt; </td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a932640b18d76a7e336fc760e9cf5511b">importance_resampling</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">oversampling_ratio</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, <a class="el" href="structps_1_1Point.html">DensityFn</a> <a class="el" href="structps_1_1Point.html">density_fn</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a932640b18d76a7e336fc760e9cf5511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8" id="r_ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad8525c124fef24618bf574b9b7b1ece8">jittered_grid</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">jitter_amount</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">stagger_ratio</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:ad8525c124fef24618bf574b9b7b1ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714" id="r_ae90df8db8e751ff4b61298114f092714"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae90df8db8e751ff4b61298114f092714">jittered_grid</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:ae90df8db8e751ff4b61298114f092714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0" id="r_af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af9ee1cf5d335276b7fabe6f1daddf1b0">operator+</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1" id="r_aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa369956286bc3f09dfdc146a5b2a49f1">operator-</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b" id="r_a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6fd3a6df3727a04f9baba3b8b87a903b">operator*</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e" id="r_a585704d3f738c5eb899810fc9308a60e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a585704d3f738c5eb899810fc9308a60e">operator/</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:a585704d3f738c5eb899810fc9308a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f" id="r_a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a366ef094d65da865384b6fb77aac5d5f">operator+</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>)</td></tr>
<tr class="separator:a366ef094d65da865384b6fb77aac5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f" id="r_a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79196b5b8a95ad9d3bc2ad698425944f">operator-</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>)</td></tr>
<tr class="separator:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b" id="r_acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#acd4dc781f43ba8a50daa139682846d4b">operator*</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>)</td></tr>
<tr class="separator:acd4dc781f43ba8a50daa139682846d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580" id="r_a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6663b4f1e9c5ee48e2bf6e1896430580">operator/</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>)</td></tr>
<tr class="separator:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4" id="r_abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#abfd6fe71db1c4df607bfdace9dffb5b4">operator*</a> (<a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>)</td></tr>
<tr class="separator:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804" id="r_afe774cb61bde6358f8a7024c42db9804"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#afe774cb61bde6358f8a7024c42db9804">operator+</a> (<a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">scalar</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>)</td></tr>
<tr class="separator:afe774cb61bde6358f8a7024c42db9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b" id="r_ace7642868199df621df9139e5179767b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:ace7642868199df621df9139e5179767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c" id="r_a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>)</td></tr>
<tr class="separator:a7c3e161560ad3000aa4e2218291b169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746" id="r_a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">length</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>)</td></tr>
<tr class="separator:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914" id="r_a7de6090e2c8291401816be9bc6cda914"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7de6090e2c8291401816be9bc6cda914">normalized</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>)</td></tr>
<tr class="separator:a7de6090e2c8291401816be9bc6cda914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808" id="r_aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aecf2b150ec16bf286e6a7b462c4d5808">distance_squared</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11" id="r_ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac0b74f22d427d199ab0df8f6942d3b11">distance</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>)</td></tr>
<tr class="separator:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa" id="r_a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79914e9fc2dd02bacd38e9bd32e21baa">lerp</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">a</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">b</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">t</a>)</td></tr>
<tr class="separator:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28" id="r_adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#adb0bd4806c7e79eddef0e1263740ae28">clamp</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">min_val</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">max_val</a>)</td></tr>
<tr class="separator:adb0bd4806c7e79eddef0e1263740ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af" id="r_aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aedb5908eae325f054e4f3dd6b9b223af">in_neighborhood</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">grid</a>, <a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">p</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">base_min_dist</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">ranges</a>, <a class="el" href="structps_1_1Point.html">ScaleFn</a> <a class="el" href="structps_1_1Point.html">scale_fn</a>)</td></tr>
<tr class="separator:aedb5908eae325f054e4f3dd6b9b223af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8" id="r_a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a898bca65491a14a41bfdd50fdc6230b8">generate_random_point_around</a> (<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">center</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">base_min_dist</a>, std::mt19937 &amp;<a class="el" href="structps_1_1Point.html">gen</a>, std::function&lt; <a class="el" href="structps_1_1Point.html">T</a>(<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;)&gt; <a class="el" href="structps_1_1Point.html">scale_fn</a>)</td></tr>
<tr class="separator:a898bca65491a14a41bfdd50fdc6230b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8" id="r_a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5b1e932ba8a20e05cd8c113179aa77c8">poisson_disk_sampling</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">ranges</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">base_min_dist</a>, <a class="el" href="structps_1_1Point.html">ScaleFn</a> <a class="el" href="structps_1_1Point.html">scale_fn</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">new_points_attempts</a>=30)</td></tr>
<tr class="separator:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e" id="r_a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6f7ab76c5d0a395aa78b85bad488e94e">poisson_disk_sampling_uniform</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">ranges</a>, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">base_min_dist</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">new_points_attempts</a>=30)</td></tr>
<tr class="separator:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69" id="r_a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">random</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df" id="r_a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a9c8c5679d987d3023b9d3beffd81e6df">filter_points_in_range</a> (<a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>)</td></tr>
<tr class="memdesc:a9c8c5679d987d3023b9d3beffd81e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points that lie within the given axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a" id="r_a5350b843397a5bf2a748115108ffa21a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">Func</a> &gt; </td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5350b843397a5bf2a748115108ffa21a">filter_points_function</a> (<a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">Func</a> <a class="el" href="structps_1_1Point.html">fn</a>)</td></tr>
<tr class="separator:a5350b843397a5bf2a748115108ffa21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862" id="r_a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a2b8197901114d1c4fd6cfe19efcd3862">refit_points_to_range</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">target_ranges</a>)</td></tr>
<tr class="memdesc:a2b8197901114d1c4fd6cfe19efcd3862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly remap a set of points to fit within the specified axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850" id="r_a7addf1455112b7895f8de7c475eed850"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">rescale_points</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">ranges</a>)</td></tr>
<tr class="separator:a7addf1455112b7895f8de7c475eed850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527" id="r_a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">DensityFn</a> &gt; </td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a29ab0a94bbe26a22cb87bf8f44703527">rejection_sampling</a> (<a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">count</a>, <a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;<a class="el" href="structps_1_1Point.html">axis_ranges</a>, <a class="el" href="structps_1_1Point.html">DensityFn</a> <a class="el" href="structps_1_1Point.html">density_fn</a>, std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt; <a class="el" href="structps_1_1Point.html">seed</a>=std::nullopt)</td></tr>
<tr class="separator:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18" id="r_aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aed8a3217a801c5b5706f4bcc3306bb18">relaxation_ktree</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">k_neighbors</a>=8, <a class="el" href="structps_1_1Point.html">T</a> <a class="el" href="structps_1_1Point.html">step_size</a>=<a class="el" href="structps_1_1Point.html">T</a>(0.1), <a class="el" href="structps_1_1Point.html">size_t</a> <a class="el" href="structps_1_1Point.html">iterations</a>=10)</td></tr>
<tr class="memdesc:aed8a3217a801c5b5706f4bcc3306bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree.  <br /></td></tr>
<tr class="separator:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002" id="r_a802637e81218193c0e65266c8075f002"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a802637e81218193c0e65266c8075f002">save_points_to_csv</a> (<a class="el" href="structps_1_1Point.html">const</a> std::string &amp;<a class="el" href="structps_1_1Point.html">filename</a>, <a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>, <a class="el" href="structps_1_1Point.html">bool</a> <a class="el" href="structps_1_1Point.html">write_header</a>=<a class="el" href="structps_1_1Point.html">true</a>)</td></tr>
<tr class="separator:a802637e81218193c0e65266c8075f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b" id="r_af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af6737277b9cc05d5f2ab248f17baea3b">split_by_dimension</a> (<a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;<a class="el" href="structps_1_1Point.html">points</a>)</td></tr>
<tr class="separator:af6737277b9cc05d5f2ab248f17baea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9ecfd54020ea95c133d1fc99cf4f75a" name="ac9ecfd54020ea95c133d1fc99cf4f75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ecfd54020ea95c133d1fc99cf4f75a">&#9670;&#160;</a></span>KDTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">using</a> <a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">ps::KDTree</a> = <a class="el" href="structps_1_1Point.html">typedef</a> nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt;<a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;<a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a>&gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;<a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a>&gt;, <a class="el" href="structps_1_1Point.html">N</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nanoflann__adaptator_8hpp_source.html#l00032">32</a> of file <a class="el" href="nanoflann__adaptator_8hpp_source.html">nanoflann_adaptator.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adb0bd4806c7e79eddef0e1263740ae28" name="adb0bd4806c7e79eddef0e1263740ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bd4806c7e79eddef0e1263740ae28">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; ps::clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00238">238</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  239</span>{</div>
<div class="line"><span class="lineno">  240</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  241</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  242</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = std::min(std::max(<a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>], <a class="code hl_struct" href="structps_1_1Point.html">min_val</a>), <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>);</div>
<div class="line"><span class="lineno">  243</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  244</span>}</div>
<div class="ttc" id="astructps_1_1Point_html"><div class="ttname"><a href="structps_1_1Point.html">ps::Point</a></div><div class="ttdoc">A fixed-size N-dimensional point/vector class.</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00035">point.hpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0b74f22d427d199ab0df8f6942d3b11" name="ac0b74f22d427d199ab0df8f6942d3b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b74f22d427d199ab0df8f6942d3b11">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">T</a> ps::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00226">226</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  227</span>{</div>
<div class="line"><span class="lineno">  228</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">length</a>(<a class="code hl_struct" href="structps_1_1Point.html">a</a> - <a class="code hl_struct" href="structps_1_1Point.html">b</a>);</div>
<div class="line"><span class="lineno">  229</span>}</div>
<div class="ttc" id="anamespaceps_html_a38d89dd8b52a63eabb39ef5e425d5746"><div class="ttname"><a href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">ps::length</a></div><div class="ttdeci">T length(const Point&lt; T, N &gt; &amp;a)</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00206">point.hpp:206</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1f4a1110a40bf1c6a687182db6b4b94" name="ad1f4a1110a40bf1c6a687182db6b4b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4a1110a40bf1c6a687182db6b4b94">&#9670;&#160;</a></span>distance_rejection_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::distance_rejection_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2PointSampler_2PointSampler_2PointSampler_2include_2point_sampler_2distance_rejection_filter_8hpp-example.html#a0">/home/runner/work/PointSampler/PointSampler/PointSampler/include/point_sampler/distance_rejection_filter.hpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="distance__rejection__filter_8hpp_source.html#l00031">31</a> of file <a class="el" href="distance__rejection__filter_8hpp_source.html">distance_rejection_filter.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   33</span>{</div>
<div class="line"><span class="lineno">   34</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">points</a>.empty())</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span>  std::vector&lt;Point&lt;T, N&gt;&gt; result;</div>
<div class="line"><span class="lineno">   38</span>  result.reserve(points.size());</div>
<div class="line"><span class="lineno">   39</span>  result.push_back(points.front());</div>
<div class="line"><span class="lineno">   40</span> </div>
<div class="line"><span class="lineno">   41</span>  <span class="keywordflow">for</span> (std::size_t i = 1; i &lt; points.size(); ++i)</div>
<div class="line"><span class="lineno">   42</span>  {</div>
<div class="line"><span class="lineno">   43</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;p = points[i];</div>
<div class="line"><span class="lineno">   44</span> </div>
<div class="line"><span class="lineno">   45</span>    PointCloudAdaptor&lt;T, N&gt; adaptor(result);</div>
<div class="line"><span class="lineno">   46</span>    KDTree&lt;T, N&gt;            index(N, adaptor);</div>
<div class="line"><span class="lineno">   47</span>    index.buildIndex();</div>
<div class="line"><span class="lineno">   48</span> </div>
<div class="line"><span class="lineno">   49</span>    std::array&lt;T, N&gt; query;</div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">for</span> (std::size_t d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">   51</span>      query[d] = p[d];</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span>    std::vector&lt;nanoflann::ResultItem&lt;unsigned int, T&gt;&gt; matches;</div>
<div class="line"><span class="lineno">   54</span>    nanoflann::SearchParameters                         params;</div>
<div class="line"><span class="lineno">   55</span>    <span class="keyword">const</span> T                                             radius = min_dist * min_dist;</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> found = index.radiusSearch(query.data(), radius, matches, params);</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">if</span> (found == 0)</div>
<div class="line"><span class="lineno">   60</span>      result.push_back(p);</div>
<div class="line"><span class="lineno">   61</span>  }</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">   64</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af23d114903fd5cb3ccb19d3e64183632" name="af23d114903fd5cb3ccb19d3e64183632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d114903fd5cb3ccb19d3e64183632">&#9670;&#160;</a></span>distance_rejection_filter_warped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::distance_rejection_filter_warped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2PointSampler_2PointSampler_2PointSampler_2include_2point_sampler_2distance_rejection_filter_8hpp-example.html#a1">/home/runner/work/PointSampler/PointSampler/PointSampler/include/point_sampler/distance_rejection_filter.hpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="distance__rejection__filter_8hpp_source.html#l00067">67</a> of file <a class="el" href="distance__rejection__filter_8hpp_source.html">distance_rejection_filter.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   71</span>{</div>
<div class="line"><span class="lineno">   72</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">points</a>.empty())</div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">   74</span> </div>
<div class="line"><span class="lineno">   75</span>  std::vector&lt;Point&lt;T, N&gt;&gt; result;</div>
<div class="line"><span class="lineno">   76</span>  result.reserve(points.size());</div>
<div class="line"><span class="lineno">   77</span>  result.push_back(points.front());</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>  <span class="keywordflow">for</span> (std::size_t i = 1; i &lt; points.size(); ++i)</div>
<div class="line"><span class="lineno">   80</span>  {</div>
<div class="line"><span class="lineno">   81</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;p = points[i];</div>
<div class="line"><span class="lineno">   82</span>    <span class="keyword">const</span> T     local_min_dist = base_min_dist * scale_fn(p);</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    PointCloudAdaptor&lt;T, N&gt; adaptor(result);</div>
<div class="line"><span class="lineno">   85</span>    KDTree&lt;T, N&gt;            index(N, adaptor);</div>
<div class="line"><span class="lineno">   86</span>    index.buildIndex();</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>    std::array&lt;T, N&gt; query;</div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">for</span> (std::size_t d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">   90</span>      query[d] = p[d];</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    std::vector&lt;nanoflann::ResultItem&lt;unsigned int, T&gt;&gt; matches;</div>
<div class="line"><span class="lineno">   93</span>    nanoflann::SearchParameters                         params;</div>
<div class="line"><span class="lineno">   94</span>    <span class="keyword">const</span> T radius = local_min_dist * local_min_dist;</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    <span class="keyword">const</span> <span class="keywordtype">size_t</span> found = index.radiusSearch(query.data(), radius, matches, params);</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">if</span> (found == 0)</div>
<div class="line"><span class="lineno">   98</span>      result.push_back(p);</div>
<div class="line"><span class="lineno">   99</span>  }</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  102</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aecf2b150ec16bf286e6a7b462c4d5808" name="aecf2b150ec16bf286e6a7b462c4d5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf2b150ec16bf286e6a7b462c4d5808">&#9670;&#160;</a></span>distance_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">T</a> ps::distance_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00221">221</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  222</span>{</div>
<div class="line"><span class="lineno">  223</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a>(<a class="code hl_struct" href="structps_1_1Point.html">a</a> - <a class="code hl_struct" href="structps_1_1Point.html">b</a>);</div>
<div class="line"><span class="lineno">  224</span>}</div>
<div class="ttc" id="anamespaceps_html_a7c3e161560ad3000aa4e2218291b169c"><div class="ttname"><a href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">ps::length_squared</a></div><div class="ttdeci">T length_squared(const Point&lt; T, N &gt; &amp;a)</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00201">point.hpp:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ace7642868199df621df9139e5179767b" name="ace7642868199df621df9139e5179767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7642868199df621df9139e5179767b">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">T</a> ps::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00193">193</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  194</span>{</div>
<div class="line"><span class="lineno">  195</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a> = <a class="code hl_struct" href="structps_1_1Point.html">T</a>(0);</div>
<div class="line"><span class="lineno">  196</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  197</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a> += <a class="code hl_struct" href="structps_1_1Point.html">a</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] * <a class="code hl_struct" href="structps_1_1Point.html">b</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  198</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  199</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5350b843397a5bf2a748115108ffa21a" name="a5350b843397a5bf2a748115108ffa21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5350b843397a5bf2a748115108ffa21a">&#9670;&#160;</a></span>filter_points_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , std::size_t N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">Func</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::filter_points_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">Func</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00052">52</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   54</span>{</div>
<div class="line"><span class="lineno">   55</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">filtered</a>;</div>
<div class="line"><span class="lineno">   56</span>  <a class="code hl_struct" href="structps_1_1Point.html">filtered</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">points</a>.size());</div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">p</a> : <a class="code hl_struct" href="structps_1_1Point.html">points</a>)</div>
<div class="line"><span class="lineno">   59</span>  {</div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">fn</a>(<a class="code hl_struct" href="structps_1_1Point.html">p</a>) != <a class="code hl_struct" href="structps_1_1Point.html">T</a>(0)) <span class="comment">// keep point if function value is not zero</span></div>
<div class="line"><span class="lineno">   61</span>      <a class="code hl_struct" href="structps_1_1Point.html">filtered</a>.push_back(<a class="code hl_struct" href="structps_1_1Point.html">p</a>);</div>
<div class="line"><span class="lineno">   62</span>  }</div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>  <span class="keywordflow">return</span> filtered;</div>
<div class="line"><span class="lineno">   65</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c8c5679d987d3023b9d3beffd81e6df" name="a9c8c5679d987d3023b9d3beffd81e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8c5679d987d3023b9d3beffd81e6df">&#9670;&#160;</a></span>filter_points_in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::filter_points_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points that lie within the given axis-aligned ranges. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of coordinates. </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Input points. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Ranges for each dimension (min, max) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; Filtered points that lie within the given ranges. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00025">25</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   28</span>{</div>
<div class="line"><span class="lineno">   29</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">filtered</a>;</div>
<div class="line"><span class="lineno">   30</span>  <a class="code hl_struct" href="structps_1_1Point.html">filtered</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">points</a>.size());</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">p</a> : <a class="code hl_struct" href="structps_1_1Point.html">points</a>)</div>
<div class="line"><span class="lineno">   33</span>  {</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordtype">bool</span> <a class="code hl_struct" href="structps_1_1Point.html">inside</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   36</span>    {</div>
<div class="line"><span class="lineno">   37</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;[<a class="code hl_struct" href="structps_1_1Point.html">min_val</a>, <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>] = <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">   38</span>      <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] &lt; <a class="code hl_struct" href="structps_1_1Point.html">min_val</a> || <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] &gt; <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>)</div>
<div class="line"><span class="lineno">   39</span>      {</div>
<div class="line"><span class="lineno">   40</span>        <a class="code hl_struct" href="structps_1_1Point.html">inside</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   41</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   42</span>      }</div>
<div class="line"><span class="lineno">   43</span>    }</div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">if</span> (inside)</div>
<div class="line"><span class="lineno">   45</span>      filtered.push_back(p);</div>
<div class="line"><span class="lineno">   46</span>  }</div>
<div class="line"><span class="lineno">   47</span> </div>
<div class="line"><span class="lineno">   48</span>  <span class="keywordflow">return</span> filtered;</div>
<div class="line"><span class="lineno">   49</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0efaff8017d5a171ffdf0ed0201bd65d" name="a0efaff8017d5a171ffdf0ed0201bd65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efaff8017d5a171ffdf0ed0201bd65d">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>cluster_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gaussian__clusters_8hpp_source.html#l00040">40</a> of file <a class="el" href="gaussian__clusters_8hpp_source.html">gaussian_clusters.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   46</span>{</div>
<div class="line"><span class="lineno">   47</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">cluster_centers</a> = <a class="code hl_struct" href="structps_1_1Point.html">random&lt;T, N&gt;</a>(<a class="code hl_struct" href="structps_1_1Point.html">cluster_count</a>,</div>
<div class="line"><span class="lineno">   48</span>                                                          <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>,</div>
<div class="line"><span class="lineno">   49</span>                                                          <a class="code hl_struct" href="structps_1_1Point.html">seed</a>);</div>
<div class="line"><span class="lineno">   50</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">points</a> = <a class="code hl_function" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">gaussian_clusters</a>(<a class="code hl_struct" href="structps_1_1Point.html">cluster_centers</a>,</div>
<div class="line"><span class="lineno">   51</span>                                                      <a class="code hl_struct" href="structps_1_1Point.html">points_per_cluster</a>,</div>
<div class="line"><span class="lineno">   52</span>                                                      <a class="code hl_struct" href="structps_1_1Point.html">spread</a>,</div>
<div class="line"><span class="lineno">   53</span>                                                      <a class="code hl_struct" href="structps_1_1Point.html">seed</a>);</div>
<div class="line"><span class="lineno">   54</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">points</a>;</div>
<div class="line"><span class="lineno">   55</span>}</div>
<div class="ttc" id="anamespaceps_html_a913ab9d687ee42d04488e5eb0373e23a"><div class="ttname"><a href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">ps::gaussian_clusters</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; gaussian_clusters(std::vector&lt; Point&lt; T, N &gt; &gt; cluster_centers, size_t points_per_cluster, T spread, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdef"><b>Definition</b> <a href="gaussian__clusters_8hpp_source.html#l00014">gaussian_clusters.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a913ab9d687ee42d04488e5eb0373e23a" name="a913ab9d687ee42d04488e5eb0373e23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913ab9d687ee42d04488e5eb0373e23a">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>cluster_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gaussian__clusters_8hpp_source.html#l00014">14</a> of file <a class="el" href="gaussian__clusters_8hpp_source.html">gaussian_clusters.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   19</span>{</div>
<div class="line"><span class="lineno">   20</span>  std::mt19937 <a class="code hl_struct" href="structps_1_1Point.html">gen</a>(<a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : <a class="code hl_struct" href="structps_1_1Point.html">std</a>::<a class="code hl_struct" href="structps_1_1Point.html">random_device</a>{}());</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">points</a>;</div>
<div class="line"><span class="lineno">   23</span>  <a class="code hl_struct" href="structps_1_1Point.html">points</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">cluster_centers</a>.size() * <a class="code hl_struct" href="structps_1_1Point.html">points_per_cluster</a>);</div>
<div class="line"><span class="lineno">   24</span> </div>
<div class="line"><span class="lineno">   25</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">cluster_centers</a>.size(); ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   26</span>  {</div>
<div class="line"><span class="lineno">   27</span>    std::normal_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">dist</a>(0, <a class="code hl_struct" href="structps_1_1Point.html">spread</a>);</div>
<div class="line"><span class="lineno">   28</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">j</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">j</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">points_per_cluster</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">j</a>)</div>
<div class="line"><span class="lineno">   29</span>    {</div>
<div class="line"><span class="lineno">   30</span>      <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">p</a>;</div>
<div class="line"><span class="lineno">   31</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">k</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">k</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">k</a>)</div>
<div class="line"><span class="lineno">   32</span>        <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">k</a>] = <a class="code hl_struct" href="structps_1_1Point.html">cluster_centers</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>][<a class="code hl_struct" href="structps_1_1Point.html">k</a>] + <a class="code hl_struct" href="structps_1_1Point.html">dist</a>(<a class="code hl_struct" href="structps_1_1Point.html">gen</a>);</div>
<div class="line"><span class="lineno">   33</span>      <a class="code hl_struct" href="structps_1_1Point.html">points</a>.push_back(<a class="code hl_struct" href="structps_1_1Point.html">p</a>);</div>
<div class="line"><span class="lineno">   34</span>    }</div>
<div class="line"><span class="lineno">   35</span>  }</div>
<div class="line"><span class="lineno">   36</span>  <span class="keywordflow">return</span> points;</div>
<div class="line"><span class="lineno">   37</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a898bca65491a14a41bfdd50fdc6230b8" name="a898bca65491a14a41bfdd50fdc6230b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898bca65491a14a41bfdd50fdc6230b8">&#9670;&#160;</a></span>generate_random_point_around()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; ps::generate_random_point_around </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structps_1_1Point.html">T</a>(<a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="poisson__disk__sampling_8hpp_source.html#l00139">139</a> of file <a class="el" href="poisson__disk__sampling_8hpp_source.html">poisson_disk_sampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  143</span>{</div>
<div class="line"><span class="lineno">  144</span>  std::uniform_real_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">dist_angle</a>(0, 2 * <a class="code hl_struct" href="structps_1_1Point.html">M_PI</a>);</div>
<div class="line"><span class="lineno">  145</span>  std::uniform_real_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">dist_radius</a>(0, 1);</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>  <span class="comment">// Generate random direction in N dimensions using normal distribution method</span></div>
<div class="line"><span class="lineno">  148</span>  std::normal_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">normal</a>(0, 1);</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">dir</a>;</div>
<div class="line"><span class="lineno">  151</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a>           <a class="code hl_struct" href="structps_1_1Point.html">length_dir</a> = 0;</div>
<div class="line"><span class="lineno">  152</span>  <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno">  153</span>  {</div>
<div class="line"><span class="lineno">  154</span>    <a class="code hl_struct" href="structps_1_1Point.html">length_dir</a> = 0;</div>
<div class="line"><span class="lineno">  155</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  156</span>    {</div>
<div class="line"><span class="lineno">  157</span>      <a class="code hl_struct" href="structps_1_1Point.html">dir</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">normal</a>(<a class="code hl_struct" href="structps_1_1Point.html">gen</a>);</div>
<div class="line"><span class="lineno">  158</span>      <a class="code hl_struct" href="structps_1_1Point.html">length_dir</a> += <a class="code hl_struct" href="structps_1_1Point.html">dir</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] * <a class="code hl_struct" href="structps_1_1Point.html">dir</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  159</span>    }</div>
<div class="line"><span class="lineno">  160</span>    length_dir = std::sqrt(length_dir);</div>
<div class="line"><span class="lineno">  161</span>  } <span class="keywordflow">while</span> (length_dir == 0);</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">  164</span>    dir[i] /= length_dir;</div>
<div class="line"><span class="lineno">  165</span> </div>
<div class="line"><span class="lineno">  166</span>  T                                 scaled_min_dist = scale_fn(center) * base_min_dist;</div>
<div class="line"><span class="lineno">  167</span>  std::uniform_real_distribution&lt;T&gt; dist_r(scaled_min_dist, 2 * scaled_min_dist);</div>
<div class="line"><span class="lineno">  168</span>  T                                 r = dist_r(gen);</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>  Point&lt;T, N&gt; p;</div>
<div class="line"><span class="lineno">  171</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">  172</span>    p[i] = center[i] + dir[i] * r;</div>
<div class="line"><span class="lineno">  173</span> </div>
<div class="line"><span class="lineno">  174</span>  <span class="keywordflow">return</span> p;</div>
<div class="line"><span class="lineno">  175</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a81b18395a05f0bb4d483406e79aa9524" name="a81b18395a05f0bb4d483406e79aa9524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b18395a05f0bb4d483406e79aa9524">&#9670;&#160;</a></span>halton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::halton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="halton_8hpp_source.html#l00042">42</a> of file <a class="el" href="halton_8hpp_source.html">halton.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   45</span>{</div>
<div class="line"><span class="lineno">   46</span>  <span class="comment">// seed-like effect...</span></div>
<div class="line"><span class="lineno">   47</span>  <span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">shift</a> = <a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : 0;</div>
<div class="line"><span class="lineno">   48</span>  <span class="keyword">auto</span>   <a class="code hl_struct" href="structps_1_1Point.html">points</a> = <a class="code hl_struct" href="structps_1_1Point.html">halton_sequence&lt;T, N&gt;</a>(<a class="code hl_struct" href="structps_1_1Point.html">count</a>, <a class="code hl_struct" href="structps_1_1Point.html">shift</a>);</div>
<div class="line"><span class="lineno">   49</span>  <a class="code hl_function" href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">rescale_points</a>(<a class="code hl_struct" href="structps_1_1Point.html">points</a>, <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>);</div>
<div class="line"><span class="lineno">   50</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">points</a>;</div>
<div class="line"><span class="lineno">   51</span>}</div>
<div class="ttc" id="anamespaceps_html_a7addf1455112b7895f8de7c475eed850"><div class="ttname"><a href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">ps::rescale_points</a></div><div class="ttdeci">void rescale_points(std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges)</div><div class="ttdef"><b>Definition</b> <a href="range_8hpp_source.html#l00142">range.hpp:142</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8c3b3b3367276f9a194938599d2463b" name="aa8c3b3b3367276f9a194938599d2463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c3b3b3367276f9a194938599d2463b">&#9670;&#160;</a></span>halton_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::halton_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="halton_8hpp_source.html#l00014">14</a> of file <a class="el" href="halton_8hpp_source.html">halton.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   15</span>{</div>
<div class="line"><span class="lineno">   16</span>  <span class="keyword">auto</span> <a class="code hl_function" href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">halton</a> = [](<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">index</a>, <span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">base</a>) -&gt; <a class="code hl_struct" href="structps_1_1Point.html">T</a></div>
<div class="line"><span class="lineno">   17</span>  {</div>
<div class="line"><span class="lineno">   18</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a> = 0;</div>
<div class="line"><span class="lineno">   19</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">f</a> = 1;</div>
<div class="line"><span class="lineno">   20</span>    <span class="keywordflow">while</span> (<a class="code hl_struct" href="structps_1_1Point.html">index</a> &gt; 0)</div>
<div class="line"><span class="lineno">   21</span>    {</div>
<div class="line"><span class="lineno">   22</span>      <a class="code hl_struct" href="structps_1_1Point.html">f</a> = <a class="code hl_struct" href="structps_1_1Point.html">f</a> / <a class="code hl_struct" href="structps_1_1Point.html">base</a>;</div>
<div class="line"><span class="lineno">   23</span>      <a class="code hl_struct" href="structps_1_1Point.html">result</a> += <a class="code hl_struct" href="structps_1_1Point.html">f</a> * (<a class="code hl_struct" href="structps_1_1Point.html">index</a> % <a class="code hl_struct" href="structps_1_1Point.html">base</a>);</div>
<div class="line"><span class="lineno">   24</span>      <a class="code hl_struct" href="structps_1_1Point.html">index</a> = <a class="code hl_struct" href="structps_1_1Point.html">index</a> / <a class="code hl_struct" href="structps_1_1Point.html">base</a>;</div>
<div class="line"><span class="lineno">   25</span>    }</div>
<div class="line"><span class="lineno">   26</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">   27</span>  };</div>
<div class="line"><span class="lineno">   28</span> </div>
<div class="line"><span class="lineno">   29</span>  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> primes[15] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};</div>
<div class="line"><span class="lineno">   30</span>  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> n_primes = 15;</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>  std::vector&lt;Point&lt;T, N&gt;&gt; points(count);</div>
<div class="line"><span class="lineno">   33</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i)</div>
<div class="line"><span class="lineno">   34</span>  {</div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">   36</span>      points[i][d] = <a class="code hl_function" href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">halton</a>(i + 1 + shift, primes[std::min(n_primes - 1, d)]);</div>
<div class="line"><span class="lineno">   37</span>  }</div>
<div class="line"><span class="lineno">   38</span>  <span class="keywordflow">return</span> points;</div>
<div class="line"><span class="lineno">   39</span>}</div>
<div class="ttc" id="anamespaceps_html_a81b18395a05f0bb4d483406e79aa9524"><div class="ttname"><a href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">ps::halton</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; halton(size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdef"><b>Definition</b> <a href="halton_8hpp_source.html#l00042">halton.hpp:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aad0cc7bc81f7cac9f0be26177b9986a6" name="aad0cc7bc81f7cac9f0be26177b9986a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cc7bc81f7cac9f0be26177b9986a6">&#9670;&#160;</a></span>hammersley()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::hammersley </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hammersley_8hpp_source.html#l00043">43</a> of file <a class="el" href="hammersley_8hpp_source.html">hammersley.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   46</span>{</div>
<div class="line"><span class="lineno">   47</span>  <span class="comment">// seed-like effect...</span></div>
<div class="line"><span class="lineno">   48</span>  <span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">shift</a> = <a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : 0;</div>
<div class="line"><span class="lineno">   49</span>  <span class="keyword">auto</span>   <a class="code hl_struct" href="structps_1_1Point.html">points</a> = <a class="code hl_struct" href="structps_1_1Point.html">hammersley_sequence&lt;T, N&gt;</a>(<a class="code hl_struct" href="structps_1_1Point.html">count</a>, <a class="code hl_struct" href="structps_1_1Point.html">shift</a>);</div>
<div class="line"><span class="lineno">   50</span>  <a class="code hl_function" href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">rescale_points</a>(<a class="code hl_struct" href="structps_1_1Point.html">points</a>, <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>);</div>
<div class="line"><span class="lineno">   51</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">points</a>;</div>
<div class="line"><span class="lineno">   52</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae21a8c51533330ead4ebe76eed3e72b3" name="ae21a8c51533330ead4ebe76eed3e72b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21a8c51533330ead4ebe76eed3e72b3">&#9670;&#160;</a></span>hammersley_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::hammersley_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="hammersley_8hpp_source.html#l00014">14</a> of file <a class="el" href="hammersley_8hpp_source.html">hammersley.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   15</span>{</div>
<div class="line"><span class="lineno">   16</span>  <span class="keyword">auto</span> <a class="code hl_struct" href="structps_1_1Point.html">van_der_corput</a> = [](<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">n</a>, <span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">base</a>) -&gt; <a class="code hl_struct" href="structps_1_1Point.html">T</a></div>
<div class="line"><span class="lineno">   17</span>  {</div>
<div class="line"><span class="lineno">   18</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">q</a> = 0;</div>
<div class="line"><span class="lineno">   19</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">bk</a> = 1.0 / <a class="code hl_struct" href="structps_1_1Point.html">base</a>;</div>
<div class="line"><span class="lineno">   20</span>    <span class="keywordflow">while</span> (<a class="code hl_struct" href="structps_1_1Point.html">n</a> &gt; 0)</div>
<div class="line"><span class="lineno">   21</span>    {</div>
<div class="line"><span class="lineno">   22</span>      <a class="code hl_struct" href="structps_1_1Point.html">q</a> += <a class="code hl_struct" href="structps_1_1Point.html">T</a>(<a class="code hl_struct" href="structps_1_1Point.html">n</a> % <a class="code hl_struct" href="structps_1_1Point.html">base</a>) * <a class="code hl_struct" href="structps_1_1Point.html">bk</a>;</div>
<div class="line"><span class="lineno">   23</span>      <a class="code hl_struct" href="structps_1_1Point.html">n</a> /= <a class="code hl_struct" href="structps_1_1Point.html">base</a>;</div>
<div class="line"><span class="lineno">   24</span>      <a class="code hl_struct" href="structps_1_1Point.html">bk</a> /= <a class="code hl_struct" href="structps_1_1Point.html">base</a>;</div>
<div class="line"><span class="lineno">   25</span>    }</div>
<div class="line"><span class="lineno">   26</span>    <span class="keywordflow">return</span> q;</div>
<div class="line"><span class="lineno">   27</span>  };</div>
<div class="line"><span class="lineno">   28</span> </div>
<div class="line"><span class="lineno">   29</span>  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> primes[15] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};</div>
<div class="line"><span class="lineno">   30</span>  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> n_primes = 15;</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>  std::vector&lt;Point&lt;T, N&gt;&gt; points(count);</div>
<div class="line"><span class="lineno">   33</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i)</div>
<div class="line"><span class="lineno">   34</span>  {</div>
<div class="line"><span class="lineno">   35</span>    points[i][0] = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(i) / <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(count);</div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 1; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">   37</span>      points[i][d] = van_der_corput(i + shift, primes[std::min(n_primes - 1, d - 1)]);</div>
<div class="line"><span class="lineno">   38</span>  }</div>
<div class="line"><span class="lineno">   39</span>  <span class="keywordflow">return</span> points;</div>
<div class="line"><span class="lineno">   40</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a932640b18d76a7e336fc760e9cf5511b" name="a932640b18d76a7e336fc760e9cf5511b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932640b18d76a7e336fc760e9cf5511b">&#9670;&#160;</a></span>importance_resampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">DensityFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::importance_resampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>oversampling_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">DensityFn</a>&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="importance__resampling_8hpp_source.html#l00014">14</a> of file <a class="el" href="importance__resampling_8hpp_source.html">importance_resampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   20</span>{</div>
<div class="line"><span class="lineno">   21</span>  std::mt19937 <a class="code hl_struct" href="structps_1_1Point.html">gen</a>(<a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : <a class="code hl_struct" href="structps_1_1Point.html">std</a>::<a class="code hl_struct" href="structps_1_1Point.html">random_device</a>{}());</div>
<div class="line"><span class="lineno">   22</span> </div>
<div class="line"><span class="lineno">   23</span>  <span class="comment">// Generate grid</span></div>
<div class="line"><span class="lineno">   24</span>  <span class="keywordtype">size_t</span>                   <a class="code hl_struct" href="structps_1_1Point.html">count_grid</a> = <a class="code hl_struct" href="structps_1_1Point.html">count</a> * <a class="code hl_struct" href="structps_1_1Point.html">oversampling_ratio</a>;</div>
<div class="line"><span class="lineno">   25</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">grid_points</a> = <a class="code hl_struct" href="structps_1_1Point.html">halton&lt;T, N&gt;</a>(<a class="code hl_struct" href="structps_1_1Point.html">count_grid</a>, <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>, <a class="code hl_struct" href="structps_1_1Point.html">seed</a>);</div>
<div class="line"><span class="lineno">   26</span> </div>
<div class="line"><span class="lineno">   27</span>  <span class="comment">// Weights</span></div>
<div class="line"><span class="lineno">   28</span>  std::vector&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">weights</a>;</div>
<div class="line"><span class="lineno">   29</span>  <a class="code hl_struct" href="structps_1_1Point.html">weights</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">count_grid</a>);</div>
<div class="line"><span class="lineno">   30</span> </div>
<div class="line"><span class="lineno">   31</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">p</a> : <a class="code hl_struct" href="structps_1_1Point.html">grid_points</a>)</div>
<div class="line"><span class="lineno">   32</span>    <a class="code hl_struct" href="structps_1_1Point.html">weights</a>.<a class="code hl_struct" href="structps_1_1Point.html">push_back</a>(<a class="code hl_struct" href="structps_1_1Point.html">density_fn</a>(<a class="code hl_struct" href="structps_1_1Point.html">p</a>));</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>  <span class="comment">// Normalize weights</span></div>
<div class="line"><span class="lineno">   35</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">sum</a> = std::accumulate(<a class="code hl_struct" href="structps_1_1Point.html">weights</a>.begin(), <a class="code hl_struct" href="structps_1_1Point.html">weights</a>.end(), <a class="code hl_struct" href="structps_1_1Point.html">T</a>(0));</div>
<div class="line"><span class="lineno">   36</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;w : <a class="code hl_struct" href="structps_1_1Point.html">weights</a>)</div>
<div class="line"><span class="lineno">   37</span>    w /= <a class="code hl_struct" href="structps_1_1Point.html">sum</a>;</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span>  <span class="comment">// Resample</span></div>
<div class="line"><span class="lineno">   40</span>  std::discrete_distribution&lt;size_t&gt; <a class="code hl_struct" href="structps_1_1Point.html">dist</a>(<a class="code hl_struct" href="structps_1_1Point.html">weights</a>.begin(), <a class="code hl_struct" href="structps_1_1Point.html">weights</a>.end());</div>
<div class="line"><span class="lineno">   41</span>  std::vector&lt;Point&lt;T, N&gt;&gt;           <a class="code hl_struct" href="structps_1_1Point.html">samples</a>;</div>
<div class="line"><span class="lineno">   42</span>  <a class="code hl_struct" href="structps_1_1Point.html">samples</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">count</a>);</div>
<div class="line"><span class="lineno">   43</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">count</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   44</span>    <a class="code hl_struct" href="structps_1_1Point.html">samples</a>.push_back(<a class="code hl_struct" href="structps_1_1Point.html">grid_points</a>[<a class="code hl_struct" href="structps_1_1Point.html">dist</a>(<a class="code hl_struct" href="structps_1_1Point.html">gen</a>)]);</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">samples</a>;</div>
<div class="line"><span class="lineno">   47</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedb5908eae325f054e4f3dd6b9b223af" name="aedb5908eae325f054e4f3dd6b9b223af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb5908eae325f054e4f3dd6b9b223af">&#9670;&#160;</a></span>in_neighborhood()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">bool</a> ps::in_neighborhood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="poisson__disk__sampling_8hpp_source.html#l00069">69</a> of file <a class="el" href="poisson__disk__sampling_8hpp_source.html">poisson_disk_sampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   74</span>{</div>
<div class="line"><span class="lineno">   75</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">scaled_min_dist_p</a> = <a class="code hl_struct" href="structps_1_1Point.html">scale_fn</a>(<a class="code hl_struct" href="structps_1_1Point.html">p</a>) * <a class="code hl_struct" href="structps_1_1Point.html">base_min_dist</a>;</div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>  <span class="comment">// Convert point to grid coordinates</span></div>
<div class="line"><span class="lineno">   78</span>  <span class="keyword">auto</span> <a class="code hl_struct" href="structps_1_1Point.html">idx</a> = <a class="code hl_struct" href="structps_1_1Point.html">grid</a>.point_to_grid(<a class="code hl_struct" href="structps_1_1Point.html">p</a>, <a class="code hl_struct" href="structps_1_1Point.html">ranges</a>);</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>  <span class="comment">// Calculate the radius in cells to check neighbors</span></div>
<div class="line"><span class="lineno">   81</span>  <span class="keywordtype">int</span> <a class="code hl_struct" href="structps_1_1Point.html">radius</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::ceil(<a class="code hl_struct" href="structps_1_1Point.html">scaled_min_dist_p</a> / <a class="code hl_struct" href="structps_1_1Point.html">grid</a>.cell_size));</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>  <span class="comment">// Iterate neighbor cells in N dimensions (hypercube)</span></div>
<div class="line"><span class="lineno">   84</span>  <span class="comment">// We&#39;ll do a recursive iteration over N dims</span></div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>  std::array&lt;int, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">offsets</a>{};</div>
<div class="line"><span class="lineno">   87</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">   88</span>    offsets[i] = -radius;</div>
<div class="line"><span class="lineno">   89</span> </div>
<div class="line"><span class="lineno">   90</span>  <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>  <span class="comment">// Recursive lambda to iterate neighbors</span></div>
<div class="line"><span class="lineno">   93</span>  std::function&lt;void(<span class="keywordtype">size_t</span>)&gt; check_neighbors;</div>
<div class="line"><span class="lineno">   94</span>  check_neighbors = [&amp;](<span class="keywordtype">size_t</span> dim)</div>
<div class="line"><span class="lineno">   95</span>  {</div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordflow">if</span> (dim == N)</div>
<div class="line"><span class="lineno">   97</span>    {</div>
<div class="line"><span class="lineno">   98</span>      <span class="comment">// Compute neighbor cell index</span></div>
<div class="line"><span class="lineno">   99</span>      std::array&lt;size_t, N&gt; neighbor_idx{};</div>
<div class="line"><span class="lineno">  100</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">  101</span>      {</div>
<div class="line"><span class="lineno">  102</span>        <span class="keywordtype">int</span> val = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(idx[d]) + offsets[d];</div>
<div class="line"><span class="lineno">  103</span>        <span class="keywordflow">if</span> (val &lt; 0 || val &gt;= <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(grid.grid_size[d]))</div>
<div class="line"><span class="lineno">  104</span>          <span class="keywordflow">return</span>; <span class="comment">// out of grid bounds</span></div>
<div class="line"><span class="lineno">  105</span>        neighbor_idx[d] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(val);</div>
<div class="line"><span class="lineno">  106</span>      }</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;slot = grid[neighbor_idx];</div>
<div class="line"><span class="lineno">  109</span>      <span class="keywordflow">if</span> (slot)</div>
<div class="line"><span class="lineno">  110</span>      {</div>
<div class="line"><span class="lineno">  111</span>        T scaled_min_dist_slot = scale_fn(slot.value()) * base_min_dist;</div>
<div class="line"><span class="lineno">  112</span>        T dist_thresh = std::max(scaled_min_dist_p, scaled_min_dist_slot);</div>
<div class="line"><span class="lineno">  113</span>        T dist_thresh_sq = dist_thresh * dist_thresh;</div>
<div class="line"><span class="lineno">  114</span> </div>
<div class="line"><span class="lineno">  115</span>        Point&lt;T, N&gt; diff = p - slot.value();</div>
<div class="line"><span class="lineno">  116</span>        T           dist_sq = T(0);</div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">  118</span>          dist_sq += diff[i] * diff[i];</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>        <span class="keywordflow">if</span> (dist_sq &lt; dist_thresh_sq)</div>
<div class="line"><span class="lineno">  121</span>          result = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  122</span>      }</div>
<div class="line"><span class="lineno">  123</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  124</span>    }</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">for</span> (offsets[dim] = -radius; offsets[dim] &lt;= radius; ++offsets[dim])</div>
<div class="line"><span class="lineno">  127</span>    {</div>
<div class="line"><span class="lineno">  128</span>      check_neighbors(dim + 1);</div>
<div class="line"><span class="lineno">  129</span>      <span class="keywordflow">if</span> (result)</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  131</span>    }</div>
<div class="line"><span class="lineno">  132</span>  };</div>
<div class="line"><span class="lineno">  133</span> </div>
<div class="line"><span class="lineno">  134</span>  check_neighbors(0);</div>
<div class="line"><span class="lineno">  135</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  136</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8525c124fef24618bf574b9b7b1ece8" name="ad8525c124fef24618bf574b9b7b1ece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8525c124fef24618bf574b9b7b1ece8">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>jitter_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stagger_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="jittered__grid_8hpp_source.html#l00013">13</a> of file <a class="el" href="jittered__grid_8hpp_source.html">jittered_grid.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   18</span>{</div>
<div class="line"><span class="lineno">   19</span>  std::mt19937                      <a class="code hl_struct" href="structps_1_1Point.html">gen</a>(<a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : <a class="code hl_struct" href="structps_1_1Point.html">std</a>::<a class="code hl_struct" href="structps_1_1Point.html">random_device</a>{}());</div>
<div class="line"><span class="lineno">   20</span>  std::uniform_real_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">uniform01</a>(0.0, 1.0);</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span>  std::array&lt;size_t, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">resolution</a>;</div>
<div class="line"><span class="lineno">   23</span>  <span class="keywordtype">size_t</span>                <a class="code hl_struct" href="structps_1_1Point.html">total_cells</a> = 1;</div>
<div class="line"><span class="lineno">   24</span> </div>
<div class="line"><span class="lineno">   25</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">volume</a> = 1;</div>
<div class="line"><span class="lineno">   26</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[<a class="code hl_struct" href="structps_1_1Point.html">min</a>, <a class="code hl_struct" href="structps_1_1Point.html">max</a>] : <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>)</div>
<div class="line"><span class="lineno">   27</span>    <a class="code hl_struct" href="structps_1_1Point.html">volume</a> *= (<a class="code hl_struct" href="structps_1_1Point.html">max</a> - <a class="code hl_struct" href="structps_1_1Point.html">min</a>);</div>
<div class="line"><span class="lineno">   28</span> </div>
<div class="line"><span class="lineno">   29</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">target_cell_volume</a> = <a class="code hl_struct" href="structps_1_1Point.html">volume</a> / <span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structps_1_1Point.html">T</a><span class="keyword">&gt;</span>(<a class="code hl_struct" href="structps_1_1Point.html">count</a>);</div>
<div class="line"><span class="lineno">   30</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">cell_size_estimate</a> = std::pow(<a class="code hl_struct" href="structps_1_1Point.html">target_cell_volume</a>, <span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structps_1_1Point.html">T</a><span class="keyword">&gt;</span>(1.0) / <a class="code hl_struct" href="structps_1_1Point.html">N</a>);</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   33</span>  {</div>
<div class="line"><span class="lineno">   34</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">range</a> = <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>].second - <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>].first;</div>
<div class="line"><span class="lineno">   35</span>    <a class="code hl_struct" href="structps_1_1Point.html">resolution</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = std::max&lt;size_t&gt;(1, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code hl_struct" href="structps_1_1Point.html">range</a> / <a class="code hl_struct" href="structps_1_1Point.html">cell_size_estimate</a>));</div>
<div class="line"><span class="lineno">   36</span>    <a class="code hl_struct" href="structps_1_1Point.html">total_cells</a> *= <a class="code hl_struct" href="structps_1_1Point.html">resolution</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">   37</span>  }</div>
<div class="line"><span class="lineno">   38</span> </div>
<div class="line"><span class="lineno">   39</span>  std::vector&lt;Point&lt;T, N&gt;&gt; points;</div>
<div class="line"><span class="lineno">   40</span>  points.reserve(std::min(count, total_cells));</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>  std::vector&lt;std::array&lt;size_t, N&gt;&gt; cell_indices;</div>
<div class="line"><span class="lineno">   43</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> linear = 0; linear &lt; total_cells; ++linear)</div>
<div class="line"><span class="lineno">   44</span>  {</div>
<div class="line"><span class="lineno">   45</span>    std::array&lt;size_t, N&gt; index{};</div>
<div class="line"><span class="lineno">   46</span>    <span class="keywordtype">size_t</span>                div = 1;</div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">   48</span>    {</div>
<div class="line"><span class="lineno">   49</span>      index[i] = (linear / div) % resolution[i];</div>
<div class="line"><span class="lineno">   50</span>      div *= resolution[i];</div>
<div class="line"><span class="lineno">   51</span>    }</div>
<div class="line"><span class="lineno">   52</span>    cell_indices.push_back(index);</div>
<div class="line"><span class="lineno">   53</span>  }</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>  std::shuffle(cell_indices.begin(), cell_indices.end(), gen);</div>
<div class="line"><span class="lineno">   56</span>  <span class="keywordtype">size_t</span> limit = std::min(count, cell_indices.size());</div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; limit; ++i)</div>
<div class="line"><span class="lineno">   59</span>  {</div>
<div class="line"><span class="lineno">   60</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;idx = cell_indices[i];</div>
<div class="line"><span class="lineno">   61</span>    Point&lt;T, N&gt; p;</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">   64</span>    {</div>
<div class="line"><span class="lineno">   65</span>      T range_min = axis_ranges[d].first;</div>
<div class="line"><span class="lineno">   66</span>      T range_max = axis_ranges[d].second;</div>
<div class="line"><span class="lineno">   67</span>      T cell_size = (range_max - range_min) / <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(resolution[d]);</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>      T jitter_range = jitter_amount[d] * cell_size;</div>
<div class="line"><span class="lineno">   70</span>      T jitter_center = (1.0 - jitter_amount[d]) * 0.5 * cell_size;</div>
<div class="line"><span class="lineno">   71</span>      T jitter = uniform01(gen) * jitter_range;</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>      <span class="comment">// Compute stagger offset from higher dimensions</span></div>
<div class="line"><span class="lineno">   74</span>      T stagger_offset = 0;</div>
<div class="line"><span class="lineno">   75</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = d + 1; k &lt; N; ++k)</div>
<div class="line"><span class="lineno">   76</span>      {</div>
<div class="line"><span class="lineno">   77</span>        <span class="keywordflow">if</span> (idx[k] % 2 == 1)</div>
<div class="line"><span class="lineno">   78</span>          stagger_offset += stagger_ratio[d] * cell_size;</div>
<div class="line"><span class="lineno">   79</span>      }</div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>      p[d] = range_min + idx[d] * cell_size + jitter_center + jitter + stagger_offset;</div>
<div class="line"><span class="lineno">   82</span>    }</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>    points.push_back(p);</div>
<div class="line"><span class="lineno">   85</span>  }</div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>  <span class="keywordflow">return</span> points;</div>
<div class="line"><span class="lineno">   88</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae90df8db8e751ff4b61298114f092714" name="ae90df8db8e751ff4b61298114f092714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90df8db8e751ff4b61298114f092714">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="jittered__grid_8hpp_source.html#l00092">92</a> of file <a class="el" href="jittered__grid_8hpp_source.html">jittered_grid.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   95</span>{</div>
<div class="line"><span class="lineno">   96</span>  std::array&lt;T, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">full_jitter</a>;</div>
<div class="line"><span class="lineno">   97</span>  std::array&lt;T, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">stagger_ratio</a>;</div>
<div class="line"><span class="lineno">   98</span>  <a class="code hl_struct" href="structps_1_1Point.html">full_jitter</a>.fill(<span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structps_1_1Point.html">T</a><span class="keyword">&gt;</span>(1.0));</div>
<div class="line"><span class="lineno">   99</span>  <a class="code hl_struct" href="structps_1_1Point.html">stagger_ratio</a>.fill(<span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structps_1_1Point.html">T</a><span class="keyword">&gt;</span>(0.0));</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">jittered_grid&lt;T, N&gt;</a>(<a class="code hl_struct" href="structps_1_1Point.html">count</a>, <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>, <a class="code hl_struct" href="structps_1_1Point.html">full_jitter</a>, <a class="code hl_struct" href="structps_1_1Point.html">stagger_ratio</a>, <a class="code hl_struct" href="structps_1_1Point.html">seed</a>);</div>
<div class="line"><span class="lineno">  102</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a38d89dd8b52a63eabb39ef5e425d5746" name="a38d89dd8b52a63eabb39ef5e425d5746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d89dd8b52a63eabb39ef5e425d5746">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">T</a> ps::length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00206">206</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  207</span>{</div>
<div class="line"><span class="lineno">  208</span>  <span class="keywordflow">return</span> std::sqrt(<a class="code hl_function" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a>(<a class="code hl_struct" href="structps_1_1Point.html">a</a>));</div>
<div class="line"><span class="lineno">  209</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c3e161560ad3000aa4e2218291b169c" name="a7c3e161560ad3000aa4e2218291b169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3e161560ad3000aa4e2218291b169c">&#9670;&#160;</a></span>length_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">T</a> ps::length_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00201">201</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  202</span>{</div>
<div class="line"><span class="lineno">  203</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a>(<a class="code hl_struct" href="structps_1_1Point.html">a</a>, <a class="code hl_struct" href="structps_1_1Point.html">a</a>);</div>
<div class="line"><span class="lineno">  204</span>}</div>
<div class="ttc" id="anamespaceps_html_ace7642868199df621df9139e5179767b"><div class="ttname"><a href="namespaceps.html#ace7642868199df621df9139e5179767b">ps::dot</a></div><div class="ttdeci">T dot(const Point&lt; T, N &gt; &amp;a, const Point&lt; T, N &gt; &amp;b)</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00193">point.hpp:193</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a79914e9fc2dd02bacd38e9bd32e21baa" name="a79914e9fc2dd02bacd38e9bd32e21baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79914e9fc2dd02bacd38e9bd32e21baa">&#9670;&#160;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; ps::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00232">232</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  233</span>{</div>
<div class="line"><span class="lineno">  234</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">a</a> + (<a class="code hl_struct" href="structps_1_1Point.html">b</a> - <a class="code hl_struct" href="structps_1_1Point.html">a</a>) * <a class="code hl_struct" href="structps_1_1Point.html">t</a>;</div>
<div class="line"><span class="lineno">  235</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7de6090e2c8291401816be9bc6cda914" name="a7de6090e2c8291401816be9bc6cda914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6090e2c8291401816be9bc6cda914">&#9670;&#160;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; ps::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00211">211</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  212</span>{</div>
<div class="line"><span class="lineno">  213</span>  <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">len</a> = <a class="code hl_function" href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">length</a>(<a class="code hl_struct" href="structps_1_1Point.html">a</a>);</div>
<div class="line"><span class="lineno">  214</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">len</a> == <a class="code hl_struct" href="structps_1_1Point.html">T</a>(0))</div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a>();</div>
<div class="line"><span class="lineno">  216</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">a</a> / <a class="code hl_struct" href="structps_1_1Point.html">len</a>;</div>
<div class="line"><span class="lineno">  218</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6fd3a6df3727a04f9baba3b8b87a903b" name="a6fd3a6df3727a04f9baba3b8b87a903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd3a6df3727a04f9baba3b8b87a903b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00129">129</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  130</span>{</div>
<div class="line"><span class="lineno">  131</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  132</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  133</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">a</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] * <a class="code hl_struct" href="structps_1_1Point.html">b</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  134</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  135</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd4dc781f43ba8a50daa139682846d4b" name="acd4dc781f43ba8a50daa139682846d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4dc781f43ba8a50daa139682846d4b">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00163">163</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  164</span>{</div>
<div class="line"><span class="lineno">  165</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  166</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  167</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] * <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  168</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  169</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfd6fe71db1c4df607bfdace9dffb5b4" name="abfd6fe71db1c4df607bfdace9dffb5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6fe71db1c4df607bfdace9dffb5b4">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00180">180</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  181</span>{</div>
<div class="line"><span class="lineno">  182</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">p</a> * <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  183</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af9ee1cf5d335276b7fabe6f1daddf1b0" name="af9ee1cf5d335276b7fabe6f1daddf1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ee1cf5d335276b7fabe6f1daddf1b0">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00111">111</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  112</span>{</div>
<div class="line"><span class="lineno">  113</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  114</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  115</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">a</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] + <a class="code hl_struct" href="structps_1_1Point.html">b</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  116</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  117</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a366ef094d65da865384b6fb77aac5d5f" name="a366ef094d65da865384b6fb77aac5d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ef094d65da865384b6fb77aac5d5f">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00147">147</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  148</span>{</div>
<div class="line"><span class="lineno">  149</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  150</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  151</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] + <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  152</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  153</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe774cb61bde6358f8a7024c42db9804" name="afe774cb61bde6358f8a7024c42db9804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe774cb61bde6358f8a7024c42db9804">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00185">185</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  186</span>{</div>
<div class="line"><span class="lineno">  187</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">p</a> + <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  188</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa369956286bc3f09dfdc146a5b2a49f1" name="aa369956286bc3f09dfdc146a5b2a49f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa369956286bc3f09dfdc146a5b2a49f1">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00120">120</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  121</span>{</div>
<div class="line"><span class="lineno">  122</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  123</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  124</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">a</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] - <a class="code hl_struct" href="structps_1_1Point.html">b</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  125</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  126</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a79196b5b8a95ad9d3bc2ad698425944f" name="a79196b5b8a95ad9d3bc2ad698425944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79196b5b8a95ad9d3bc2ad698425944f">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00155">155</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  156</span>{</div>
<div class="line"><span class="lineno">  157</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  158</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  159</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] - <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  160</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  161</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a585704d3f738c5eb899810fc9308a60e" name="a585704d3f738c5eb899810fc9308a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585704d3f738c5eb899810fc9308a60e">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00138">138</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  139</span>{</div>
<div class="line"><span class="lineno">  140</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  141</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  142</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">a</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] / <a class="code hl_struct" href="structps_1_1Point.html">b</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">  143</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  144</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6663b4f1e9c5ee48e2bf6e1896430580" name="a6663b4f1e9c5ee48e2bf6e1896430580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6663b4f1e9c5ee48e2bf6e1896430580">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; <a class="el" href="structps_1_1Point.html">ps::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="point_8hpp_source.html#l00171">171</a> of file <a class="el" href="point_8hpp_source.html">point.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  172</span>{</div>
<div class="line"><span class="lineno">  173</span>  <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  174</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">  175</span>    <a class="code hl_struct" href="structps_1_1Point.html">result</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] / <a class="code hl_struct" href="structps_1_1Point.html">scalar</a>;</div>
<div class="line"><span class="lineno">  176</span>  <span class="keywordflow">return</span> <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">  177</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b1e932ba8a20e05cd8c113179aa77c8" name="a5b1e932ba8a20e05cd8c113179aa77c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1e932ba8a20e05cd8c113179aa77c8">&#9670;&#160;</a></span>poisson_disk_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">ScaleFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::poisson_disk_sampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">ScaleFn</a>&#160;</td>
          <td class="paramname"><em>scale_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="poisson__disk__sampling_8hpp_source.html#l00178">178</a> of file <a class="el" href="poisson__disk__sampling_8hpp_source.html">poisson_disk_sampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  185</span>{</div>
<div class="line"><span class="lineno">  186</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">count</a> == 0)</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>  std::mt19937 gen(seed ? *seed : std::random_device{}());</div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>  T cell_size = base_min_dist / std::sqrt(<span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(N));</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>  <span class="comment">// Compute grid size per axis</span></div>
<div class="line"><span class="lineno">  194</span>  std::array&lt;size_t, N&gt; grid_size{};</div>
<div class="line"><span class="lineno">  195</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">  196</span>  {</div>
<div class="line"><span class="lineno">  197</span>    T axis_len = ranges[i].second - ranges[i].first;</div>
<div class="line"><span class="lineno">  198</span>    grid_size[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(std::ceil(axis_len / cell_size));</div>
<div class="line"><span class="lineno">  199</span>  }</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>  GridND&lt;T, N&gt; grid(grid_size, cell_size);</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>  std::vector&lt;Point&lt;T, N&gt;&gt; sample_points;</div>
<div class="line"><span class="lineno">  204</span>  sample_points.reserve(count);</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span>  std::vector&lt;Point&lt;T, N&gt;&gt; process_list;</div>
<div class="line"><span class="lineno">  207</span>  process_list.reserve(count);</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>  <span class="comment">// Generate first point randomly inside ranges</span></div>
<div class="line"><span class="lineno">  210</span>  Point&lt;T, N&gt; first_point;</div>
<div class="line"><span class="lineno">  211</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">  212</span>  {</div>
<div class="line"><span class="lineno">  213</span>    std::uniform_real_distribution&lt;T&gt; dist_axis(ranges[i].first, ranges[i].second);</div>
<div class="line"><span class="lineno">  214</span>    first_point[i] = dist_axis(gen);</div>
<div class="line"><span class="lineno">  215</span>  }</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span>  sample_points.push_back(first_point);</div>
<div class="line"><span class="lineno">  218</span>  process_list.push_back(first_point);</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>  grid[grid.point_to_grid(first_point, ranges)] = first_point;</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>  <span class="keywordflow">while</span> (!process_list.empty() &amp;&amp; sample_points.size() &lt; count)</div>
<div class="line"><span class="lineno">  223</span>  {</div>
<div class="line"><span class="lineno">  224</span>    <span class="comment">// Pop a random element from process_list</span></div>
<div class="line"><span class="lineno">  225</span>    std::uniform_int_distribution&lt;size_t&gt; dist_idx(0, process_list.size() - 1);</div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordtype">size_t</span>                                idx = dist_idx(gen);</div>
<div class="line"><span class="lineno">  227</span>    Point&lt;T, N&gt;                           point = process_list[idx];</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span>    <span class="comment">// Remove from process_list (swap-pop)</span></div>
<div class="line"><span class="lineno">  230</span>    process_list[idx] = process_list.back();</div>
<div class="line"><span class="lineno">  231</span>    process_list.pop_back();</div>
<div class="line"><span class="lineno">  232</span> </div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; new_points_attempts &amp;&amp; sample_points.size() &lt; count; ++i)</div>
<div class="line"><span class="lineno">  234</span>    {</div>
<div class="line"><span class="lineno">  235</span>      Point&lt;T, N&gt; new_point = generate_random_point_around&lt;T, N&gt;(point,</div>
<div class="line"><span class="lineno">  236</span>                                                                 base_min_dist,</div>
<div class="line"><span class="lineno">  237</span>                                                                 gen,</div>
<div class="line"><span class="lineno">  238</span>                                                                 scale_fn);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>      <span class="comment">// Check bounds</span></div>
<div class="line"><span class="lineno">  241</span>      <span class="keywordtype">bool</span> in_bounds = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  242</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">  243</span>      {</div>
<div class="line"><span class="lineno">  244</span>        <span class="keywordflow">if</span> (new_point[d] &lt; ranges[d].first || new_point[d] &gt; ranges[d].second)</div>
<div class="line"><span class="lineno">  245</span>        {</div>
<div class="line"><span class="lineno">  246</span>          in_bounds = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  247</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  248</span>        }</div>
<div class="line"><span class="lineno">  249</span>      }</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>      <span class="keywordflow">if</span> (!in_bounds)</div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>      <span class="comment">// Check neighbors with scaled distance</span></div>
<div class="line"><span class="lineno">  255</span>      <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceps.html#aedb5908eae325f054e4f3dd6b9b223af">in_neighborhood</a>(grid, new_point, base_min_dist, ranges, scale_fn))</div>
<div class="line"><span class="lineno">  256</span>      {</div>
<div class="line"><span class="lineno">  257</span>        sample_points.push_back(new_point);</div>
<div class="line"><span class="lineno">  258</span>        process_list.push_back(new_point);</div>
<div class="line"><span class="lineno">  259</span>        grid[grid.point_to_grid(new_point, ranges)] = new_point;</div>
<div class="line"><span class="lineno">  260</span>      }</div>
<div class="line"><span class="lineno">  261</span>    }</div>
<div class="line"><span class="lineno">  262</span>  }</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>  <span class="keywordflow">return</span> sample_points;</div>
<div class="line"><span class="lineno">  265</span>}</div>
<div class="ttc" id="anamespaceps_html_aedb5908eae325f054e4f3dd6b9b223af"><div class="ttname"><a href="namespaceps.html#aedb5908eae325f054e4f3dd6b9b223af">ps::in_neighborhood</a></div><div class="ttdeci">bool in_neighborhood(const GridND&lt; T, N &gt; &amp;grid, const Point&lt; T, N &gt; &amp;p, T base_min_dist, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges, ScaleFn scale_fn)</div><div class="ttdef"><b>Definition</b> <a href="poisson__disk__sampling_8hpp_source.html#l00069">poisson_disk_sampling.hpp:69</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f7ab76c5d0a395aa78b85bad488e94e" name="a6f7ab76c5d0a395aa78b85bad488e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7ab76c5d0a395aa78b85bad488e94e">&#9670;&#160;</a></span>poisson_disk_sampling_uniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::poisson_disk_sampling_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="poisson__disk__sampling_8hpp_source.html#l00269">269</a> of file <a class="el" href="poisson__disk__sampling_8hpp_source.html">poisson_disk_sampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  275</span>{</div>
<div class="line"><span class="lineno">  276</span>  <span class="keyword">auto</span> <a class="code hl_struct" href="structps_1_1Point.html">scale_fn</a> = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">ps::Point&lt;T, N&gt;</a> &amp; <span class="comment">/*p*/</span>) -&gt; <span class="keywordtype">float</span> { <span class="keywordflow">return</span> 1.f; };</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>  <span class="keywordflow">return</span> poisson_disk_sampling(count,</div>
<div class="line"><span class="lineno">  279</span>                               ranges,</div>
<div class="line"><span class="lineno">  280</span>                               base_min_dist,</div>
<div class="line"><span class="lineno">  281</span>                               scale_fn,</div>
<div class="line"><span class="lineno">  282</span>                               seed,</div>
<div class="line"><span class="lineno">  283</span>                               new_points_attempts);</div>
<div class="line"><span class="lineno">  284</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10763ef2a872aa9eddb48ea341cd6f69" name="a10763ef2a872aa9eddb48ea341cd6f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10763ef2a872aa9eddb48ea341cd6f69">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="random_8hpp_source.html#l00014">14</a> of file <a class="el" href="random_8hpp_source.html">random.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   17</span>{</div>
<div class="line"><span class="lineno">   18</span>  std::mt19937 <a class="code hl_struct" href="structps_1_1Point.html">gen</a>(<a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : <a class="code hl_struct" href="structps_1_1Point.html">std</a>::<a class="code hl_struct" href="structps_1_1Point.html">random_device</a>{}());</div>
<div class="line"><span class="lineno">   19</span> </div>
<div class="line"><span class="lineno">   20</span>  <span class="comment">// Create N distributions, one per dimension</span></div>
<div class="line"><span class="lineno">   21</span>  std::array&lt;std::uniform_real_distribution&lt;T&gt;, <a class="code hl_struct" href="structps_1_1Point.html">N</a>&gt; <a class="code hl_struct" href="structps_1_1Point.html">dists</a>;</div>
<div class="line"><span class="lineno">   22</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   23</span>  {</div>
<div class="line"><span class="lineno">   24</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;[<a class="code hl_struct" href="structps_1_1Point.html">min_val</a>, <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>] = <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">   25</span>    <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">min_val</a> &gt; <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>)</div>
<div class="line"><span class="lineno">   26</span>      <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid axis range: min &gt; max&quot;</span>);</div>
<div class="line"><span class="lineno">   27</span>    <a class="code hl_struct" href="structps_1_1Point.html">dists</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = std::uniform_real_distribution&lt;T&gt;(<a class="code hl_struct" href="structps_1_1Point.html">min_val</a>, <a class="code hl_struct" href="structps_1_1Point.html">max_val</a>);</div>
<div class="line"><span class="lineno">   28</span>  }</div>
<div class="line"><span class="lineno">   29</span> </div>
<div class="line"><span class="lineno">   30</span>  std::vector&lt;Point&lt;T, N&gt;&gt; points;</div>
<div class="line"><span class="lineno">   31</span>  points.reserve(count);</div>
<div class="line"><span class="lineno">   32</span> </div>
<div class="line"><span class="lineno">   33</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i)</div>
<div class="line"><span class="lineno">   34</span>  {</div>
<div class="line"><span class="lineno">   35</span>    Point&lt;T, N&gt; p;</div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; N; ++j)</div>
<div class="line"><span class="lineno">   37</span>      p[j] = dists[j](gen);</div>
<div class="line"><span class="lineno">   38</span>    points.push_back(p);</div>
<div class="line"><span class="lineno">   39</span>  }</div>
<div class="line"><span class="lineno">   40</span> </div>
<div class="line"><span class="lineno">   41</span>  <span class="keywordflow">return</span> points;</div>
<div class="line"><span class="lineno">   42</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b8197901114d1c4fd6cfe19efcd3862" name="a2b8197901114d1c4fd6cfe19efcd3862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8197901114d1c4fd6cfe19efcd3862">&#9670;&#160;</a></span>refit_points_to_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">void</a> ps::refit_points_to_range </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly remap a set of points to fit within the specified axis-aligned ranges. </p>
<p>This function computes the axis-aligned bounding box (AABB) of the input points and linearly rescales each point so that all dimensions lie in the given <code>target_ranges</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>Vector of input points to modify in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_ranges</td><td>Desired output min/max per dimension.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md0"></a>
Example</h3>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_struct" href="structps_1_1Point.html">generate_random_points&lt;float, 2&gt;</a>(100, { {</div>
<div class="line">{0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"><span class="comment">// Refit to a new range: [10, 20]  [50, 100]</span></div>
<div class="line">refit_points_to_range&lt;float, 2&gt;(pts, { { {10.f, 20.f}, {50.f, 100.f} } });</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If a dimension has constant value (min == max), the center of the target range is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00092">92</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   94</span>{</div>
<div class="line"><span class="lineno">   95</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">points</a>.empty())</div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>  std::array&lt;T, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">min_vals</a>, <a class="code hl_struct" href="structps_1_1Point.html">max_vals</a>;</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>  <span class="comment">// Initialize min/max</span></div>
<div class="line"><span class="lineno">  101</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">d</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">d</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">d</a>)</div>
<div class="line"><span class="lineno">  102</span>  {</div>
<div class="line"><span class="lineno">  103</span>    <a class="code hl_struct" href="structps_1_1Point.html">min_vals</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>] = <a class="code hl_struct" href="structps_1_1Point.html">points</a>[0][<a class="code hl_struct" href="structps_1_1Point.html">d</a>];</div>
<div class="line"><span class="lineno">  104</span>    <a class="code hl_struct" href="structps_1_1Point.html">max_vals</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>] = <a class="code hl_struct" href="structps_1_1Point.html">points</a>[0][<a class="code hl_struct" href="structps_1_1Point.html">d</a>];</div>
<div class="line"><span class="lineno">  105</span>  }</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span>  <span class="comment">// Compute bounding box</span></div>
<div class="line"><span class="lineno">  108</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points)</div>
<div class="line"><span class="lineno">  109</span>  {</div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">  111</span>    {</div>
<div class="line"><span class="lineno">  112</span>      min_vals[d] = std::min(min_vals[d], p[d]);</div>
<div class="line"><span class="lineno">  113</span>      max_vals[d] = std::max(max_vals[d], p[d]);</div>
<div class="line"><span class="lineno">  114</span>    }</div>
<div class="line"><span class="lineno">  115</span>  }</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>  <span class="comment">// Apply linear mapping to each point</span></div>
<div class="line"><span class="lineno">  118</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : points)</div>
<div class="line"><span class="lineno">  119</span>  {</div>
<div class="line"><span class="lineno">  120</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line"><span class="lineno">  121</span>    {</div>
<div class="line"><span class="lineno">  122</span>      <span class="keyword">const</span> T in_min = min_vals[d];</div>
<div class="line"><span class="lineno">  123</span>      <span class="keyword">const</span> T in_max = max_vals[d];</div>
<div class="line"><span class="lineno">  124</span>      <span class="keyword">const</span> T out_min = target_ranges[d].first;</div>
<div class="line"><span class="lineno">  125</span>      <span class="keyword">const</span> T out_max = target_ranges[d].second;</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>      <span class="keywordflow">if</span> (std::abs(in_max - in_min) &lt; T(1e-12))</div>
<div class="line"><span class="lineno">  128</span>      {</div>
<div class="line"><span class="lineno">  129</span>        <span class="comment">// Degenerate axis: center the target range</span></div>
<div class="line"><span class="lineno">  130</span>        p[d] = (out_min + out_max) / T(2);</div>
<div class="line"><span class="lineno">  131</span>      }</div>
<div class="line"><span class="lineno">  132</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  133</span>      {</div>
<div class="line"><span class="lineno">  134</span>        <span class="keyword">const</span> T t = (p[d] - in_min) / (in_max - in_min);</div>
<div class="line"><span class="lineno">  135</span>        p[d] = out_min + t * (out_max - out_min);</div>
<div class="line"><span class="lineno">  136</span>      }</div>
<div class="line"><span class="lineno">  137</span>    }</div>
<div class="line"><span class="lineno">  138</span>  }</div>
<div class="line"><span class="lineno">  139</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a29ab0a94bbe26a22cb87bf8f44703527" name="a29ab0a94bbe26a22cb87bf8f44703527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ab0a94bbe26a22cb87bf8f44703527">&#9670;&#160;</a></span>rejection_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N, <a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">DensityFn</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; ps::rejection_sampling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">DensityFn</a>&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structps_1_1Point.html">unsigned</a> <a class="el" href="structps_1_1Point.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="rejection__sampling_8hpp_source.html#l00013">13</a> of file <a class="el" href="rejection__sampling_8hpp_source.html">rejection_sampling.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   18</span>{</div>
<div class="line"><span class="lineno">   19</span>  std::mt19937 <a class="code hl_struct" href="structps_1_1Point.html">gen</a>(<a class="code hl_struct" href="structps_1_1Point.html">seed</a> ? *<a class="code hl_struct" href="structps_1_1Point.html">seed</a> : <a class="code hl_struct" href="structps_1_1Point.html">std</a>::<a class="code hl_struct" href="structps_1_1Point.html">random_device</a>{}());</div>
<div class="line"><span class="lineno">   20</span> </div>
<div class="line"><span class="lineno">   21</span>  std::array&lt;std::uniform_real_distribution&lt;T&gt;, <a class="code hl_struct" href="structps_1_1Point.html">N</a>&gt; <a class="code hl_struct" href="structps_1_1Point.html">coord_dists</a>;</div>
<div class="line"><span class="lineno">   22</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   23</span>    <a class="code hl_struct" href="structps_1_1Point.html">coord_dists</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = std::uniform_real_distribution&lt;T&gt;(<a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>].<a class="code hl_struct" href="structps_1_1Point.html">first</a>,</div>
<div class="line"><span class="lineno">   24</span>                                                       <a class="code hl_struct" href="structps_1_1Point.html">axis_ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>].<a class="code hl_struct" href="structps_1_1Point.html">second</a>);</div>
<div class="line"><span class="lineno">   25</span> </div>
<div class="line"><span class="lineno">   26</span>  std::uniform_real_distribution&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">accept_dist</a>(0.0, 1.0);</div>
<div class="line"><span class="lineno">   27</span> </div>
<div class="line"><span class="lineno">   28</span>  std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">result</a>;</div>
<div class="line"><span class="lineno">   29</span>  <a class="code hl_struct" href="structps_1_1Point.html">result</a>.reserve(<a class="code hl_struct" href="structps_1_1Point.html">count</a>);</div>
<div class="line"><span class="lineno">   30</span> </div>
<div class="line"><span class="lineno">   31</span>  <span class="keywordflow">while</span> (<a class="code hl_struct" href="structps_1_1Point.html">result</a>.size() &lt; <a class="code hl_struct" href="structps_1_1Point.html">count</a>)</div>
<div class="line"><span class="lineno">   32</span>  {</div>
<div class="line"><span class="lineno">   33</span>    <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">p</a>;</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   35</span>      <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>] = <a class="code hl_struct" href="structps_1_1Point.html">coord_dists</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>](<a class="code hl_struct" href="structps_1_1Point.html">gen</a>);</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">prob</a> = <a class="code hl_struct" href="structps_1_1Point.html">density_fn</a>(<a class="code hl_struct" href="structps_1_1Point.html">p</a>);</div>
<div class="line"><span class="lineno">   38</span>    <a class="code hl_struct" href="structps_1_1Point.html">T</a> <a class="code hl_struct" href="structps_1_1Point.html">threshold</a> = <a class="code hl_struct" href="structps_1_1Point.html">accept_dist</a>(<a class="code hl_struct" href="structps_1_1Point.html">gen</a>);</div>
<div class="line"><span class="lineno">   39</span> </div>
<div class="line"><span class="lineno">   40</span>    <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">prob</a> &gt;= <a class="code hl_struct" href="structps_1_1Point.html">threshold</a>)</div>
<div class="line"><span class="lineno">   41</span>      <a class="code hl_struct" href="structps_1_1Point.html">result</a>.push_back(<a class="code hl_struct" href="structps_1_1Point.html">p</a>);</div>
<div class="line"><span class="lineno">   42</span>  }</div>
<div class="line"><span class="lineno">   43</span> </div>
<div class="line"><span class="lineno">   44</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">   45</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed8a3217a801c5b5706f4bcc3306bb18" name="aed8a3217a801c5b5706f4bcc3306bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8a3217a801c5b5706f4bcc3306bb18">&#9670;&#160;</a></span>relaxation_ktree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">void</a> ps::relaxation_ktree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>k_neighbors</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">T</a>&#160;</td>
          <td class="paramname"><em>step_size</em> = <code><a class="el" href="structps_1_1Point.html">T</a>(0.1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">size_t</a>&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree. </p>
<p>This function performs iterative relaxation on a set of N-dimensional points by pushing each point away from its nearest neighbors. It uses a KD-tree for efficient neighbor lookup. The goal is to reduce clustering and obtain a more uniform or blue-noise-like distribution.</p>
<p>Each point is offset based on inverse-distance-weighted repulsion from its k-nearest neighbors, normalized and scaled by a step size. The point set is updated over a number of iterations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>The point set to relax. This vector will be modified in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k_neighbors</td><td>Number of neighbors to consider (default is 8). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>How far to move a point per iteration (default is 0.1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Number of relaxation iterations (default is 10).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The KD-tree is rebuilt on each iteration to reflect the updated positions.</dd></dl>
<h3><a class="anchor" id="autotoc_md1"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation_8hpp.html">point_sampler/relaxation.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = <a class="code hl_struct" href="structps_1_1Point.html">generate_random_points&lt;float, 2&gt;</a>(</div>
<div class="line">    1000, { { {0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply 10 iterations of relaxation</span></div>
<div class="line">relaxation_ktree&lt;float, 2&gt;(pts, 8, 0.1f, 10);</div>
<div class="ttc" id="arelaxation_8hpp_html"><div class="ttname"><a href="relaxation_8hpp.html">relaxation.hpp</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2"></a>
How it works:</h3>
<ul>
<li>For each point:<ul>
<li>Find its <code>k_neighbors</code> nearest neighbors using a KD-tree.</li>
<li>Compute offset vectors from the current point to each neighbor.</li>
<li>Weight the vectors by the inverse square distance (stronger push from closer neighbors).</li>
<li>Accumulate the offset, normalize, and scale by <code>step_size</code>.</li>
<li>Apply the movement to each point.</li>
</ul>
</li>
<li>Repeat for <code>iterations</code> steps. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="relaxation_8hpp_source.html#l00059">59</a> of file <a class="el" href="relaxation_8hpp_source.html">relaxation.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   63</span>{</div>
<div class="line"><span class="lineno">   64</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">iter</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">iter</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">iterations</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">iter</a>)</div>
<div class="line"><span class="lineno">   65</span>  {</div>
<div class="line"><span class="lineno">   66</span>    <a class="code hl_struct" href="structps_1_1Point.html">PointCloudAdaptor&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">adaptor</a>(<a class="code hl_struct" href="structps_1_1Point.html">points</a>);</div>
<div class="line"><span class="lineno">   67</span>    <a class="code hl_struct" href="structps_1_1Point.html">KDTree&lt;T, N&gt;</a>            <a class="code hl_struct" href="structps_1_1Point.html">index</a>(<a class="code hl_struct" href="structps_1_1Point.html">N</a>, <a class="code hl_struct" href="structps_1_1Point.html">adaptor</a>);</div>
<div class="line"><span class="lineno">   68</span>    <a class="code hl_struct" href="structps_1_1Point.html">index</a>.buildIndex();</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>    std::vector&lt;Point&lt;T, N&gt;&gt; <a class="code hl_struct" href="structps_1_1Point.html">new_points</a> = <a class="code hl_struct" href="structps_1_1Point.html">points</a>;</div>
<div class="line"><span class="lineno">   71</span> </div>
<div class="line"><span class="lineno">   72</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">points</a>.size(); ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   73</span>    {</div>
<div class="line"><span class="lineno">   74</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">p</a> = <a class="code hl_struct" href="structps_1_1Point.html">points</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>];</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span>      std::vector&lt;size_t&gt; <a class="code hl_struct" href="structps_1_1Point.html">ret_indexes</a>(<a class="code hl_struct" href="structps_1_1Point.html">k_neighbors</a> + 1);</div>
<div class="line"><span class="lineno">   77</span>      std::vector&lt;T&gt;      <a class="code hl_struct" href="structps_1_1Point.html">out_dists_sqr</a>(<a class="code hl_struct" href="structps_1_1Point.html">k_neighbors</a> + 1);</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>      nanoflann::KNNResultSet&lt;T&gt; <a class="code hl_struct" href="structps_1_1Point.html">result_set</a>(<a class="code hl_struct" href="structps_1_1Point.html">k_neighbors</a> + 1);</div>
<div class="line"><span class="lineno">   80</span>      <a class="code hl_struct" href="structps_1_1Point.html">result_set</a>.init(<a class="code hl_struct" href="structps_1_1Point.html">ret_indexes</a>.data(), <a class="code hl_struct" href="structps_1_1Point.html">out_dists_sqr</a>.data());</div>
<div class="line"><span class="lineno">   81</span> </div>
<div class="line"><span class="lineno">   82</span>      std::array&lt;T, N&gt; <a class="code hl_struct" href="structps_1_1Point.html">query</a>;</div>
<div class="line"><span class="lineno">   83</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">d</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">d</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">d</a>)</div>
<div class="line"><span class="lineno">   84</span>        <a class="code hl_struct" href="structps_1_1Point.html">query</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>] = <a class="code hl_struct" href="structps_1_1Point.html">p</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>];</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>      <a class="code hl_struct" href="structps_1_1Point.html">index</a>.findNeighbors(<a class="code hl_struct" href="structps_1_1Point.html">result_set</a>, <a class="code hl_struct" href="structps_1_1Point.html">query</a>.data(), nanoflann::SearchParameters());</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>      <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;T, N&gt;</a> <a class="code hl_struct" href="structps_1_1Point.html">offset</a>{};</div>
<div class="line"><span class="lineno">   89</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt; result_set.size(); ++j) <span class="comment">// skip self at j=0</span></div>
<div class="line"><span class="lineno">   90</span>      {</div>
<div class="line"><span class="lineno">   91</span>        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q = points[ret_indexes[j]];</div>
<div class="line"><span class="lineno">   92</span>        <span class="keyword">auto</span>        delta = p - q;</div>
<div class="line"><span class="lineno">   93</span>        T           dist_sq = length_squared(delta) + T(1e-6); <span class="comment">// avoid div by 0</span></div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>        offset = offset + delta / dist_sq;</div>
<div class="line"><span class="lineno">   96</span>      }</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>      new_points[i] = p + <a class="code hl_function" href="namespaceps.html#a7de6090e2c8291401816be9bc6cda914">normalized</a>(offset) * step_size;</div>
<div class="line"><span class="lineno">   99</span>    }</div>
<div class="line"><span class="lineno">  100</span> </div>
<div class="line"><span class="lineno">  101</span>    points = std::move(new_points);</div>
<div class="line"><span class="lineno">  102</span>  }</div>
<div class="line"><span class="lineno">  103</span>}</div>
<div class="ttc" id="anamespaceps_html_a7de6090e2c8291401816be9bc6cda914"><div class="ttname"><a href="namespaceps.html#a7de6090e2c8291401816be9bc6cda914">ps::normalized</a></div><div class="ttdeci">Point&lt; T, N &gt; normalized(const Point&lt; T, N &gt; &amp;a)</div><div class="ttdef"><b>Definition</b> <a href="point_8hpp_source.html#l00211">point.hpp:211</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7addf1455112b7895f8de7c475eed850" name="a7addf1455112b7895f8de7c475eed850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addf1455112b7895f8de7c475eed850">&#9670;&#160;</a></span>rescale_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">void</a> ps::rescale_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::array&lt; std::pair&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00142">142</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  144</span>{</div>
<div class="line"><span class="lineno">  145</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">pt</a> : <a class="code hl_struct" href="structps_1_1Point.html">points</a>)</div>
<div class="line"><span class="lineno">  146</span>    <a class="code hl_struct" href="structps_1_1Point.html">for</a> (<a class="code hl_struct" href="structps_1_1Point.html">size_t</a> <a class="code hl_struct" href="structps_1_1Point.html">d</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">d</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">d</a>)</div>
<div class="line"><span class="lineno">  147</span>      <a class="code hl_struct" href="structps_1_1Point.html">pt</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>] = <a class="code hl_struct" href="structps_1_1Point.html">ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>].<a class="code hl_struct" href="structps_1_1Point.html">first</a> + <a class="code hl_struct" href="structps_1_1Point.html">pt</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>] * (<a class="code hl_struct" href="structps_1_1Point.html">ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>].<a class="code hl_struct" href="structps_1_1Point.html">second</a> - <a class="code hl_struct" href="structps_1_1Point.html">ranges</a>[<a class="code hl_struct" href="structps_1_1Point.html">d</a>].<a class="code hl_struct" href="structps_1_1Point.html">first</a>);</div>
<div class="line"><span class="lineno">  148</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a802637e81218193c0e65266c8075f002" name="a802637e81218193c0e65266c8075f002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802637e81218193c0e65266c8075f002">&#9670;&#160;</a></span>save_points_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">bool</a> ps::save_points_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_header</em> = <code><a class="el" href="structps_1_1Point.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00016">16</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   19</span>{</div>
<div class="line"><span class="lineno">   20</span>  std::ofstream <a class="code hl_struct" href="structps_1_1Point.html">out</a>(<a class="code hl_struct" href="structps_1_1Point.html">filename</a>);</div>
<div class="line"><span class="lineno">   21</span>  <span class="keywordflow">if</span> (!<a class="code hl_struct" href="structps_1_1Point.html">out</a>.is_open())</div>
<div class="line"><span class="lineno">   22</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   23</span> </div>
<div class="line"><span class="lineno">   24</span>  <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">write_header</a>)</div>
<div class="line"><span class="lineno">   25</span>  {</div>
<div class="line"><span class="lineno">   26</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   27</span>    {</div>
<div class="line"><span class="lineno">   28</span>      <a class="code hl_struct" href="structps_1_1Point.html">out</a> &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; <a class="code hl_struct" href="structps_1_1Point.html">i</a>;</div>
<div class="line"><span class="lineno">   29</span>      <span class="keywordflow">if</span> (<a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a> - 1)</div>
<div class="line"><span class="lineno">   30</span>        <a class="code hl_struct" href="structps_1_1Point.html">out</a> &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><span class="lineno">   31</span>    }</div>
<div class="line"><span class="lineno">   32</span>    out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   33</span>  }</div>
<div class="line"><span class="lineno">   34</span> </div>
<div class="line"><span class="lineno">   35</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;point : points)</div>
<div class="line"><span class="lineno">   36</span>  {</div>
<div class="line"><span class="lineno">   37</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)</div>
<div class="line"><span class="lineno">   38</span>    {</div>
<div class="line"><span class="lineno">   39</span>      out &lt;&lt; point[i];</div>
<div class="line"><span class="lineno">   40</span>      <span class="keywordflow">if</span> (i &lt; N - 1)</div>
<div class="line"><span class="lineno">   41</span>        out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><span class="lineno">   42</span>    }</div>
<div class="line"><span class="lineno">   43</span>    out &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   44</span>  }</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   47</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6737277b9cc05d5f2ab248f17baea3b" name="af6737277b9cc05d5f2ab248f17baea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6737277b9cc05d5f2ab248f17baea3b">&#9670;&#160;</a></span>split_by_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structps_1_1Point.html">typename</a> <a class="el" href="structps_1_1Point.html">T</a> , <a class="el" href="structps_1_1Point.html">size_t</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; <a class="el" href="structps_1_1Point.html">T</a> &gt;, <a class="el" href="structps_1_1Point.html">N</a> &gt; ps::split_by_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structps_1_1Point.html">const</a> std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; <a class="el" href="structps_1_1Point.html">T</a>, <a class="el" href="structps_1_1Point.html">N</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8hpp_source.html#l00055">55</a> of file <a class="el" href="utils_8hpp_source.html">utils.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   56</span>{</div>
<div class="line"><span class="lineno">   57</span>  std::array&lt;std::vector&lt;T&gt;, <a class="code hl_struct" href="structps_1_1Point.html">N</a>&gt; <a class="code hl_struct" href="structps_1_1Point.html">components</a>;</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code hl_struct" href="structps_1_1Point.html">point</a> : <a class="code hl_struct" href="structps_1_1Point.html">points</a>)</div>
<div class="line"><span class="lineno">   60</span>    <a class="code hl_struct" href="structps_1_1Point.html">for</a> (<a class="code hl_struct" href="structps_1_1Point.html">size_t</a> <a class="code hl_struct" href="structps_1_1Point.html">i</a> = 0; <a class="code hl_struct" href="structps_1_1Point.html">i</a> &lt; <a class="code hl_struct" href="structps_1_1Point.html">N</a>; ++<a class="code hl_struct" href="structps_1_1Point.html">i</a>)</div>
<div class="line"><span class="lineno">   61</span>    {</div>
<div class="line"><span class="lineno">   62</span>      <a class="code hl_struct" href="structps_1_1Point.html">components</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>].push_back(<a class="code hl_struct" href="structps_1_1Point.html">point</a>[<a class="code hl_struct" href="structps_1_1Point.html">i</a>]);</div>
<div class="line"><span class="lineno">   63</span>    }</div>
<div class="line"><span class="lineno">   64</span> </div>
<div class="line"><span class="lineno">   65</span>  <span class="keywordflow">return</span> components;</div>
<div class="line"><span class="lineno">   66</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
