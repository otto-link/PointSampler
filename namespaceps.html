<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ps Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ps Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1GridND.html">GridND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size N-dimensional point/vector class.  <a href="structps_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a" id="r_ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">KDTree</a> = nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt; T, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; T, N &gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt; T, N &gt;, N &gt;</td></tr>
<tr class="separator:ac9ecfd54020ea95c133d1fc99cf4f75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94" id="r_ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad1f4a1110a40bf1c6a687182db6b4b94">distance_rejection_filter</a> (const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, T min_dist)</td></tr>
<tr class="separator:ad1f4a1110a40bf1c6a687182db6b4b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632" id="r_af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename ScaleFn &gt; </td></tr>
<tr class="memitem:af23d114903fd5cb3ccb19d3e64183632"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">distance_rejection_filter_warped</a> (const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, T base_min_dist, ScaleFn scale_fn)</td></tr>
<tr class="memdesc:af23d114903fd5cb3ccb19d3e64183632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points based on spatially-varying minimal distance constraints.  <br /></td></tr>
<tr class="separator:af23d114903fd5cb3ccb19d3e64183632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a" id="r_a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a913ab9d687ee42d04488e5eb0373e23a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">gaussian_clusters</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; cluster_centers, size_t points_per_cluster, T spread, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a913ab9d687ee42d04488e5eb0373e23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates clustered points around provided cluster centers using a Gaussian distribution.  <br /></td></tr>
<tr class="separator:a913ab9d687ee42d04488e5eb0373e23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d" id="r_a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a0efaff8017d5a171ffdf0ed0201bd65d">gaussian_clusters</a> (size_t cluster_count, size_t points_per_cluster, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, T spread, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates clustered points around random centers uniformly sampled in a bounding box.  <br /></td></tr>
<tr class="separator:a0efaff8017d5a171ffdf0ed0201bd65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b" id="r_aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa8c3b3b3367276f9a194938599d2463b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa8c3b3b3367276f9a194938599d2463b">halton_sequence</a> (size_t count, size_t shift)</td></tr>
<tr class="separator:aa8c3b3b3367276f9a194938599d2463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524" id="r_a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a81b18395a05f0bb4d483406e79aa9524"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a81b18395a05f0bb4d483406e79aa9524">halton</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a81b18395a05f0bb4d483406e79aa9524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of quasi-random points using the Halton sequence in N dimensions.  <br /></td></tr>
<tr class="separator:a81b18395a05f0bb4d483406e79aa9524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3" id="r_ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae21a8c51533330ead4ebe76eed3e72b3">hammersley_sequence</a> (size_t count, size_t shift)</td></tr>
<tr class="separator:ae21a8c51533330ead4ebe76eed3e72b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6" id="r_aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aad0cc7bc81f7cac9f0be26177b9986a6">hammersley</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of quasi-random points using the Hammersley sequence in N dimensions.  <br /></td></tr>
<tr class="separator:aad0cc7bc81f7cac9f0be26177b9986a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b" id="r_a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename DensityFn &gt; </td></tr>
<tr class="memitem:a932640b18d76a7e336fc760e9cf5511b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a932640b18d76a7e336fc760e9cf5511b">importance_resampling</a> (size_t count, size_t oversampling_ratio, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, DensityFn density_fn, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a932640b18d76a7e336fc760e9cf5511b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point set via importance resampling from a quasi-random oversampled grid.  <br /></td></tr>
<tr class="separator:a932640b18d76a7e336fc760e9cf5511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8" id="r_ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ad8525c124fef24618bf574b9b7b1ece8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ad8525c124fef24618bf574b9b7b1ece8">jittered_grid</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, const std::array&lt; T, N &gt; &amp;jitter_amount, const std::array&lt; T, N &gt; &amp;stagger_ratio, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:ad8525c124fef24618bf574b9b7b1ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point set on a jittered and optionally staggered grid.  <br /></td></tr>
<tr class="separator:ad8525c124fef24618bf574b9b7b1ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714" id="r_ae90df8db8e751ff4b61298114f092714"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ae90df8db8e751ff4b61298114f092714"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ae90df8db8e751ff4b61298114f092714">jittered_grid</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:ae90df8db8e751ff4b61298114f092714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a jittered grid of points with full jitter and no stagger.  <br /></td></tr>
<tr class="separator:ae90df8db8e751ff4b61298114f092714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0" id="r_af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af9ee1cf5d335276b7fabe6f1daddf1b0">operator+</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:af9ee1cf5d335276b7fabe6f1daddf1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1" id="r_aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aa369956286bc3f09dfdc146a5b2a49f1">operator-</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:aa369956286bc3f09dfdc146a5b2a49f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b" id="r_a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6fd3a6df3727a04f9baba3b8b87a903b">operator*</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a6fd3a6df3727a04f9baba3b8b87a903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e" id="r_a585704d3f738c5eb899810fc9308a60e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a585704d3f738c5eb899810fc9308a60e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a585704d3f738c5eb899810fc9308a60e">operator/</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a585704d3f738c5eb899810fc9308a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f" id="r_a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a366ef094d65da865384b6fb77aac5d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a366ef094d65da865384b6fb77aac5d5f">operator+</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T scalar)</td></tr>
<tr class="separator:a366ef094d65da865384b6fb77aac5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f" id="r_a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79196b5b8a95ad9d3bc2ad698425944f">operator-</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T scalar)</td></tr>
<tr class="separator:a79196b5b8a95ad9d3bc2ad698425944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b" id="r_acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:acd4dc781f43ba8a50daa139682846d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#acd4dc781f43ba8a50daa139682846d4b">operator*</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T scalar)</td></tr>
<tr class="separator:acd4dc781f43ba8a50daa139682846d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580" id="r_a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6663b4f1e9c5ee48e2bf6e1896430580">operator/</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T scalar)</td></tr>
<tr class="separator:a6663b4f1e9c5ee48e2bf6e1896430580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4" id="r_abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#abfd6fe71db1c4df607bfdace9dffb5b4">operator*</a> (T scalar, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:abfd6fe71db1c4df607bfdace9dffb5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804" id="r_afe774cb61bde6358f8a7024c42db9804"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:afe774cb61bde6358f8a7024c42db9804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#afe774cb61bde6358f8a7024c42db9804">operator+</a> (T scalar, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:afe774cb61bde6358f8a7024c42db9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b" id="r_ace7642868199df621df9139e5179767b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ace7642868199df621df9139e5179767b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:ace7642868199df621df9139e5179767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c" id="r_a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a7c3e161560ad3000aa4e2218291b169c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a7c3e161560ad3000aa4e2218291b169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746" id="r_a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a38d89dd8b52a63eabb39ef5e425d5746">length</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a38d89dd8b52a63eabb39ef5e425d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914" id="r_a7de6090e2c8291401816be9bc6cda914"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a7de6090e2c8291401816be9bc6cda914"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7de6090e2c8291401816be9bc6cda914">normalized</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a7de6090e2c8291401816be9bc6cda914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808" id="r_aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aecf2b150ec16bf286e6a7b462c4d5808">distance_squared</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:aecf2b150ec16bf286e6a7b462c4d5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11" id="r_ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#ac0b74f22d427d199ab0df8f6942d3b11">distance</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:ac0b74f22d427d199ab0df8f6942d3b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa" id="r_a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a79914e9fc2dd02bacd38e9bd32e21baa">lerp</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;b, T t)</td></tr>
<tr class="separator:a79914e9fc2dd02bacd38e9bd32e21baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28" id="r_adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:adb0bd4806c7e79eddef0e1263740ae28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#adb0bd4806c7e79eddef0e1263740ae28">clamp</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T min_val, T max_val)</td></tr>
<tr class="separator:adb0bd4806c7e79eddef0e1263740ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af" id="r_aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename ScaleFn &gt; </td></tr>
<tr class="memitem:aedb5908eae325f054e4f3dd6b9b223af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aedb5908eae325f054e4f3dd6b9b223af">in_neighborhood</a> (const <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; T, N &gt; &amp;grid, const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;p, T base_min_dist, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges, ScaleFn scale_fn)</td></tr>
<tr class="separator:aedb5908eae325f054e4f3dd6b9b223af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8" id="r_a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a898bca65491a14a41bfdd50fdc6230b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a898bca65491a14a41bfdd50fdc6230b8">generate_random_point_around</a> (const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;center, T base_min_dist, std::mt19937 &amp;gen, std::function&lt; T(const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;)&gt; scale_fn)</td></tr>
<tr class="separator:a898bca65491a14a41bfdd50fdc6230b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8" id="r_a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename ScaleFn &gt; </td></tr>
<tr class="memitem:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5b1e932ba8a20e05cd8c113179aa77c8">poisson_disk_sampling</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges, T base_min_dist, ScaleFn scale_fn, std::optional&lt; unsigned int &gt; seed=std::nullopt, size_t new_points_attempts=30)</td></tr>
<tr class="memdesc:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of Poisson disk samples in N-dimensional space, possibly with a warped metric.  <br /></td></tr>
<tr class="separator:a5b1e932ba8a20e05cd8c113179aa77c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e" id="r_a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a6f7ab76c5d0a395aa78b85bad488e94e">poisson_disk_sampling_uniform</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges, T base_min_dist, std::optional&lt; unsigned int &gt; seed=std::nullopt, size_t new_points_attempts=30)</td></tr>
<tr class="memdesc:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate uniformly distributed Poisson disk samples in N-dimensional space.  <br /></td></tr>
<tr class="separator:a6f7ab76c5d0a395aa78b85bad488e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69" id="r_a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a10763ef2a872aa9eddb48ea341cd6f69">random</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a10763ef2a872aa9eddb48ea341cd6f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a specified number of uniformly distributed random points in N-dimensional space.  <br /></td></tr>
<tr class="separator:a10763ef2a872aa9eddb48ea341cd6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df" id="r_a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a9c8c5679d987d3023b9d3beffd81e6df">filter_points_in_range</a> (const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges)</td></tr>
<tr class="memdesc:a9c8c5679d987d3023b9d3beffd81e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points that lie within the specified axis-aligned bounding box.  <br /></td></tr>
<tr class="separator:a9c8c5679d987d3023b9d3beffd81e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a" id="r_a5350b843397a5bf2a748115108ffa21a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename Func &gt; </td></tr>
<tr class="memitem:a5350b843397a5bf2a748115108ffa21a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a5350b843397a5bf2a748115108ffa21a">filter_points_function</a> (const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, Func fn)</td></tr>
<tr class="memdesc:a5350b843397a5bf2a748115108ffa21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters points using a user-provided function.  <br /></td></tr>
<tr class="separator:a5350b843397a5bf2a748115108ffa21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862" id="r_a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a2b8197901114d1c4fd6cfe19efcd3862">refit_points_to_range</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;target_ranges)</td></tr>
<tr class="memdesc:a2b8197901114d1c4fd6cfe19efcd3862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly remap a set of points to fit within the specified axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a2b8197901114d1c4fd6cfe19efcd3862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850" id="r_a7addf1455112b7895f8de7c475eed850"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a7addf1455112b7895f8de7c475eed850"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a7addf1455112b7895f8de7c475eed850">rescale_points</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;ranges)</td></tr>
<tr class="memdesc:a7addf1455112b7895f8de7c475eed850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales normalized points (in [0, 1]) to specified axis-aligned ranges.  <br /></td></tr>
<tr class="separator:a7addf1455112b7895f8de7c475eed850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527" id="r_a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename DensityFn &gt; </td></tr>
<tr class="memitem:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a29ab0a94bbe26a22cb87bf8f44703527">rejection_sampling</a> (size_t count, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, DensityFn density_fn, std::optional&lt; unsigned int &gt; seed=std::nullopt)</td></tr>
<tr class="memdesc:a29ab0a94bbe26a22cb87bf8f44703527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random points using rejection sampling based on a user-defined density function.  <br /></td></tr>
<tr class="separator:a29ab0a94bbe26a22cb87bf8f44703527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18" id="r_aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#aed8a3217a801c5b5706f4bcc3306bb18">relaxation_ktree</a> (std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, size_t k_neighbors=8, T step_size=T(0.1), size_t iterations=10)</td></tr>
<tr class="memdesc:aed8a3217a801c5b5706f4bcc3306bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree.  <br /></td></tr>
<tr class="separator:aed8a3217a801c5b5706f4bcc3306bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002" id="r_a802637e81218193c0e65266c8075f002"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a802637e81218193c0e65266c8075f002"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#a802637e81218193c0e65266c8075f002">save_points_to_csv</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points, bool write_header=true)</td></tr>
<tr class="memdesc:a802637e81218193c0e65266c8075f002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a set of N-dimensional points to a CSV file.  <br /></td></tr>
<tr class="separator:a802637e81218193c0e65266c8075f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b" id="r_af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af6737277b9cc05d5f2ab248f17baea3b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::vector&lt; T &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceps.html#af6737277b9cc05d5f2ab248f17baea3b">split_by_dimension</a> (const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;points)</td></tr>
<tr class="memdesc:af6737277b9cc05d5f2ab248f17baea3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a list of N-dimensional points into N separate coordinate vectors.  <br /></td></tr>
<tr class="separator:af6737277b9cc05d5f2ab248f17baea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9ecfd54020ea95c133d1fc99cf4f75a" name="ac9ecfd54020ea95c133d1fc99cf4f75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ecfd54020ea95c133d1fc99cf4f75a">&#9670;&#160;</a></span>KDTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceps.html#ac9ecfd54020ea95c133d1fc99cf4f75a">ps::KDTree</a> = typedef nanoflann::KDTreeSingleIndexAdaptor&lt; nanoflann::L2_Simple_Adaptor&lt;T, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;T, N&gt; &gt;, <a class="el" href="structps_1_1PointCloudAdaptor.html">PointCloudAdaptor</a>&lt;T, N&gt;, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adb0bd4806c7e79eddef0e1263740ae28" name="adb0bd4806c7e79eddef0e1263740ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bd4806c7e79eddef0e1263740ae28">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0b74f22d427d199ab0df8f6942d3b11" name="ac0b74f22d427d199ab0df8f6942d3b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b74f22d427d199ab0df8f6942d3b11">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ps::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f4a1110a40bf1c6a687182db6b4b94" name="ad1f4a1110a40bf1c6a687182db6b4b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4a1110a40bf1c6a687182db6b4b94">&#9670;&#160;</a></span>distance_rejection_filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::distance_rejection_filter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af23d114903fd5cb3ccb19d3e64183632" name="af23d114903fd5cb3ccb19d3e64183632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d114903fd5cb3ccb19d3e64183632">&#9670;&#160;</a></span>distance_rejection_filter_warped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename ScaleFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::distance_rejection_filter_warped </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScaleFn&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points based on spatially-varying minimal distance constraints. </p>
<p>A scale function is used to modulate the minimum allowed distance for each point. The base distance <code>base_min_dist</code> is scaled by the value returned by <code>scale_fn(p)</code>, allowing for adaptive sampling densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
    <tr><td class="paramname">ScaleFn</td><td>Callable returning a scalar scale factor for a given point</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of candidate points </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Base minimum allowed distance </td></tr>
    <tr><td class="paramname">scale_fn</td><td>Function providing a local scale factor per point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A filtered set of points with variable spacing</dd></dl>
<h3><a class="anchor" id="autotoc_md0"></a>
Example</h3>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> scale_fn = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a>&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> 0.5f + 0.5f * std::sin(p[0] * 3.1415f); <span class="comment">// Varies between 0.5 and</span></div>
<div class="line">1</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = ps::random&lt;float, 2&gt;(1000, {{0,1},{0,1}});</div>
<div class="line"><span class="keyword">auto</span> filtered = <a class="code hl_function" href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">ps::distance_rejection_filter_warped</a>(pts, 0.05f, scale_fn);</div>
<div class="ttc" id="anamespaceps_html_af23d114903fd5cb3ccb19d3e64183632"><div class="ttname"><a href="namespaceps.html#af23d114903fd5cb3ccb19d3e64183632">ps::distance_rejection_filter_warped</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; distance_rejection_filter_warped(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, T base_min_dist, ScaleFn scale_fn)</div><div class="ttdoc">Filters points based on spatially-varying minimal distance constraints.</div><div class="ttdef"><b>Definition</b> distance_rejection_filter.hpp:95</div></div>
<div class="ttc" id="astructps_1_1Point_html"><div class="ttname"><a href="structps_1_1Point.html">ps::Point</a></div><div class="ttdoc">A fixed-size N-dimensional point/vector class.</div><div class="ttdef"><b>Definition</b> point.hpp:37</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aecf2b150ec16bf286e6a7b462c4d5808" name="aecf2b150ec16bf286e6a7b462c4d5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf2b150ec16bf286e6a7b462c4d5808">&#9670;&#160;</a></span>distance_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ps::distance_squared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7642868199df621df9139e5179767b" name="ace7642868199df621df9139e5179767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7642868199df621df9139e5179767b">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ps::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5350b843397a5bf2a748115108ffa21a" name="a5350b843397a5bf2a748115108ffa21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5350b843397a5bf2a748115108ffa21a">&#9670;&#160;</a></span>filter_points_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::filter_points_function </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points using a user-provided function. </p>
<p>Keeps only the points for which the provided function <code>fn(p)</code> does not return zero. This can be used to apply custom masks, implicit surface functions, etc.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates. </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">Func</td><td>Callable that takes a Point&lt;T, N&gt; and returns a value convertible to T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of input points. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function that returns a non-zero value if the point should be kept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of filtered points.</dd></dl>
<div class="fragment"><div class="line"> std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.f, 0.f}, {1.f, 1.f}, {2.f, 2.f}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> filtered = ps::filter_points_function&lt;float, 2&gt;(pts, [](<span class="keyword">const</span></div>
<div class="line">Point&lt;float, 2&gt; &amp;p) { <span class="keywordflow">return</span> (p[0] + p[1] &lt; 2.5f) ? 1.f : 0.f; });</div>
<div class="line"><span class="comment">// Keeps only { {0.f, 0.f}, {1.f, 1.f} }</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9c8c5679d987d3023b9d3beffd81e6df" name="a9c8c5679d987d3023b9d3beffd81e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8c5679d987d3023b9d3beffd81e6df">&#9670;&#160;</a></span>filter_points_in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::filter_points_in_range </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters points that lie within the specified axis-aligned bounding box. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of input points to filter. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box ranges for each dimension (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing only the points that lie within all specified axis ranges.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentif</td><td>axis_ranges are ill-formed (e.g., min &gt; max).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"> std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.5f, 0.5f}, {2.f, 3.f}, {-1.f,</div>
<div class="line">0.f} };</div>
<div class="line"><span class="keyword">auto</span> filtered = ps::filter_points_in_range&lt;float, 2&gt;(pts, { {{0.f, 1.f},</div>
<div class="line">{0.f, 1.f}} });</div>
<div class="line"><span class="comment">// filtered now contains only { {0.5f, 0.5f} }</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0efaff8017d5a171ffdf0ed0201bd65d" name="a0efaff8017d5a171ffdf0ed0201bd65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efaff8017d5a171ffdf0ed0201bd65d">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cluster_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates clustered points around random centers uniformly sampled in a bounding box. </p>
<p>Cluster centers are randomly sampled within the provided <code>axis_ranges</code>, and each cluster then has <code>points_per_cluster</code> points sampled from a Gaussian distribution centered at the cluster's location, with a specified standard deviation <code>spread</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_count</td><td>Number of cluster centers to generate </td></tr>
    <tr><td class="paramname">points_per_cluster</td><td>Number of points per cluster </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box ranges for each dimension </td></tr>
    <tr><td class="paramname">spread</td><td>Standard deviation of the Gaussian spread </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of clustered points</dd></dl>
<h3><a class="anchor" id="autotoc_md2"></a>
Example</h3>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> clustered = ps::gaussian_clusters&lt;float, 2&gt;(</div>
<div class="line">    5, 100,</div>
<div class="line">    {{{0,1}, {0,1}}}, 0.03f</div>
<div class="line">);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a913ab9d687ee42d04488e5eb0373e23a" name="a913ab9d687ee42d04488e5eb0373e23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913ab9d687ee42d04488e5eb0373e23a">&#9670;&#160;</a></span>gaussian_clusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::gaussian_clusters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt;&#160;</td>
          <td class="paramname"><em>cluster_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>points_per_cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates clustered points around provided cluster centers using a Gaussian distribution. </p>
<p>For each cluster center, this function generates <code>points_per_cluster</code> points where each coordinate is sampled from a normal distribution centered at the coordinate of the cluster center with standard deviation <code>spread</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_centers</td><td>A vector of cluster center points </td></tr>
    <tr><td class="paramname">points_per_cluster</td><td>Number of points to generate per cluster </td></tr>
    <tr><td class="paramname">spread</td><td>Standard deviation of the Gaussian spread </td></tr>
    <tr><td class="paramname">seed</td><td>Optional random seed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of clustered points</dd></dl>
<h3><a class="anchor" id="autotoc_md1"></a>
Example</h3>
<div class="fragment"><div class="line"> std::vector&lt;Point&lt;float, 2&gt;&gt; centers = {</div>
<div class="line">    {0.2f, 0.2f},</div>
<div class="line">    {0.8f, 0.8f}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> clustered = <a class="code hl_function" href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">ps::gaussian_clusters</a>(centers, 100, 0.05f);</div>
<div class="ttc" id="anamespaceps_html_a913ab9d687ee42d04488e5eb0373e23a"><div class="ttname"><a href="namespaceps.html#a913ab9d687ee42d04488e5eb0373e23a">ps::gaussian_clusters</a></div><div class="ttdeci">std::vector&lt; Point&lt; T, N &gt; &gt; gaussian_clusters(std::vector&lt; Point&lt; T, N &gt; &gt; cluster_centers, size_t points_per_cluster, T spread, std::optional&lt; unsigned int &gt; seed=std::nullopt)</div><div class="ttdoc">Generates clustered points around provided cluster centers using a Gaussian distribution.</div><div class="ttdef"><b>Definition</b> gaussian_clusters.hpp:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a898bca65491a14a41bfdd50fdc6230b8" name="a898bca65491a14a41bfdd50fdc6230b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898bca65491a14a41bfdd50fdc6230b8">&#9670;&#160;</a></span>generate_random_point_around()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::generate_random_point_around </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T(const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81b18395a05f0bb4d483406e79aa9524" name="a81b18395a05f0bb4d483406e79aa9524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b18395a05f0bb4d483406e79aa9524">&#9670;&#160;</a></span>halton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::halton </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of quasi-random points using the Halton sequence in N dimensions. </p>
<p>This function generates <code>count</code> points in the unit hypercube using the Halton sequence, then rescales them to fit within the specified axis-aligned bounding box. An optional <code>seed</code> is used as a starting index offset (i.e., a shift) in the sequence to decorrelate multiple calls.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box for each dimension, as min/max pairs </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed that offsets the sequence start index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The generated Halton points rescaled to the bounding box</dd></dl>
<h3><a class="anchor" id="autotoc_md3"></a>
Example</h3>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> points = ps::halton&lt;float, 2&gt;(</div>
<div class="line">    1000,</div>
<div class="line">    {{{0, 1}, {0, 1}}}, 42</div>
<div class="line">);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa8c3b3b3367276f9a194938599d2463b" name="aa8c3b3b3367276f9a194938599d2463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c3b3b3367276f9a194938599d2463b">&#9670;&#160;</a></span>halton_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::halton_sequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad0cc7bc81f7cac9f0be26177b9986a6" name="aad0cc7bc81f7cac9f0be26177b9986a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cc7bc81f7cac9f0be26177b9986a6">&#9670;&#160;</a></span>hammersley()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::hammersley </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of quasi-random points using the Hammersley sequence in N dimensions. </p>
<p>This function generates <code>count</code> points in the unit hypercube using the Hammersley sequence, then rescales them to fit within the specified axis-aligned bounding box. An optional <code>seed</code> can be used as a starting index offset (i.e., a shift) to decorrelate multiple calls or introduce variation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box for each dimension, as min/max pairs </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed that offsets the sequence start index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The generated Hammersley points rescaled to the bounding box</dd></dl>
<h3><a class="anchor" id="autotoc_md4"></a>
Example</h3>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> points = ps::hammersley&lt;float, 3&gt;(</div>
<div class="line">    512,</div>
<div class="line">    {{{-1, 1}, {-1, 1}, {0, 1}}}, 7</div>
<div class="line">);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae21a8c51533330ead4ebe76eed3e72b3" name="ae21a8c51533330ead4ebe76eed3e72b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21a8c51533330ead4ebe76eed3e72b3">&#9670;&#160;</a></span>hammersley_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::hammersley_sequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a932640b18d76a7e336fc760e9cf5511b" name="a932640b18d76a7e336fc760e9cf5511b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932640b18d76a7e336fc760e9cf5511b">&#9670;&#160;</a></span>importance_resampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename DensityFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::importance_resampling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>oversampling_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DensityFn&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a point set via importance resampling from a quasi-random oversampled grid. </p>
<p>This function uses a Halton sequence to create an oversampled set of candidate points in the domain. Each point is assigned a weight based on the provided density function. A discrete distribution is then used to resample <code>count</code> points according to these weights.</p>
<p>The higher the <code>oversampling_ratio</code>, the better the approximation to the target density, at the cost of performance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
    <tr><td class="paramname">DensityFn</td><td>A callable with signature <code>T(const <a class="el" href="structps_1_1Point.html" title="A fixed-size N-dimensional point/vector class.">Point</a>&lt;T, N&gt;&amp;)</code> returning a non-negative density value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to return after resampling </td></tr>
    <tr><td class="paramname">oversampling_ratio</td><td>Number of candidate points to generate as a multiple of <code>count</code> </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the domain of the points </td></tr>
    <tr><td class="paramname">density_fn</td><td>Function mapping a point to a (non-negative) density value </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed to control the random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; The resulting resampled point set</dd></dl>
<h3><a class="anchor" id="autotoc_md5"></a>
Example</h3>
<div class="fragment"><div class="line"> <span class="keyword">auto</span> density = [](<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a> &amp;p) {</div>
<div class="line">    <span class="keywordflow">return</span> std::exp(-10.0f * (p[0]*p[0] + p[1]*p[1]));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> points = ps::importance_resampling&lt;float, 2&gt;(</div>
<div class="line">    500, 5,</div>
<div class="line">    {{{-1, 1}, {-1, 1}}}, density, 42</div>
<div class="line">);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aedb5908eae325f054e4f3dd6b9b223af" name="aedb5908eae325f054e4f3dd6b9b223af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb5908eae325f054e4f3dd6b9b223af">&#9670;&#160;</a></span>in_neighborhood()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename ScaleFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ps::in_neighborhood </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1GridND.html">GridND</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScaleFn&#160;</td>
          <td class="paramname"><em>scale_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8525c124fef24618bf574b9b7b1ece8" name="ad8525c124fef24618bf574b9b7b1ece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8525c124fef24618bf574b9b7b1ece8">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>jitter_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>stagger_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a point set on a jittered and optionally staggered grid. </p>
<p>This function divides the domain into a grid and places one point in each selected cell. Each point is jittered within its cell, and staggered offsets may be applied depending on the index of higher-dimensional axes. The result is a semi-regular sampling pattern with randomness.</p>
<p>Jittering prevents aliasing, and staggering introduces a controlled shift between alternating cells to improve uniformity and avoid alignment artifacts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of output points (best effort, may be capped by total available cells) </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the sampling domain </td></tr>
    <tr><td class="paramname">jitter_amount</td><td>Per-dimension jitter factor ∈ [0, 1]. A value of 1.0 means full jitter in the cell. </td></tr>
    <tr><td class="paramname">stagger_ratio</td><td>Per-dimension stagger ratio, indicating how much to offset points based on higher dimension parity </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for deterministic jittering and shuffling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; Sampled points</dd></dl>
<h3><a class="anchor" id="autotoc_md6"></a>
Example</h3>
<div class="fragment"><div class="line"> std::array&lt;std::pair&lt;float, float&gt;, 2&gt; bounds = {{{0.0f, 1.0f}, {0.0f,</div>
<div class="line">1.0f}}};</div>
<div class="line">std::array&lt;float, 2&gt; jitter = {0.8f, 0.8f};</div>
<div class="line">std::array&lt;float, 2&gt; stagger = {0.2f, 0.0f};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> samples = ps::jittered_grid&lt;float, 2&gt;(256, bounds, jitter, stagger, 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae90df8db8e751ff4b61298114f092714" name="ae90df8db8e751ff4b61298114f092714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90df8db8e751ff4b61298114f092714">&#9670;&#160;</a></span>jittered_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::jittered_grid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a jittered grid of points with full jitter and no stagger. </p>
<p>This overload defaults to jittering each dimension fully within its cell and applies no staggering. It is equivalent to calling the full version with <code>jitter_amount</code> filled with 1.0 and <code>stagger_ratio</code> filled with 0.0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double) </td></tr>
    <tr><td class="paramname">N</td><td>Dimensionality of the space </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of points to generate </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Axis-aligned bounding box defining the sampling domain </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for deterministic jittering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; Jittered point samples</dd></dl>
<h3><a class="anchor" id="autotoc_md7"></a>
Example</h3>
<div class="fragment"><div class="line"> std::array&lt;std::pair&lt;double, double&gt;, 3&gt; bounds = {{{0, 1}, {0, 1}, {0,</div>
<div class="line">1}}};</div>
<div class="line"><span class="keyword">auto</span> points = ps::jittered_grid&lt;double, 3&gt;(1000, bounds, 1234);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a38d89dd8b52a63eabb39ef5e425d5746" name="a38d89dd8b52a63eabb39ef5e425d5746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d89dd8b52a63eabb39ef5e425d5746">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ps::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3e161560ad3000aa4e2218291b169c" name="a7c3e161560ad3000aa4e2218291b169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3e161560ad3000aa4e2218291b169c">&#9670;&#160;</a></span>length_squared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ps::length_squared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79914e9fc2dd02bacd38e9bd32e21baa" name="a79914e9fc2dd02bacd38e9bd32e21baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79914e9fc2dd02bacd38e9bd32e21baa">&#9670;&#160;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7de6090e2c8291401816be9bc6cda914" name="a7de6090e2c8291401816be9bc6cda914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de6090e2c8291401816be9bc6cda914">&#9670;&#160;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::normalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fd3a6df3727a04f9baba3b8b87a903b" name="a6fd3a6df3727a04f9baba3b8b87a903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd3a6df3727a04f9baba3b8b87a903b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd4dc781f43ba8a50daa139682846d4b" name="acd4dc781f43ba8a50daa139682846d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4dc781f43ba8a50daa139682846d4b">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd6fe71db1c4df607bfdace9dffb5b4" name="abfd6fe71db1c4df607bfdace9dffb5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6fe71db1c4df607bfdace9dffb5b4">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9ee1cf5d335276b7fabe6f1daddf1b0" name="af9ee1cf5d335276b7fabe6f1daddf1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ee1cf5d335276b7fabe6f1daddf1b0">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a366ef094d65da865384b6fb77aac5d5f" name="a366ef094d65da865384b6fb77aac5d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ef094d65da865384b6fb77aac5d5f">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe774cb61bde6358f8a7024c42db9804" name="afe774cb61bde6358f8a7024c42db9804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe774cb61bde6358f8a7024c42db9804">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa369956286bc3f09dfdc146a5b2a49f1" name="aa369956286bc3f09dfdc146a5b2a49f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa369956286bc3f09dfdc146a5b2a49f1">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79196b5b8a95ad9d3bc2ad698425944f" name="a79196b5b8a95ad9d3bc2ad698425944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79196b5b8a95ad9d3bc2ad698425944f">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a585704d3f738c5eb899810fc9308a60e" name="a585704d3f738c5eb899810fc9308a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585704d3f738c5eb899810fc9308a60e">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6663b4f1e9c5ee48e2bf6e1896430580" name="a6663b4f1e9c5ee48e2bf6e1896430580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6663b4f1e9c5ee48e2bf6e1896430580">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; ps::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b1e932ba8a20e05cd8c113179aa77c8" name="a5b1e932ba8a20e05cd8c113179aa77c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1e932ba8a20e05cd8c113179aa77c8">&#9670;&#160;</a></span>poisson_disk_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename ScaleFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::poisson_disk_sampling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScaleFn&#160;</td>
          <td class="paramname"><em>scale_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a set of Poisson disk samples in N-dimensional space, possibly with a warped metric. </p>
<p>This function uses Bridson's algorithm to generate evenly spaced points according to a minimum base distance, which can be warped using a user-defined scaling function (e.g., density or metric warping).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the sampling space. </td></tr>
    <tr><td class="paramname">ScaleFn</td><td>Callable type returning a scaling factor at a given point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of points (will attempt to generate up to this many). </td></tr>
    <tr><td class="paramname">ranges</td><td>Coordinate axis ranges (bounding box) for each of the N dimensions. </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Base minimum distance between any two points (before scaling). </td></tr>
    <tr><td class="paramname">scale_fn</td><td>Function that returns a distance scaling factor at a given point. This enables warped-space or non-uniform Poisson sampling. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed for reproducibility. </td></tr>
    <tr><td class="paramname">new_points_attempts</td><td>Number of candidate points to try around each active point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of sample points satisfying the scaled Poisson distance constraint. </dd></dl>

</div>
</div>
<a id="a6f7ab76c5d0a395aa78b85bad488e94e" name="a6f7ab76c5d0a395aa78b85bad488e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7ab76c5d0a395aa78b85bad488e94e">&#9670;&#160;</a></span>poisson_disk_sampling_uniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::poisson_disk_sampling_uniform </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base_min_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_points_attempts</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate uniformly distributed Poisson disk samples in N-dimensional space. </p>
<p>This is a convenience wrapper over <code>poisson_disk_sampling</code> using a constant distance scale (i.e., uniform metric).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of the sampling space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of points (will attempt to generate up to this many). </td></tr>
    <tr><td class="paramname">ranges</td><td>Coordinate axis ranges (bounding box) for each of the N dimensions. </td></tr>
    <tr><td class="paramname">base_min_dist</td><td>Minimum distance between any two points. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional RNG seed for reproducibility. </td></tr>
    <tr><td class="paramname">new_points_attempts</td><td>Number of candidate points to try around each active point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of uniformly spaced sample points. </dd></dl>

</div>
</div>
<a id="a10763ef2a872aa9eddb48ea341cd6f69" name="a10763ef2a872aa9eddb48ea341cd6f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10763ef2a872aa9eddb48ea341cd6f69">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::random </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a specified number of uniformly distributed random points in N-dimensional space. </p>
<p>This function creates <code>count</code> random points where each coordinate is independently sampled from a uniform distribution defined by <code>axis_ranges</code> per dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric type for coordinates (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>The dimensionality of the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of random points to generate. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>An array of N pairs specifying the min and max range for each axis. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for the random number generator. If not provided, a nondeterministic random seed is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing <code>count</code> randomly generated points within the specified axis ranges.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentIf</td><td>any axis range has min &gt; max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The points are generated independently per axis using uniform_real_distribution.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="random_8hpp.html">point_sampler/random.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> dim = 3;</div>
<div class="line">  <span class="keywordtype">size_t</span> count = 5;</div>
<div class="line">  std::array&lt;std::pair&lt;float, float&gt;, dim&gt; ranges = {{{0.f, 1.f}, {0.f, 2.f},</div>
<div class="line">{-1.f, 1.f}}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Generate points with a fixed seed for reproducibility auto points =</span></div>
<div class="line">ps::random&lt;float, dim&gt;(count, ranges, 42);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : points)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dim; ++i) std::cout &lt;&lt; p[i] &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="arandom_8hpp_html"><div class="ttname"><a href="random_8hpp.html">random.hpp</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2b8197901114d1c4fd6cfe19efcd3862" name="a2b8197901114d1c4fd6cfe19efcd3862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8197901114d1c4fd6cfe19efcd3862">&#9670;&#160;</a></span>refit_points_to_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ps::refit_points_to_range </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly remap a set of points to fit within the specified axis-aligned ranges. </p>
<p>This function computes the axis-aligned bounding box (AABB) of the input points and linearly rescales each point so that all dimensions lie in the given <code>target_ranges</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>Vector of input points to modify in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_ranges</td><td>Desired output min/max per dimension.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md8"></a>
Example</h3>
<div class="fragment"><div class="line"> std::vector&lt;Point&lt;float, 2&gt;&gt; pts = generate_random_points&lt;float,</div>
<div class="line">2&gt;(100, { {</div>
<div class="line">{0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"><span class="comment">// Refit to a new range: [10, 20] × [50, 100] refit_points_to_range&lt;float,</span></div>
<div class="line">2&gt;(pts, { { {10.f, 20.f}, {50.f, 100.f} } });</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If a dimension has constant value (min == max), the center of the target range is used. </dd></dl>

</div>
</div>
<a id="a29ab0a94bbe26a22cb87bf8f44703527" name="a29ab0a94bbe26a22cb87bf8f44703527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ab0a94bbe26a22cb87bf8f44703527">&#9670;&#160;</a></span>rejection_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename DensityFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; ps::rejection_sampling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DensityFn&#160;</td>
          <td class="paramname"><em>density_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates random points using rejection sampling based on a user-defined density function. </p>
<p>This function uniformly samples candidate points within the given axis-aligned bounds and retains them based on the output of a user-provided density function. The <code>density_fn</code> should return a probability in the range [0, 1] for each point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">DensityFn</td><td>Callable with signature T(Point&lt;T, N&gt;) returning a probability in [0, 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Desired number of accepted points. </td></tr>
    <tr><td class="paramname">axis_ranges</td><td>Ranges for each axis in the form of an array of (min, max) pairs. </td></tr>
    <tr><td class="paramname">density_fn</td><td>Function that returns a probability for accepting a point. </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed for reproducibility.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Point&lt;T, N&gt;&gt; A vector of accepted points based on rejection sampling.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argumentif</td><td>any axis range is invalid (min &gt; max).</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md9"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rejection__sampling_8hpp.html">point_sampler/rejection_sampling.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> radial_density(<span class="keyword">const</span> <a class="code hl_struct" href="structps_1_1Point.html">Point&lt;float, 2&gt;</a>&amp; p)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> r2 = p[0] * p[0] + p[1] * p[1];</div>
<div class="line">    <span class="keywordflow">return</span> std::exp(-r2); <span class="comment">// higher near origin, drops with radius</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::array&lt;std::pair&lt;float, float&gt;, 2&gt; bounds = { { {-2.0f, 2.0f},</div>
<div class="line">{-2.0f, 2.0f} } };</div>
<div class="line">    <span class="keyword">auto</span> pts = ps::rejection_sampling&lt;float, 2&gt;(1000, bounds, radial_density,</div>
<div class="line">42);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generated &quot;</span> &lt;&lt; pts.size() &lt;&lt; <span class="stringliteral">&quot; points.\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="arejection__sampling_8hpp_html"><div class="ttname"><a href="rejection__sampling_8hpp.html">rejection_sampling.hpp</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Rejection sampling can be inefficient if <code>density_fn</code> returns low values over most of the domain, as many candidate samples will be discarded. </dd></dl>

</div>
</div>
<a id="aed8a3217a801c5b5706f4bcc3306bb18" name="aed8a3217a801c5b5706f4bcc3306bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8a3217a801c5b5706f4bcc3306bb18">&#9670;&#160;</a></span>relaxation_ktree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ps::relaxation_ktree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k_neighbors</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step_size</em> = <code>T(0.1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relax a point set using a k-nearest neighbor repulsion algorithm with a KD-tree. </p>
<p>This function performs iterative relaxation on a set of N-dimensional points by pushing each point away from its nearest neighbors. It uses a KD-tree for efficient neighbor lookup. The goal is to reduce clustering and obtain a more uniform or blue-noise-like distribution.</p>
<p>Each point is offset based on inverse-distance-weighted repulsion from its k-nearest neighbors, normalized and scaled by a step size. The point set is updated over a number of iterations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type for coordinates (e.g., float or double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>The point set to relax. This vector will be modified in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k_neighbors</td><td>Number of neighbors to consider (default is 8). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_size</td><td>How far to move a point per iteration (default is 0.1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Number of relaxation iterations (default is 10).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The KD-tree is rebuilt on each iteration to reflect the updated positions.</dd></dl>
<h3><a class="anchor" id="autotoc_md10"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation_8hpp.html">point_sampler/relaxation.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;float, 2&gt;&gt; pts = generate_random_points&lt;float, 2&gt;(</div>
<div class="line">    1000, { { {0.f, 1.f}, {0.f, 1.f} } }, 42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply 10 iterations of relaxation relaxation_ktree&lt;float, 2&gt;(pts, 8, 0.1f,</span></div>
<div class="line">10);</div>
<div class="ttc" id="arelaxation_8hpp_html"><div class="ttname"><a href="relaxation_8hpp.html">relaxation.hpp</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
How it works:</h3>
<ul>
<li>For each point:<ul>
<li>Find its <code>k_neighbors</code> nearest neighbors using a KD-tree.</li>
<li>Compute offset vectors from the current point to each neighbor.</li>
<li>Weight the vectors by the inverse square distance (stronger push from closer neighbors).</li>
<li>Accumulate the offset, normalize, and scale by <code>step_size</code>.</li>
<li>Apply the movement to each point.</li>
</ul>
</li>
<li>Repeat for <code>iterations</code> steps. </li>
</ul>

</div>
</div>
<a id="a7addf1455112b7895f8de7c475eed850" name="a7addf1455112b7895f8de7c475eed850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addf1455112b7895f8de7c475eed850">&#9670;&#160;</a></span>rescale_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ps::rescale_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales normalized points (in [0, 1]) to specified axis-aligned ranges. </p>
<p>Each coordinate in every point is mapped from [0, 1] to a new range defined per axis. This is useful after generating normalized samples (e.g., Poisson disk, jittered grid).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Number of dimensions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">points</td><td>Vector of normalized points to be modified in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranges</td><td>Target value ranges for each dimension.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"> std::vector&lt;Point&lt;float, 2&gt;&gt; pts = { {0.f, 0.f}, {1.f, 1.f}, {0.5f,</div>
<div class="line">0.5f} };</div>
<div class="line">ps::rescale_points&lt;float, 2&gt;(pts, { { {10.f, 20.f}, {100.f, 200.f} } });</div>
<div class="line"><span class="comment">// pts is now { {10.f, 100.f}, {20.f, 200.f}, {15.f, 150.f} }</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Assumes points are in [0, 1]^N. Does not check bounds. </dd></dl>

</div>
</div>
<a id="a802637e81218193c0e65266c8075f002" name="a802637e81218193c0e65266c8075f002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802637e81218193c0e65266c8075f002">&#9670;&#160;</a></span>save_points_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ps::save_points_to_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write_header</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a set of N-dimensional points to a CSV file. </p>
<p>The output file will contain one point per line, with each coordinate separated by commas. Optionally, a header row ("x0,x1,...,xN") can be written as the first line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the output CSV file. </td></tr>
    <tr><td class="paramname">points</td><td>Vector of points to be saved. </td></tr>
    <tr><td class="paramname">write_header</td><td>If true, writes a header row with column names ("x0,x1,...").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was successfully written, false otherwise. </dd></dl>

</div>
</div>
<a id="af6737277b9cc05d5f2ab248f17baea3b" name="af6737277b9cc05d5f2ab248f17baea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6737277b9cc05d5f2ab248f17baea3b">&#9670;&#160;</a></span>split_by_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::vector&lt; T &gt;, N &gt; ps::split_by_dimension </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structps_1_1Point.html">Point</a>&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearranges a list of N-dimensional points into N separate coordinate vectors. </p>
<p>This function decomposes a vector of N-dimensional points into N vectors, where each vector contains all the values from one coordinate dimension. Useful for plotting or statistical analysis.</p>
<p>For example, given 3D points: [(1,2,3), (4,5,6), (7,8,9)], the result will be:</p><ul>
<li>dimension 0: [1, 4, 7]</li>
<li>dimension 1: [2, 5, 8]</li>
<li>dimension 2: [3, 6, 9]</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type (e.g., float, double). </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of each point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of N-dimensional points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of N vectors, each containing the values for one coordinate axis. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
