\doxysection{/home/runner/work/\+Point\+Sampler/\+Point\+Sampler/\+Point\+Sampler/include/point\+\_\+sampler/jittered\+\_\+grid.\+hpp}
\hypertarget{_2home_2runner_2work_2PointSampler_2PointSampler_2PointSampler_2include_2point_sampler_2jittered_grid_8hpp-example}{}\label{_2home_2runner_2work_2PointSampler_2PointSampler_2PointSampler_2include_2point_sampler_2jittered_grid_8hpp-example}Generates a point set on a jittered and optionally staggered grid.

Generates a point set on a jittered and optionally staggered grid.\+This function divides the domain into a grid and places one point in each selected cell. Each point is jittered within its cell, and staggered offsets may be applied depending on the index of higher-\/dimensional axes. The result is a semi-\/regular sampling pattern with randomness.

Jittering prevents aliasing, and staggering introduces a controlled shift between alternating cells to improve uniformity and avoid alignment artifacts.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of output points (best effort, may be capped by total available cells) \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the sampling domain \\
\hline
{\em jitter\+\_\+amount} & Per-\/dimension jitter factor âˆˆ \mbox{[}0, 1\mbox{]}. A value of 1.\+0 means full jitter in the cell. \\
\hline
{\em stagger\+\_\+ratio} & Per-\/dimension stagger ratio, indicating how much to offset points based on higher dimension parity \\
\hline
{\em seed} & Optional seed for deterministic jittering and shuffling \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ Sampled points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::array<std::pair<float,\ float>,\ 2>\ bounds\ =\ \{\{\{0.0f,\ 1.0f\},\ \{0.0f,}
\DoxyCodeLine{1.0f\}\}\};}
\DoxyCodeLine{std::array<float,\ 2>\ jitter\ =\ \{0.8f,\ 0.8f\};}
\DoxyCodeLine{std::array<float,\ 2>\ stagger\ =\ \{0.2f,\ 0.0f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ samples\ =\ ps::jittered\_grid<float,\ 2>(256,\ bounds,\ jitter,\ stagger,\ 42);}

\end{DoxyCode}



\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{/*\ Copyright\ (c)\ 2025\ Otto\ Link.\ Distributed\ under\ the\ terms\ of\ the\ GNU\ General}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ Public\ License.\ The\ full\ license\ is\ in\ the\ file\ LICENSE,\ distributed\ with}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ this\ software.\ */}}
\DoxyCodeLine{\textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <optional>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{point_8hpp}{point\_sampler/point.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceps}{ps}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{std::vector<Point<T,\ N>>\ \mbox{\hyperlink{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}{jittered\_grid}}(\textcolor{keywordtype}{size\_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::array<std::pair<T,\ T>,\ N>\ \&axis\_ranges,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::array<T,\ N>\ \ \ \ \ \&jitter\_amount,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::array<T,\ N>\ \ \ \ \ \&stagger\_ratio,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::optional<unsigned\ int>\ seed\ =\ std::nullopt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ std::mt19937\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ gen(seed\ ?\ *seed\ :\ std::random\_device\{\}());}
\DoxyCodeLine{\ \ std::uniform\_real\_distribution<T>\ uniform01(0.0,\ 1.0);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::array<size\_t,\ N>\ resolution;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{size\_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ total\_cells\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ T\ volume\ =\ 1;}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&[min,\ max]\ :\ axis\_ranges)}
\DoxyCodeLine{\ \ \ \ volume\ *=\ (max\ -\/\ min);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ T\ target\_cell\_volume\ =\ volume\ /\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(count);}
\DoxyCodeLine{\ \ T\ cell\_size\_estimate\ =\ std::pow(target\_cell\_volume,\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1.0)\ /\ N);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ N;\ ++i)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ T\ range\ =\ axis\_ranges[i].second\ -\/\ axis\_ranges[i].first;}
\DoxyCodeLine{\ \ \ \ resolution[i]\ =\ std::max<size\_t>(1,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(range\ /\ cell\_size\_estimate));}
\DoxyCodeLine{\ \ \ \ total\_cells\ *=\ resolution[i];}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::vector<Point<T,\ N>>\ points;}
\DoxyCodeLine{\ \ points.reserve(std::min(count,\ total\_cells));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::vector<std::array<size\_t,\ N>>\ cell\_indices;}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ linear\ =\ 0;\ linear\ <\ total\_cells;\ ++linear)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ std::array<size\_t,\ N>\ index\{\};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{size\_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ div\ =\ 1;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ N;\ ++i)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ index[i]\ =\ (linear\ /\ div)\ \%\ resolution[i];}
\DoxyCodeLine{\ \ \ \ \ \ div\ *=\ resolution[i];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ cell\_indices.push\_back(index);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::shuffle(cell\_indices.begin(),\ cell\_indices.end(),\ gen);}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{size\_t}\ limit\ =\ std::min(count,\ cell\_indices.size());}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ limit;\ ++i)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&idx\ =\ cell\_indices[i];}
\DoxyCodeLine{\ \ \ \ Point<T,\ N>\ p;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ d\ =\ 0;\ d\ <\ N;\ ++d)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ T\ range\_min\ =\ axis\_ranges[d].first;}
\DoxyCodeLine{\ \ \ \ \ \ T\ range\_max\ =\ axis\_ranges[d].second;}
\DoxyCodeLine{\ \ \ \ \ \ T\ cell\_size\ =\ (range\_max\ -\/\ range\_min)\ /\ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(resolution[d]);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ T\ jitter\_range\ =\ jitter\_amount[d]\ *\ cell\_size;}
\DoxyCodeLine{\ \ \ \ \ \ T\ jitter\_center\ =\ (1.0\ -\/\ jitter\_amount[d])\ *\ 0.5\ *\ cell\_size;}
\DoxyCodeLine{\ \ \ \ \ \ T\ jitter\ =\ uniform01(gen)\ *\ jitter\_range;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{comment}{//\ Compute\ stagger\ offset\ from\ higher\ dimensions}}
\DoxyCodeLine{\ \ \ \ \ \ T\ stagger\_offset\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ k\ =\ d\ +\ 1;\ k\ <\ N;\ ++k)}
\DoxyCodeLine{\ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (idx[k]\ \%\ 2\ ==\ 1)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ stagger\_offset\ +=\ stagger\_ratio[d]\ *\ cell\_size;}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ p[d]\ =\ range\_min\ +\ idx[d]\ *\ cell\_size\ +\ jitter\_center\ +\ jitter\ +\ stagger\_offset;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ points.push\_back(p);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ points;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{size\_t}\ N>}
\DoxyCodeLine{std::vector<Point<T,\ N>>\ \mbox{\hyperlink{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}{jittered\_grid}}(\textcolor{keywordtype}{size\_t}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ std::array<std::pair<T,\ T>,\ N>\ \&axis\_ranges,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::optional<unsigned\ int>\ seed\ =\ std::nullopt)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ std::array<T,\ N>\ full\_jitter;}
\DoxyCodeLine{\ \ std::array<T,\ N>\ stagger\_ratio;}
\DoxyCodeLine{\ \ full\_jitter.fill(\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(1.0));}
\DoxyCodeLine{\ \ stagger\_ratio.fill(\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(0.0));}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ jittered\_grid<T,\ N>(count,\ axis\_ranges,\ full\_jitter,\ stagger\_ratio,\ seed);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ namespace\ ps}}

\end{DoxyCodeInclude}
 