\doxysection{ps Namespace Reference}
\hypertarget{namespaceps}{}\label{namespaceps}\index{ps@{ps}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}
\item 
struct \mbox{\hyperlink{structps_1_1Point}{Point}}
\begin{DoxyCompactList}\small\item\em A fixed-\/size N-\/dimensional point/vector class. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\using \mbox{\hyperlink{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}{KDTree}} = nanoflann\+::\+KDTree\+Single\+Index\+Adaptor$<$ nanoflann\+::\+L2\+\_\+\+Simple\+\_\+\+Adaptor$<$ T, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$ T, N $>$ $>$, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$ T, N $>$, N $>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94}{distance\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, T min\+\_\+dist)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N, typename Scale\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_af23d114903fd5cb3ccb19d3e64183632}{distance\+\_\+rejection\+\_\+filter\+\_\+warped}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, T base\+\_\+min\+\_\+dist, Scale\+Fn scale\+\_\+fn)
\begin{DoxyCompactList}\small\item\em Filters points based on spatially-\/varying minimal distance constraints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a0e4055582214237ee9f21369133e6194}{function\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Filters points based on a spatial probability (density) function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}{gaussian\+\_\+clusters}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ cluster\+\_\+centers, size\+\_\+t points\+\_\+per\+\_\+cluster, T spread, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates clustered points around provided cluster centers using a Gaussian distribution. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d}{gaussian\+\_\+clusters}} (size\+\_\+t cluster\+\_\+count, size\+\_\+t points\+\_\+per\+\_\+cluster, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, T spread, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates clustered points around random centers uniformly sampled in a bounding box. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_aa8c3b3b3367276f9a194938599d2463b}{halton\+\_\+sequence}} (size\+\_\+t count, size\+\_\+t shift)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a81b18395a05f0bb4d483406e79aa9524}{halton}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a set of quasi-\/random points using the Halton sequence in N dimensions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3}{hammersley\+\_\+sequence}} (size\+\_\+t count, size\+\_\+t shift)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6}{hammersley}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a set of quasi-\/random points using the Hammersley sequence in N dimensions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a932640b18d76a7e336fc760e9cf5511b}{importance\+\_\+resampling}} (size\+\_\+t count, size\+\_\+t oversampling\+\_\+ratio, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a point set via importance resampling from a quasi-\/random oversampled grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}{jittered\+\_\+grid}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, const std\+::array$<$ T, N $>$ \&jitter\+\_\+amount, const std\+::array$<$ T, N $>$ \&stagger\+\_\+ratio, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a point set on a jittered and optionally staggered grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ae90df8db8e751ff4b61298114f092714}{jittered\+\_\+grid}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a jittered grid of points with full jitter and no stagger. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0}{latin\+\_\+hypercube\+\_\+sampling}} (std\+::size\+\_\+t sample\+\_\+count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0}{operator+}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1}{operator-\/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b}{operator\texorpdfstring{$\ast$}{*}}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a585704d3f738c5eb899810fc9308a60e}{operator/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a366ef094d65da865384b6fb77aac5d5f}{operator+}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f}{operator-\/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_acd4dc781f43ba8a50daa139682846d4b}{operator\texorpdfstring{$\ast$}{*}}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580}{operator/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4}{operator\texorpdfstring{$\ast$}{*}}} (T scalar, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_afe774cb61bde6358f8a7024c42db9804}{operator+}} (T scalar, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_ace7642868199df621df9139e5179767b}{dot}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_a7c3e161560ad3000aa4e2218291b169c}{length\+\_\+squared}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746}{length}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a7de6090e2c8291401816be9bc6cda914}{normalized}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808}{distance\+\_\+squared}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11}{distance}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa}{lerp}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b, T t)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_adb0bd4806c7e79eddef0e1263740ae28}{clamp}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T min\+\_\+val, T max\+\_\+val)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ }\\bool \mbox{\hyperlink{namespaceps_aedb5908eae325f054e4f3dd6b9b223af}{in\+\_\+neighborhood}} (const \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}$<$ T, N $>$ \&grid, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T base\+\_\+min\+\_\+dist, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, Scale\+Fn scale\+\_\+fn)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a898bca65491a14a41bfdd50fdc6230b8}{generate\+\_\+random\+\_\+point\+\_\+around}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&center, T base\+\_\+min\+\_\+dist, std\+::mt19937 \&gen, std\+::function$<$ T(const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&)$>$ scale\+\_\+fn)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8}{poisson\+\_\+disk\+\_\+sampling}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, T base\+\_\+min\+\_\+dist, Scale\+Fn scale\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt, size\+\_\+t new\+\_\+points\+\_\+attempts=30)
\begin{DoxyCompactList}\small\item\em Generate a set of Poisson disk samples in N-\/dimensional space, possibly with a warped metric. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e}{poisson\+\_\+disk\+\_\+sampling\+\_\+uniform}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, T base\+\_\+min\+\_\+dist, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt, size\+\_\+t new\+\_\+points\+\_\+attempts=30)
\begin{DoxyCompactList}\small\item\em Generate uniformly distributed Poisson disk samples in N-\/dimensional space. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69}{random}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a specified number of uniformly distributed random points in N-\/dimensional space. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{random\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, std\+::size\+\_\+t target\+\_\+count)
\begin{DoxyCompactList}\small\item\em Randomly retains a fixed number of points from the input set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a66183362443c104da098224df9bcd2a1}{random\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, float keep\+\_\+fraction)
\begin{DoxyCompactList}\small\item\em Randomly retains a fraction of the input points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df}{filter\+\_\+points\+\_\+in\+\_\+range}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges)
\begin{DoxyCompactList}\small\item\em Filters points that lie within the specified axis-\/aligned bounding box. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N, typename Func $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a5350b843397a5bf2a748115108ffa21a}{filter\+\_\+points\+\_\+function}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, Func fn)
\begin{DoxyCompactList}\small\item\em Filters points using a user-\/provided function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862}{refit\+\_\+points\+\_\+to\+\_\+range}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&target\+\_\+ranges)
\begin{DoxyCompactList}\small\item\em Linearly remap a set of points to fit within the specified axis-\/aligned ranges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_a7addf1455112b7895f8de7c475eed850}{rescale\+\_\+points}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges)
\begin{DoxyCompactList}\small\item\em Rescales normalized points (in \mbox{[}0, 1\mbox{]}) to specified axis-\/aligned ranges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527}{rejection\+\_\+sampling}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates random points using rejection sampling based on a user-\/defined density function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18}{relaxation\+\_\+ktree}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, size\+\_\+t k\+\_\+neighbors=8, T step\+\_\+size=T(0.\+1), size\+\_\+t iterations=10)
\begin{DoxyCompactList}\small\item\em Relax a point set using a k-\/nearest neighbor repulsion algorithm with a KD-\/tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\bool \mbox{\hyperlink{namespaceps_a802637e81218193c0e65266c8075f002}{save\+\_\+points\+\_\+to\+\_\+csv}} (const std\+::string \&filename, const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, bool write\+\_\+header=true)
\begin{DoxyCompactList}\small\item\em Save a set of N-\/dimensional points to a CSV file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::array$<$ std\+::vector$<$ T $>$, N $>$ \mbox{\hyperlink{namespaceps_af6737277b9cc05d5f2ab248f17baea3b}{split\+\_\+by\+\_\+dimension}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points)
\begin{DoxyCompactList}\small\item\em Rearranges a list of N-\/dimensional points into N separate coordinate vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\Hypertarget{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}\label{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a} 
\index{ps@{ps}!KDTree@{KDTree}}
\index{KDTree@{KDTree}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{KDTree}{KDTree}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
using \mbox{\hyperlink{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}{ps\+::\+KDTree}} = typedef nanoflann\+::\+KDTree\+Single\+Index\+Adaptor$<$ nanoflann\+::\+L2\+\_\+\+Simple\+\_\+\+Adaptor$<$T, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$T, N$>$ $>$, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$T, N$>$, N$>$}



\doxysubsection{Function Documentation}
\Hypertarget{namespaceps_adb0bd4806c7e79eddef0e1263740ae28}\label{namespaceps_adb0bd4806c7e79eddef0e1263740ae28} 
\index{ps@{ps}!clamp@{clamp}}
\index{clamp@{clamp}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{clamp()}{clamp()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::clamp (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{min\+\_\+val,  }\item[{T}]{max\+\_\+val }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11}\label{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11} 
\index{ps@{ps}!distance@{distance}}
\index{distance@{distance}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance()}{distance()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::distance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94}\label{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94} 
\index{ps@{ps}!distance\_rejection\_filter@{distance\_rejection\_filter}}
\index{distance\_rejection\_filter@{distance\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_rejection\_filter()}{distance\_rejection\_filter()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::distance\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{T}]{min\+\_\+dist }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_af23d114903fd5cb3ccb19d3e64183632}\label{namespaceps_af23d114903fd5cb3ccb19d3e64183632} 
\index{ps@{ps}!distance\_rejection\_filter\_warped@{distance\_rejection\_filter\_warped}}
\index{distance\_rejection\_filter\_warped@{distance\_rejection\_filter\_warped}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_rejection\_filter\_warped()}{distance\_rejection\_filter\_warped()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N, typename Scale\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::distance\+\_\+rejection\+\_\+filter\+\_\+warped (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{Scale\+Fn}]{scale\+\_\+fn }\end{DoxyParamCaption})}



Filters points based on spatially-\/varying minimal distance constraints. 

A scale function is used to modulate the minimum allowed distance for each point. The base distance {\ttfamily base\+\_\+min\+\_\+dist} is scaled by the value returned by {\ttfamily scale\+\_\+fn(p)}, allowing for adaptive sampling densities.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Scale\+Fn} & Callable returning a scalar scale factor for a given point\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of candidate points \\
\hline
{\em base\+\_\+min\+\_\+dist} & Base minimum allowed distance \\
\hline
{\em scale\+\_\+fn} & Function providing a local scale factor per point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A filtered set of points with variable spacing
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md0}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md0}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ scale\_fn\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0.5f\ +\ 0.5f\ *\ std::sin(p[0]\ *\ 3.1415f);\ \textcolor{comment}{//\ Varies\ between\ 0.5\ and}}
\DoxyCodeLine{1}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<Point<float,\ 2>>\ pts\ =\ ps::random<float,\ 2>(1000,\ \{\{0,1\},\{0,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ \mbox{\hyperlink{namespaceps_af23d114903fd5cb3ccb19d3e64183632}{ps::distance\_rejection\_filter\_warped}}(pts,\ 0.05f,\ scale\_fn);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808}\label{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808} 
\index{ps@{ps}!distance\_squared@{distance\_squared}}
\index{distance\_squared@{distance\_squared}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_squared()}{distance\_squared()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::distance\+\_\+squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ace7642868199df621df9139e5179767b}\label{namespaceps_ace7642868199df621df9139e5179767b} 
\index{ps@{ps}!dot@{dot}}
\index{dot@{dot}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::dot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a5350b843397a5bf2a748115108ffa21a}\label{namespaceps_a5350b843397a5bf2a748115108ffa21a} 
\index{ps@{ps}!filter\_points\_function@{filter\_points\_function}}
\index{filter\_points\_function@{filter\_points\_function}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{filter\_points\_function()}{filter\_points\_function()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N, typename Func $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::filter\+\_\+points\+\_\+function (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{Func}]{fn }\end{DoxyParamCaption})}



Filters points using a user-\/provided function. 

Keeps only the points for which the provided function {\ttfamily fn(p)} does not return zero. This can be used to apply custom masks, implicit surface functions, etc.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates. \\
\hline
{\em N} & Number of dimensions. \\
\hline
{\em Func} & Callable that takes a Point$<$\+T, N$>$ and returns a value convertible to T.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of input points. \\
\hline
{\em fn} & Unary function that returns a non-\/zero value if the point should be kept.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of filtered points.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\},\ \{2.f,\ 2.f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ ps::filter\_points\_function<float,\ 2>(pts,\ [](\textcolor{keyword}{const}}
\DoxyCodeLine{Point<float,\ 2>\ \&p)\ \{\ \textcolor{keywordflow}{return}\ (p[0]\ +\ p[1]\ <\ 2.5f)\ ?\ 1.f\ :\ 0.f;\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ Keeps\ only\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\}\ \}}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df}\label{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df} 
\index{ps@{ps}!filter\_points\_in\_range@{filter\_points\_in\_range}}
\index{filter\_points\_in\_range@{filter\_points\_in\_range}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{filter\_points\_in\_range()}{filter\_points\_in\_range()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::filter\+\_\+points\+\_\+in\+\_\+range (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges }\end{DoxyParamCaption})}



Filters points that lie within the specified axis-\/aligned bounding box. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of input points to filter. \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box ranges for each dimension (inclusive).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector containing only the points that lie within all specified axis ranges.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argumentifaxis\+\_\+rangesareill-\/formed(e.\+g.,min} & \texorpdfstring{$>$}{>} max).\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.5f,\ 0.5f\},\ \{2.f,\ 3.f\},\ \{-\/1.f,}
\DoxyCodeLine{0.f\}\ \};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ ps::filter\_points\_in\_range<float,\ 2>(pts,\ \{\ \{\{0.f,\ 1.f\},}
\DoxyCodeLine{\{0.f,\ 1.f\}\}\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ filtered\ now\ contains\ only\ \{\ \{0.5f,\ 0.5f\}\ \}}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a0e4055582214237ee9f21369133e6194}\label{namespaceps_a0e4055582214237ee9f21369133e6194} 
\index{ps@{ps}!function\_rejection\_filter@{function\_rejection\_filter}}
\index{function\_rejection\_filter@{function\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{function\_rejection\_filter()}{function\_rejection\_filter()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::function\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Filters points based on a spatial probability (density) function. 

Each point is accepted with a probability given by {\ttfamily density\+\_\+fn(p)}, which should return a value in \mbox{[}0, 1\mbox{]}. This is useful for sampling from a non-\/uniform spatial distribution.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Density\+Fn} & Callable type with signature {\ttfamily T(const \doxylink{structps_1_1Point}{Point}\texorpdfstring{$<$}{<}T, N\texorpdfstring{$>$}{>}\&)} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input candidate points \\
\hline
{\em density\+\_\+fn} & Function returning acceptance probability for each point \\
\hline
{\em seed} & Optional random seed for reproducibility \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ of accepted points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ field\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0.5f\ +\ 0.5f\ *\ std::sin(p[0]\ *\ 10.0f);\ \textcolor{comment}{//\ Spatial\ density}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ accepted\ =\ \mbox{\hyperlink{namespaceps_a0e4055582214237ee9f21369133e6194}{ps::function\_rejection\_filter}}(pts,\ field);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d}\label{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d} 
\index{ps@{ps}!gaussian\_clusters@{gaussian\_clusters}}
\index{gaussian\_clusters@{gaussian\_clusters}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{gaussian\_clusters()}{gaussian\_clusters()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::gaussian\+\_\+clusters (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{cluster\+\_\+count,  }\item[{size\+\_\+t}]{points\+\_\+per\+\_\+cluster,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{T}]{spread,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates clustered points around random centers uniformly sampled in a bounding box. 

Cluster centers are randomly sampled within the provided {\ttfamily axis\+\_\+ranges}, and each cluster then has {\ttfamily points\+\_\+per\+\_\+cluster} points sampled from a Gaussian distribution centered at the cluster\textquotesingle{}s location, with a specified standard deviation {\ttfamily spread}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cluster\+\_\+count} & Number of cluster centers to generate \\
\hline
{\em points\+\_\+per\+\_\+cluster} & Number of points per cluster \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box ranges for each dimension \\
\hline
{\em spread} & Standard deviation of the Gaussian spread \\
\hline
{\em seed} & Optional random seed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of clustered points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md2}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md2}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ clustered\ =\ ps::gaussian\_clusters<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 5,\ 100,}
\DoxyCodeLine{\ \ \ \ \{\{\{0,1\},\ \{0,1\}\}\},\ 0.03f}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}\label{namespaceps_a913ab9d687ee42d04488e5eb0373e23a} 
\index{ps@{ps}!gaussian\_clusters@{gaussian\_clusters}}
\index{gaussian\_clusters@{gaussian\_clusters}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{gaussian\_clusters()}{gaussian\_clusters()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::gaussian\+\_\+clusters (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$}]{cluster\+\_\+centers,  }\item[{size\+\_\+t}]{points\+\_\+per\+\_\+cluster,  }\item[{T}]{spread,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates clustered points around provided cluster centers using a Gaussian distribution. 

For each cluster center, this function generates {\ttfamily points\+\_\+per\+\_\+cluster} points where each coordinate is sampled from a normal distribution centered at the coordinate of the cluster center with standard deviation {\ttfamily spread}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cluster\+\_\+centers} & A vector of cluster center points \\
\hline
{\em points\+\_\+per\+\_\+cluster} & Number of points to generate per cluster \\
\hline
{\em spread} & Standard deviation of the Gaussian spread \\
\hline
{\em seed} & Optional random seed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of clustered points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md1}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md1}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ centers\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.2f,\ 0.2f\},}
\DoxyCodeLine{\ \ \ \ \{0.8f,\ 0.8f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ clustered\ =\ \mbox{\hyperlink{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}{ps::gaussian\_clusters}}(centers,\ 100,\ 0.05f);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a898bca65491a14a41bfdd50fdc6230b8}\label{namespaceps_a898bca65491a14a41bfdd50fdc6230b8} 
\index{ps@{ps}!generate\_random\_point\_around@{generate\_random\_point\_around}}
\index{generate\_random\_point\_around@{generate\_random\_point\_around}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{generate\_random\_point\_around()}{generate\_random\_point\_around()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::generate\+\_\+random\+\_\+point\+\_\+around (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{center,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{std\+::mt19937 \&}]{gen,  }\item[{std\+::function$<$ T(const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&)$>$}]{scale\+\_\+fn }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a81b18395a05f0bb4d483406e79aa9524}\label{namespaceps_a81b18395a05f0bb4d483406e79aa9524} 
\index{ps@{ps}!halton@{halton}}
\index{halton@{halton}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{halton()}{halton()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::halton (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a set of quasi-\/random points using the Halton sequence in N dimensions. 

This function generates {\ttfamily count} points in the unit hypercube using the Halton sequence, then rescales them to fit within the specified axis-\/aligned bounding box. An optional {\ttfamily seed} is used as a starting index offset (i.\+e., a shift) in the sequence to decorrelate multiple calls.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box for each dimension, as min/max pairs \\
\hline
{\em seed} & Optional seed that offsets the sequence start index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The generated Halton points rescaled to the bounding box
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md3}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md3}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ points\ =\ ps::halton<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 1000,}
\DoxyCodeLine{\ \ \ \ \{\{\{0,\ 1\},\ \{0,\ 1\}\}\},\ 42}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aa8c3b3b3367276f9a194938599d2463b}\label{namespaceps_aa8c3b3b3367276f9a194938599d2463b} 
\index{ps@{ps}!halton\_sequence@{halton\_sequence}}
\index{halton\_sequence@{halton\_sequence}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{halton\_sequence()}{halton\_sequence()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::halton\+\_\+sequence (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{shift }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6}\label{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6} 
\index{ps@{ps}!hammersley@{hammersley}}
\index{hammersley@{hammersley}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{hammersley()}{hammersley()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::hammersley (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a set of quasi-\/random points using the Hammersley sequence in N dimensions. 

This function generates {\ttfamily count} points in the unit hypercube using the Hammersley sequence, then rescales them to fit within the specified axis-\/aligned bounding box. An optional {\ttfamily seed} can be used as a starting index offset (i.\+e., a shift) to decorrelate multiple calls or introduce variation.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box for each dimension, as min/max pairs \\
\hline
{\em seed} & Optional seed that offsets the sequence start index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The generated Hammersley points rescaled to the bounding box
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md4}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ points\ =\ ps::hammersley<float,\ 3>(}
\DoxyCodeLine{\ \ \ \ 512,}
\DoxyCodeLine{\ \ \ \ \{\{\{-\/1,\ 1\},\ \{-\/1,\ 1\},\ \{0,\ 1\}\}\},\ 7}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3}\label{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3} 
\index{ps@{ps}!hammersley\_sequence@{hammersley\_sequence}}
\index{hammersley\_sequence@{hammersley\_sequence}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{hammersley\_sequence()}{hammersley\_sequence()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::hammersley\+\_\+sequence (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{shift }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a932640b18d76a7e336fc760e9cf5511b}\label{namespaceps_a932640b18d76a7e336fc760e9cf5511b} 
\index{ps@{ps}!importance\_resampling@{importance\_resampling}}
\index{importance\_resampling@{importance\_resampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{importance\_resampling()}{importance\_resampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::importance\+\_\+resampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{oversampling\+\_\+ratio,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a point set via importance resampling from a quasi-\/random oversampled grid. 

This function uses a Halton sequence to create an oversampled set of candidate points in the domain. Each point is assigned a weight based on the provided density function. A discrete distribution is then used to resample {\ttfamily count} points according to these weights.

The higher the {\ttfamily oversampling\+\_\+ratio}, the better the approximation to the target density, at the cost of performance.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Density\+Fn} & A callable with signature {\ttfamily T(const \doxylink{structps_1_1Point}{Point}\texorpdfstring{$<$}{<}T, N\texorpdfstring{$>$}{>}\&)} returning a non-\/negative density value \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to return after resampling \\
\hline
{\em oversampling\+\_\+ratio} & Number of candidate points to generate as a multiple of {\ttfamily count} \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the domain of the points \\
\hline
{\em density\+\_\+fn} & Function mapping a point to a (non-\/negative) density value \\
\hline
{\em seed} & Optional seed to control the random number generator \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The resulting resampled point set
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md5}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ density\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\ \&p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::exp(-\/10.0f\ *\ (p[0]*p[0]\ +\ p[1]*p[1]));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ points\ =\ ps::importance\_resampling<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 500,\ 5,}
\DoxyCodeLine{\ \ \ \ \{\{\{-\/1,\ 1\},\ \{-\/1,\ 1\}\}\},\ density,\ 42}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aedb5908eae325f054e4f3dd6b9b223af}\label{namespaceps_aedb5908eae325f054e4f3dd6b9b223af} 
\index{ps@{ps}!in\_neighborhood@{in\_neighborhood}}
\index{in\_neighborhood@{in\_neighborhood}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{in\_neighborhood()}{in\_neighborhood()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ \\
bool ps\+::in\+\_\+neighborhood (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}$<$ T, N $>$ \&}]{grid,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{Scale\+Fn}]{scale\+\_\+fn }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}\label{namespaceps_ad8525c124fef24618bf574b9b7b1ece8} 
\index{ps@{ps}!jittered\_grid@{jittered\_grid}}
\index{jittered\_grid@{jittered\_grid}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{jittered\_grid()}{jittered\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::jittered\+\_\+grid (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{const std\+::array$<$ T, N $>$ \&}]{jitter\+\_\+amount,  }\item[{const std\+::array$<$ T, N $>$ \&}]{stagger\+\_\+ratio,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a point set on a jittered and optionally staggered grid. 

This function divides the domain into a grid and places one point in each selected cell. Each point is jittered within its cell, and staggered offsets may be applied depending on the index of higher-\/dimensional axes. The result is a semi-\/regular sampling pattern with randomness.

Jittering prevents aliasing, and staggering introduces a controlled shift between alternating cells to improve uniformity and avoid alignment artifacts.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of output points (best effort, may be capped by total available cells) \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the sampling domain \\
\hline
{\em jitter\+\_\+amount} & Per-\/dimension jitter factor ∈ \mbox{[}0, 1\mbox{]}. A value of 1.\+0 means full jitter in the cell. \\
\hline
{\em stagger\+\_\+ratio} & Per-\/dimension stagger ratio, indicating how much to offset points based on higher dimension parity \\
\hline
{\em seed} & Optional seed for deterministic jittering and shuffling \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ Sampled points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md6}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::array<std::pair<float,\ float>,\ 2>\ bounds\ =\ \{\{\{0.0f,\ 1.0f\},\ \{0.0f,}
\DoxyCodeLine{1.0f\}\}\};}
\DoxyCodeLine{std::array<float,\ 2>\ jitter\ =\ \{0.8f,\ 0.8f\};}
\DoxyCodeLine{std::array<float,\ 2>\ stagger\ =\ \{0.2f,\ 0.0f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ samples\ =\ ps::jittered\_grid<float,\ 2>(256,\ bounds,\ jitter,\ stagger,\ 42);}

\end{DoxyCode}
 \Hypertarget{namespaceps_ae90df8db8e751ff4b61298114f092714}\label{namespaceps_ae90df8db8e751ff4b61298114f092714} 
\index{ps@{ps}!jittered\_grid@{jittered\_grid}}
\index{jittered\_grid@{jittered\_grid}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{jittered\_grid()}{jittered\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::jittered\+\_\+grid (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a jittered grid of points with full jitter and no stagger. 

This overload defaults to jittering each dimension fully within its cell and applies no staggering. It is equivalent to calling the full version with {\ttfamily jitter\+\_\+amount} filled with 1.\+0 and {\ttfamily stagger\+\_\+ratio} filled with 0.\+0.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the sampling domain \\
\hline
{\em seed} & Optional seed for deterministic jittering \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ Jittered point samples
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md7}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md7}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::array<std::pair<double,\ double>,\ 3>\ bounds\ =\ \{\{\{0,\ 1\},\ \{0,\ 1\},\ \{0,}
\DoxyCodeLine{1\}\}\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ points\ =\ ps::jittered\_grid<double,\ 3>(1000,\ bounds,\ 1234);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0}\label{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0} 
\index{ps@{ps}!latin\_hypercube\_sampling@{latin\_hypercube\_sampling}}
\index{latin\_hypercube\_sampling@{latin\_hypercube\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{latin\_hypercube\_sampling()}{latin\_hypercube\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::latin\+\_\+hypercube\+\_\+sampling (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{sample\+\_\+count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746}\label{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746} 
\index{ps@{ps}!length@{length}}
\index{length@{length}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{length()}{length()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::length (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a7c3e161560ad3000aa4e2218291b169c}\label{namespaceps_a7c3e161560ad3000aa4e2218291b169c} 
\index{ps@{ps}!length\_squared@{length\_squared}}
\index{length\_squared@{length\_squared}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{length\_squared()}{length\_squared()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::length\+\_\+squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa}\label{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa} 
\index{ps@{ps}!lerp@{lerp}}
\index{lerp@{lerp}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{lerp()}{lerp()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::lerp (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b,  }\item[{T}]{t }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a7de6090e2c8291401816be9bc6cda914}\label{namespaceps_a7de6090e2c8291401816be9bc6cda914} 
\index{ps@{ps}!normalized@{normalized}}
\index{normalized@{normalized}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{normalized()}{normalized()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::normalized (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b}\label{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_acd4dc781f43ba8a50daa139682846d4b}\label{namespaceps_acd4dc781f43ba8a50daa139682846d4b} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4}\label{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{T}]{scalar,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0}\label{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a366ef094d65da865384b6fb77aac5d5f}\label{namespaceps_a366ef094d65da865384b6fb77aac5d5f} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_afe774cb61bde6358f8a7024c42db9804}\label{namespaceps_afe774cb61bde6358f8a7024c42db9804} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{T}]{scalar,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1}\label{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1} 
\index{ps@{ps}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f}\label{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f} 
\index{ps@{ps}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a585704d3f738c5eb899810fc9308a60e}\label{namespaceps_a585704d3f738c5eb899810fc9308a60e} 
\index{ps@{ps}!operator/@{operator/}}
\index{operator/@{operator/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580}\label{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580} 
\index{ps@{ps}!operator/@{operator/}}
\index{operator/@{operator/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8}\label{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8} 
\index{ps@{ps}!poisson\_disk\_sampling@{poisson\_disk\_sampling}}
\index{poisson\_disk\_sampling@{poisson\_disk\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{poisson\_disk\_sampling()}{poisson\_disk\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::poisson\+\_\+disk\+\_\+sampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{Scale\+Fn}]{scale\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt},  }\item[{size\+\_\+t}]{new\+\_\+points\+\_\+attempts = {\ttfamily 30} }\end{DoxyParamCaption})}



Generate a set of Poisson disk samples in N-\/dimensional space, possibly with a warped metric. 

This function uses Bridson\textquotesingle{}s algorithm to generate evenly spaced points according to a minimum base distance, which can be warped using a user-\/defined scaling function (e.\+g., density or metric warping).


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double). \\
\hline
{\em N} & Dimension of the sampling space. \\
\hline
{\em Scale\+Fn} & Callable type returning a scaling factor at a given point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Desired number of points (will attempt to generate up to this many). \\
\hline
{\em ranges} & Coordinate axis ranges (bounding box) for each of the N dimensions. \\
\hline
{\em base\+\_\+min\+\_\+dist} & Base minimum distance between any two points (before scaling). \\
\hline
{\em scale\+\_\+fn} & Function that returns a distance scaling factor at a given point. This enables warped-\/space or non-\/uniform Poisson sampling. \\
\hline
{\em seed} & Optional RNG seed for reproducibility. \\
\hline
{\em new\+\_\+points\+\_\+attempts} & Number of candidate points to try around each active point.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of sample points satisfying the scaled Poisson distance constraint. 
\end{DoxyReturn}
\Hypertarget{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e}\label{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e} 
\index{ps@{ps}!poisson\_disk\_sampling\_uniform@{poisson\_disk\_sampling\_uniform}}
\index{poisson\_disk\_sampling\_uniform@{poisson\_disk\_sampling\_uniform}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{poisson\_disk\_sampling\_uniform()}{poisson\_disk\_sampling\_uniform()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::poisson\+\_\+disk\+\_\+sampling\+\_\+uniform (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt},  }\item[{size\+\_\+t}]{new\+\_\+points\+\_\+attempts = {\ttfamily 30} }\end{DoxyParamCaption})}



Generate uniformly distributed Poisson disk samples in N-\/dimensional space. 

This is a convenience wrapper over {\ttfamily poisson\+\_\+disk\+\_\+sampling} using a constant distance scale (i.\+e., uniform metric).


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double). \\
\hline
{\em N} & Dimension of the sampling space.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Desired number of points (will attempt to generate up to this many). \\
\hline
{\em ranges} & Coordinate axis ranges (bounding box) for each of the N dimensions. \\
\hline
{\em base\+\_\+min\+\_\+dist} & Minimum distance between any two points. \\
\hline
{\em seed} & Optional RNG seed for reproducibility. \\
\hline
{\em new\+\_\+points\+\_\+attempts} & Number of candidate points to try around each active point.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of uniformly spaced sample points. 
\end{DoxyReturn}
\Hypertarget{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69}\label{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69} 
\index{ps@{ps}!random@{random}}
\index{random@{random}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random()}{random()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a specified number of uniformly distributed random points in N-\/dimensional space. 

This function creates {\ttfamily count} random points where each coordinate is independently sampled from a uniform distribution defined by {\ttfamily axis\+\_\+ranges} per dimension.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The numeric type for coordinates (e.\+g., float, double). \\
\hline
{\em N} & The dimensionality of the points.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & The number of random points to generate. \\
\hline
{\em axis\+\_\+ranges} & An array of N pairs specifying the min and max range for each axis. \\
\hline
{\em seed} & Optional seed for the random number generator. If not provided, a nondeterministic random seed is used.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector containing {\ttfamily count} randomly generated points within the specified axis ranges.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument\+Ifanyaxisrangehas} & min \texorpdfstring{$>$}{>} max.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
The points are generated independently per axis using uniform\+\_\+real\+\_\+distribution.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{random_8hpp}{point\_sampler/random.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ dim\ =\ 3;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{size\_t}\ count\ =\ 5;}
\DoxyCodeLine{\ \ std::array<std::pair<float,\ float>,\ dim>\ ranges\ =\ \{\{\{0.f,\ 1.f\},\ \{0.f,\ 2.f\},}
\DoxyCodeLine{\{-\/1.f,\ 1.f\}\}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Generate\ points\ with\ a\ fixed\ seed\ for\ reproducibility\ auto\ points\ =}}
\DoxyCodeLine{ps::random<float,\ dim>(count,\ ranges,\ 42);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ p\ :\ points)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ dim;\ ++i)\ std::cout\ <<\ p[i]\ <<\ \textcolor{charliteral}{'\ '};}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a66183362443c104da098224df9bcd2a1}\label{namespaceps_a66183362443c104da098224df9bcd2a1} 
\index{ps@{ps}!random\_rejection\_filter@{random\_rejection\_filter}}
\index{random\_rejection\_filter@{random\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random\_rejection\_filter()}{random\_rejection\_filter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{float}]{keep\+\_\+fraction }\end{DoxyParamCaption})}



Randomly retains a fraction of the input points. 

This is a convenience overload of {\ttfamily random\+\_\+rejection\+\_\+filter} that accepts a floating-\/point {\ttfamily keep\+\_\+fraction} instead of an absolute count. Internally, it computes the number of points to retain and calls the count-\/based version.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input vector of points \\
\hline
{\em keep\+\_\+fraction} & Fraction of points to retain (between 0.\+0 and 1.\+0) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ containing {\ttfamily keep\+\_\+fraction \texorpdfstring{$\ast$}{*} points.\+size()} randomly selected points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<double,\ 3>>\ cloud\ =\ ps::random<double,\ 3>(10000,}
\DoxyCodeLine{\{\{-\/1,1\},\{-\/1,1\},\{-\/1,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ sparse\ =\ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{ps::random\_rejection\_filter}}(cloud,\ 0.25);\ \textcolor{comment}{//\ Keep\ 25\%\ of\ the}}
\DoxyCodeLine{points}

\end{DoxyCode}
 \Hypertarget{namespaceps_ab818126518017939773c8a43bd92fc42}\label{namespaceps_ab818126518017939773c8a43bd92fc42} 
\index{ps@{ps}!random\_rejection\_filter@{random\_rejection\_filter}}
\index{random\_rejection\_filter@{random\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random\_rejection\_filter()}{random\_rejection\_filter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{std\+::size\+\_\+t}]{target\+\_\+count }\end{DoxyParamCaption})}



Randomly retains a fixed number of points from the input set. 

This function returns a subset of the input points of size {\ttfamily target\+\_\+count}, selected uniformly at random without replacement. If {\ttfamily target\+\_\+count} is greater than or equal to the number of input points, the full input is returned.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input vector of points \\
\hline
{\em target\+\_\+count} & Desired number of points in the output (≤ points.\+size()) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ containing {\ttfamily target\+\_\+count} randomly selected points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ ps::random<float,\ 2>(1000,}
\DoxyCodeLine{\{\{0,1\},\{0,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ reduced\ =\ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{ps::random\_rejection\_filter}}(pts,\ 300);\ \textcolor{comment}{//\ Keep\ 300\ points}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862}\label{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862} 
\index{ps@{ps}!refit\_points\_to\_range@{refit\_points\_to\_range}}
\index{refit\_points\_to\_range@{refit\_points\_to\_range}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{refit\_points\_to\_range()}{refit\_points\_to\_range()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::refit\+\_\+points\+\_\+to\+\_\+range (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{target\+\_\+ranges }\end{DoxyParamCaption})}



Linearly remap a set of points to fit within the specified axis-\/aligned ranges. 

This function computes the axis-\/aligned bounding box (AABB) of the input points and linearly rescales each point so that all dimensions lie in the given {\ttfamily target\+\_\+ranges}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & Vector of input points to modify in-\/place. \\
\hline
\mbox{\texttt{ in}}  & {\em target\+\_\+ranges} & Desired output min/max per dimension.\\
\hline
\end{DoxyParams}
\hypertarget{namespaceps_autotoc_md8}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md8}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ generate\_random\_points<float,}
\DoxyCodeLine{2>(100,\ \{\ \{}
\DoxyCodeLine{\{0.f,\ 1.f\},\ \{0.f,\ 1.f\}\ \}\ \},\ 42);}
\DoxyCodeLine{\textcolor{comment}{//\ Refit\ to\ a\ new\ range:\ [10,\ 20]\ ×\ [50,\ 100]\ refit\_points\_to\_range<float,}}
\DoxyCodeLine{2>(pts,\ \{\ \{\ \{10.f,\ 20.f\},\ \{50.f,\ 100.f\}\ \}\ \});}

\end{DoxyCode}


\begin{DoxyNote}{Note}
If a dimension has constant value (min == max), the center of the target range is used. 
\end{DoxyNote}
\Hypertarget{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527}\label{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527} 
\index{ps@{ps}!rejection\_sampling@{rejection\_sampling}}
\index{rejection\_sampling@{rejection\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{rejection\_sampling()}{rejection\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::rejection\+\_\+sampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates random points using rejection sampling based on a user-\/defined density function. 

This function uniformly samples candidate points within the given axis-\/aligned bounds and retains them based on the output of a user-\/provided density function. The {\ttfamily density\+\_\+fn} should return a probability in the range \mbox{[}0, 1\mbox{]} for each point.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions. \\
\hline
{\em Density\+Fn} & Callable with signature T(\+Point$<$\+T, N$>$) returning a probability in \mbox{[}0, 1\mbox{]}.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Desired number of accepted points. \\
\hline
{\em axis\+\_\+ranges} & Ranges for each axis in the form of an array of (min, max) pairs. \\
\hline
{\em density\+\_\+fn} & Function that returns a probability for accepting a point. \\
\hline
{\em seed} & Optional seed for reproducibility.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of accepted points based on rejection sampling.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argumentifanyaxisrangeis} & invalid (min \texorpdfstring{$>$}{>} max).\\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceps_autotoc_md9}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md9}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{rejection__sampling_8hpp}{point\_sampler/rejection\_sampling.hpp}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{float}\ radial\_density(\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{float}\ r2\ =\ p[0]\ *\ p[0]\ +\ p[1]\ *\ p[1];}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::exp(-\/r2);\ \textcolor{comment}{//\ higher\ near\ origin,\ drops\ with\ radius}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()\ \{}
\DoxyCodeLine{\ \ \ \ std::array<std::pair<float,\ float>,\ 2>\ bounds\ =\ \{\ \{\ \{-\/2.0f,\ 2.0f\},}
\DoxyCodeLine{\{-\/2.0f,\ 2.0f\}\ \}\ \};}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ pts\ =\ ps::rejection\_sampling<float,\ 2>(1000,\ bounds,\ radial\_density,}
\DoxyCodeLine{42);}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Generated\ "{}}\ <<\ pts.size()\ <<\ \textcolor{stringliteral}{"{}\ points.\(\backslash\)n"{}};}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Rejection sampling can be inefficient if {\ttfamily density\+\_\+fn} returns low values over most of the domain, as many candidate samples will be discarded. 
\end{DoxyNote}
\Hypertarget{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18}\label{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18} 
\index{ps@{ps}!relaxation\_ktree@{relaxation\_ktree}}
\index{relaxation\_ktree@{relaxation\_ktree}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{relaxation\_ktree()}{relaxation\_ktree()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::relaxation\+\_\+ktree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{size\+\_\+t}]{k\+\_\+neighbors = {\ttfamily 8},  }\item[{T}]{step\+\_\+size = {\ttfamily T(0.1)},  }\item[{size\+\_\+t}]{iterations = {\ttfamily 10} }\end{DoxyParamCaption})}



Relax a point set using a k-\/nearest neighbor repulsion algorithm with a KD-\/tree. 

This function performs iterative relaxation on a set of N-\/dimensional points by pushing each point away from its nearest neighbors. It uses a KD-\/tree for efficient neighbor lookup. The goal is to reduce clustering and obtain a more uniform or blue-\/noise-\/like distribution.

Each point is offset based on inverse-\/distance-\/weighted repulsion from its k-\/nearest neighbors, normalized and scaled by a step size. The point set is updated over a number of iterations.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & The point set to relax. This vector will be modified in place. \\
\hline
\mbox{\texttt{ in}}  & {\em k\+\_\+neighbors} & Number of neighbors to consider (default is 8). \\
\hline
\mbox{\texttt{ in}}  & {\em step\+\_\+size} & How far to move a point per iteration (default is 0.\+1). \\
\hline
\mbox{\texttt{ in}}  & {\em iterations} & Number of relaxation iterations (default is 10).\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The KD-\/tree is rebuilt on each iteration to reflect the updated positions.
\end{DoxyNote}
\hypertarget{namespaceps_autotoc_md10}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md10}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{relaxation_8hpp}{point\_sampler/relaxation.hpp}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<Point<float,\ 2>>\ pts\ =\ generate\_random\_points<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 1000,\ \{\ \{\ \{0.f,\ 1.f\},\ \{0.f,\ 1.f\}\ \}\ \},\ 42);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Apply\ 10\ iterations\ of\ relaxation\ relaxation\_ktree<float,\ 2>(pts,\ 8,\ 0.1f,}}
\DoxyCodeLine{10);}

\end{DoxyCode}
\hypertarget{namespaceps_autotoc_md11}{}\doxysubsubsubsection{\texorpdfstring{How it works\+:}{How it works:}}\label{namespaceps_autotoc_md11}

\begin{DoxyItemize}
\item For each point\+:
\begin{DoxyItemize}
\item Find its {\ttfamily k\+\_\+neighbors} nearest neighbors using a KD-\/tree.
\item Compute offset vectors from the current point to each neighbor.
\item Weight the vectors by the inverse square distance (stronger push from closer neighbors).
\item Accumulate the offset, normalize, and scale by {\ttfamily step\+\_\+size}.
\item Apply the movement to each point.
\end{DoxyItemize}
\item Repeat for {\ttfamily iterations} steps. 
\end{DoxyItemize}\Hypertarget{namespaceps_a7addf1455112b7895f8de7c475eed850}\label{namespaceps_a7addf1455112b7895f8de7c475eed850} 
\index{ps@{ps}!rescale\_points@{rescale\_points}}
\index{rescale\_points@{rescale\_points}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{rescale\_points()}{rescale\_points()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::rescale\+\_\+points (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges }\end{DoxyParamCaption})}



Rescales normalized points (in \mbox{[}0, 1\mbox{]}) to specified axis-\/aligned ranges. 

Each coordinate in every point is mapped from \mbox{[}0, 1\mbox{]} to a new range defined per axis. This is useful after generating normalized samples (e.\+g., Poisson disk, jittered grid).


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float, double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & Vector of normalized points to be modified in-\/place. \\
\hline
\mbox{\texttt{ in}}  & {\em ranges} & Target value ranges for each dimension.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\},\ \{0.5f,}
\DoxyCodeLine{0.5f\}\ \};}
\DoxyCodeLine{ps::rescale\_points<float,\ 2>(pts,\ \{\ \{\ \{10.f,\ 20.f\},\ \{100.f,\ 200.f\}\ \}\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ pts\ is\ now\ \{\ \{10.f,\ 100.f\},\ \{20.f,\ 200.f\},\ \{15.f,\ 150.f\}\ \}}}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Assumes points are in \mbox{[}0, 1\mbox{]}\texorpdfstring{$^\wedge$}{\string^}N. Does not check bounds. 
\end{DoxyNote}
\Hypertarget{namespaceps_a802637e81218193c0e65266c8075f002}\label{namespaceps_a802637e81218193c0e65266c8075f002} 
\index{ps@{ps}!save\_points\_to\_csv@{save\_points\_to\_csv}}
\index{save\_points\_to\_csv@{save\_points\_to\_csv}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{save\_points\_to\_csv()}{save\_points\_to\_csv()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
bool ps\+::save\+\_\+points\+\_\+to\+\_\+csv (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{bool}]{write\+\_\+header = {\ttfamily true} }\end{DoxyParamCaption})}



Save a set of N-\/dimensional points to a CSV file. 

The output file will contain one point per line, with each coordinate separated by commas. Optionally, a header row ("{}x0,x1,...,x\+N"{}) can be written as the first line.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em filename} & Path to the output CSV file. \\
\hline
{\em points} & Vector of points to be saved. \\
\hline
{\em write\+\_\+header} & If true, writes a header row with column names ("{}x0,x1,..."{}).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the file was successfully written, false otherwise. 
\end{DoxyReturn}
\Hypertarget{namespaceps_af6737277b9cc05d5f2ab248f17baea3b}\label{namespaceps_af6737277b9cc05d5f2ab248f17baea3b} 
\index{ps@{ps}!split\_by\_dimension@{split\_by\_dimension}}
\index{split\_by\_dimension@{split\_by\_dimension}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{split\_by\_dimension()}{split\_by\_dimension()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::array$<$ std\+::vector$<$ T $>$, N $>$ ps\+::split\+\_\+by\+\_\+dimension (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points }\end{DoxyParamCaption})}



Rearranges a list of N-\/dimensional points into N separate coordinate vectors. 

This function decomposes a vector of N-\/dimensional points into N vectors, where each vector contains all the values from one coordinate dimension. Useful for plotting or statistical analysis.

For example, given 3D points\+: \mbox{[}(1,2,3), (4,5,6), (7,8,9)\mbox{]}, the result will be\+:
\begin{DoxyItemize}
\item dimension 0\+: \mbox{[}1, 4, 7\mbox{]}
\item dimension 1\+: \mbox{[}2, 5, 8\mbox{]}
\item dimension 2\+: \mbox{[}3, 6, 9\mbox{]}
\end{DoxyItemize}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of N-\/dimensional points.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of N vectors, each containing the values for one coordinate axis. 
\end{DoxyReturn}
