\doxysection{ps Namespace Reference}
\hypertarget{namespaceps}{}\label{namespaceps}\index{ps@{ps}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}
\item 
struct \mbox{\hyperlink{structps_1_1Point}{Point}}
\begin{DoxyCompactList}\small\item\em A fixed-\/size N-\/dimensional point/vector class. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\using \mbox{\hyperlink{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}{KDTree}} = nanoflann\+::\+KDTree\+Single\+Index\+Adaptor$<$ nanoflann\+::\+L2\+\_\+\+Simple\+\_\+\+Adaptor$<$ T, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$ T, N $>$ $>$, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$ T, N $>$, N $>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94}{distance\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, T min\+\_\+dist)
\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N, typename Scale\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_af23d114903fd5cb3ccb19d3e64183632}{distance\+\_\+rejection\+\_\+filter\+\_\+warped}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, T base\+\_\+min\+\_\+dist, Scale\+Fn scale\+\_\+fn)
\begin{DoxyCompactList}\small\item\em Filters points based on spatially-\/varying minimal distance constraints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a0e4055582214237ee9f21369133e6194}{function\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Filters points based on a spatial probability (density) function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}{gaussian\+\_\+clusters}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ cluster\+\_\+centers, size\+\_\+t points\+\_\+per\+\_\+cluster, T spread, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates clustered points around provided cluster centers using a Gaussian distribution. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d}{gaussian\+\_\+clusters}} (size\+\_\+t cluster\+\_\+count, size\+\_\+t points\+\_\+per\+\_\+cluster, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, T spread, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates clustered points around random centers uniformly sampled in a bounding box. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_aa8c3b3b3367276f9a194938599d2463b}{halton\+\_\+sequence}} (size\+\_\+t count, size\+\_\+t shift)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a81b18395a05f0bb4d483406e79aa9524}{halton}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a set of quasi-\/random points using the Halton sequence in N dimensions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3}{hammersley\+\_\+sequence}} (size\+\_\+t count, size\+\_\+t shift)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6}{hammersley}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a set of quasi-\/random points using the Hammersley sequence in N dimensions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a932640b18d76a7e336fc760e9cf5511b}{importance\+\_\+resampling}} (size\+\_\+t count, size\+\_\+t oversampling\+\_\+ratio, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a point set via importance resampling from a quasi-\/random oversampled grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}{jittered\+\_\+grid}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, const std\+::array$<$ T, N $>$ \&jitter\+\_\+amount, const std\+::array$<$ T, N $>$ \&stagger\+\_\+ratio, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a point set on a jittered and optionally staggered grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ae90df8db8e751ff4b61298114f092714}{jittered\+\_\+grid}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a jittered grid of points with full jitter and no stagger. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::pair$<$ std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$, std\+::vector$<$ size\+\_\+t $>$ $>$ \mbox{\hyperlink{namespaceps_ac0a1fb7adf634a6a0137cd041c54b0a3}{kmeans\+\_\+cluster}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, size\+\_\+t k\+\_\+clusters, bool normalize\+\_\+data=true, size\+\_\+t max\+\_\+iterations=100)
\begin{DoxyCompactList}\small\item\em Perform k-\/means clustering on a set of points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0}{latin\+\_\+hypercube\+\_\+sampling}} (std\+::size\+\_\+t sample\+\_\+count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::pair$<$ std\+::vector$<$ T $>$, std\+::vector$<$ T $>$ $>$ \mbox{\hyperlink{namespaceps_ae96771d03336a56988d82df95e8a797a}{angle\+\_\+distribution\+\_\+neighbors}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, T bin\+\_\+width, size\+\_\+t k\+\_\+neighbors=8)
\begin{DoxyCompactList}\small\item\em Compute the angular distribution function (ADF) using nearest neighbors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespaceps_a9a824a8963ef7b15c01da0f1f9c90eee}{distance\+\_\+to\+\_\+boundary}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges)
\begin{DoxyCompactList}\small\item\em Compute the distance of each point to the domain boundary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespaceps_a91a0bac33731ed899845c6081c117db2}{first\+\_\+neighbor\+\_\+distance\+\_\+squared}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points)
\begin{DoxyCompactList}\small\item\em Computes the squared distance to the nearest neighbor for each point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \mbox{\hyperlink{namespaceps_ac29744e12116f882d8a620a3fd02d72d}{nearest\+\_\+neighbors\+\_\+indices}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, size\+\_\+t k\+\_\+neighbors=8)
\begin{DoxyCompactList}\small\item\em Finds the nearest neighbors for each point in a set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::pair$<$ std\+::vector$<$ T $>$, std\+::vector$<$ T $>$ $>$ \mbox{\hyperlink{namespaceps_a8d80a56ea4774726e748b48e1ecf0a8d}{radial\+\_\+distribution}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, T bin\+\_\+width, T max\+\_\+distance)
\begin{DoxyCompactList}\small\item\em Compute the normalized radial distribution function g(r). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0}{operator+}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1}{operator-\/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b}{operator\texorpdfstring{$\ast$}{*}}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a585704d3f738c5eb899810fc9308a60e}{operator/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a366ef094d65da865384b6fb77aac5d5f}{operator+}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f}{operator-\/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_acd4dc781f43ba8a50daa139682846d4b}{operator\texorpdfstring{$\ast$}{*}}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580}{operator/}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T scalar)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4}{operator\texorpdfstring{$\ast$}{*}}} (T scalar, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_afe774cb61bde6358f8a7024c42db9804}{operator+}} (T scalar, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_ace7642868199df621df9139e5179767b}{dot}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_a7c3e161560ad3000aa4e2218291b169c}{length\+\_\+squared}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746}{length}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a7de6090e2c8291401816be9bc6cda914}{normalized}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808}{distance\+\_\+squared}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\T \mbox{\hyperlink{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11}{distance}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa}{lerp}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&a, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&b, T t)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_adb0bd4806c7e79eddef0e1263740ae28}{clamp}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T min\+\_\+val, T max\+\_\+val)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ }\\bool \mbox{\hyperlink{namespaceps_aedb5908eae325f054e4f3dd6b9b223af}{in\+\_\+neighborhood}} (const \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}$<$ T, N $>$ \&grid, const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&p, T base\+\_\+min\+\_\+dist, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, Scale\+Fn scale\+\_\+fn)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \mbox{\hyperlink{namespaceps_a898bca65491a14a41bfdd50fdc6230b8}{generate\+\_\+random\+\_\+point\+\_\+around}} (const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&center, T base\+\_\+min\+\_\+dist, std\+::mt19937 \&gen, std\+::function$<$ T(const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&)$>$ scale\+\_\+fn)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8}{poisson\+\_\+disk\+\_\+sampling}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, T base\+\_\+min\+\_\+dist, Scale\+Fn scale\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt, size\+\_\+t new\+\_\+points\+\_\+attempts=30)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e}{poisson\+\_\+disk\+\_\+sampling\+\_\+uniform}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges, T base\+\_\+min\+\_\+dist, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt, size\+\_\+t new\+\_\+points\+\_\+attempts=30)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69}{random}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates a specified number of uniformly distributed random points in N-\/dimensional space. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{random\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, std\+::size\+\_\+t target\+\_\+count)
\begin{DoxyCompactList}\small\item\em Randomly retains a fixed number of points from the input set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a66183362443c104da098224df9bcd2a1}{random\+\_\+rejection\+\_\+filter}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, float keep\+\_\+fraction)
\begin{DoxyCompactList}\small\item\em Randomly retains a fraction of the input points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df}{filter\+\_\+points\+\_\+in\+\_\+range}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges)
\begin{DoxyCompactList}\small\item\em Filters points that lie within the specified axis-\/aligned bounding box. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N, typename Func $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a5350b843397a5bf2a748115108ffa21a}{filter\+\_\+points\+\_\+function}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, Func fn)
\begin{DoxyCompactList}\small\item\em Filters points using a user-\/provided function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862}{refit\+\_\+points\+\_\+to\+\_\+range}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&target\+\_\+ranges)
\begin{DoxyCompactList}\small\item\em Linearly remap a set of points to fit within the specified axis-\/aligned ranges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_a7addf1455112b7895f8de7c475eed850}{rescale\+\_\+points}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&ranges)
\begin{DoxyCompactList}\small\item\em Rescales normalized points (in \mbox{[}0, 1\mbox{]}) to specified axis-\/aligned ranges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527}{rejection\+\_\+sampling}} (size\+\_\+t count, const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&axis\+\_\+ranges, Density\+Fn density\+\_\+fn, std\+::optional$<$ unsigned int $>$ seed=std\+::nullopt)
\begin{DoxyCompactList}\small\item\em Generates random points using rejection sampling based on a user-\/defined density function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18}{relaxation\+\_\+ktree}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, size\+\_\+t k\+\_\+neighbors=8, T step\+\_\+size=T(0.\+1), size\+\_\+t iterations=10)
\begin{DoxyCompactList}\small\item\em Relax a point set using a k-\/nearest neighbor repulsion algorithm with a KD-\/tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\bool \mbox{\hyperlink{namespaceps_a802637e81218193c0e65266c8075f002}{save\+\_\+points\+\_\+to\+\_\+csv}} (const std\+::string \&filename, const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, bool write\+\_\+header=true)
\begin{DoxyCompactList}\small\item\em Save a set of N-\/dimensional points to a CSV file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceps_a5b92b660faab5030374ba2dee9f89810}{save\+\_\+vector\+\_\+to\+\_\+csv}} (const std\+::string \&filename, const std\+::vector$<$ T $>$ \&values, bool write\+\_\+header=true, const std\+::string \&header\+\_\+name="{}value"{})
\begin{DoxyCompactList}\small\item\em Save a 1D vector of values to a CSV file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N+1 $>$ $>$ \mbox{\hyperlink{namespaceps_a964f314c19f0b1300d513bce618c5954}{add\+\_\+dimension}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points, const std\+::vector$<$ T $>$ \&new\+\_\+dimension)
\begin{DoxyCompactList}\small\item\em Add a new dimension to a set of points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \mbox{\hyperlink{namespaceps_a677f90d97b1dcfeaa2ecc299ee37f5bf}{merge\+\_\+by\+\_\+dimension}} (const std\+::array$<$ std\+::vector$<$ T $>$, N $>$ \&components)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespaceps_a172358f05108b5cabdac4e43ab309ab2}{normalize\+\_\+points}} (std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points)
\begin{DoxyCompactList}\small\item\em Normalize the coordinates of a set of points along each axis to the range \mbox{[}0, 1\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::array$<$ std\+::vector$<$ T $>$, N $>$ \mbox{\hyperlink{namespaceps_af6737277b9cc05d5f2ab248f17baea3b}{split\+\_\+by\+\_\+dimension}} (const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&points)
\begin{DoxyCompactList}\small\item\em Rearranges a list of N-\/dimensional points into N separate coordinate vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\Hypertarget{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}\label{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a} 
\index{ps@{ps}!KDTree@{KDTree}}
\index{KDTree@{KDTree}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{KDTree}{KDTree}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
using \mbox{\hyperlink{namespaceps_ac9ecfd54020ea95c133d1fc99cf4f75a}{ps\+::\+KDTree}} = typedef nanoflann\+::\+KDTree\+Single\+Index\+Adaptor$<$ nanoflann\+::\+L2\+\_\+\+Simple\+\_\+\+Adaptor$<$T, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$T, N$>$ $>$, \mbox{\hyperlink{structps_1_1PointCloudAdaptor}{Point\+Cloud\+Adaptor}}$<$T, N$>$, N$>$}



\doxysubsection{Function Documentation}
\Hypertarget{namespaceps_a964f314c19f0b1300d513bce618c5954}\label{namespaceps_a964f314c19f0b1300d513bce618c5954} 
\index{ps@{ps}!add\_dimension@{add\_dimension}}
\index{add\_dimension@{add\_dimension}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{add\_dimension()}{add\_dimension()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N+1 $>$ $>$ ps\+::add\+\_\+dimension (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::vector$<$ T $>$ \&}]{new\+\_\+dimension }\end{DoxyParamCaption})}



Add a new dimension to a set of points. 

This function takes a vector of points of dimension N and appends a new coordinate to each point, producing a new vector of points of dimension N+1.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type of the coordinates (e.\+g., float, double, int). \\
\hline
{\em N} & Current number of dimensions in the input points. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of input points of dimension N. \\
\hline
{\em new\+\_\+dimension} & Vector of values for the new dimension. Must have the same size as {\ttfamily points}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of points of dimension N+1, with the new dimension appended.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+errorifthesizeof\`{}points\`{}and\`{}new\+\_\+dimension\`{}donotmatch.} & \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
This function creates a new vector of points with an increased dimension count, since the type Point$<$\+T, N$>$ is distinct from \doxylink{structps_1_1Point}{Point}\texorpdfstring{$<$}{<}T, N+1\texorpdfstring{$>$}{>}.
\end{DoxyNote}
{\bfseries{Example usage\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ points\ =\ \{\ \{\{1.0f,\ 2.0f\}\},\ \{\{3.0f,\ 4.0f\}\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{std::vector<float>\ z\_values\ =\ \{\ 10.0f,\ 20.0f\ \};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ points3D\ =\ \mbox{\hyperlink{namespaceps_a964f314c19f0b1300d513bce618c5954}{add\_dimension}}(points,\ z\_values);}
\DoxyCodeLine{\textcolor{comment}{//\ points3D\ now\ contains\ \{\{1.0f,\ 2.0f,\ 10.0f\}\},\ \{\{3.0f,\ 4.0f,\ 20.0f\}\}}}

\end{DoxyCode}
 \Hypertarget{namespaceps_ae96771d03336a56988d82df95e8a797a}\label{namespaceps_ae96771d03336a56988d82df95e8a797a} 
\index{ps@{ps}!angle\_distribution\_neighbors@{angle\_distribution\_neighbors}}
\index{angle\_distribution\_neighbors@{angle\_distribution\_neighbors}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{angle\_distribution\_neighbors()}{angle\_distribution\_neighbors()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::pair$<$ std\+::vector$<$ T $>$, std\+::vector$<$ T $>$ $>$ ps\+::angle\+\_\+distribution\+\_\+neighbors (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{T}]{bin\+\_\+width,  }\item[{size\+\_\+t}]{k\+\_\+neighbors = {\ttfamily 8} }\end{DoxyParamCaption})}



Compute the angular distribution function (ADF) using nearest neighbors. 

The angular distribution function (ADF) measures the distribution of bond angles formed by a point and pairs of its nearest neighbors.


\begin{DoxyItemize}
\item Flat distribution → random uniform points.
\item Peaks at characteristic angles → local order (e.\+g. hexagonal lattice peaks at 60°).
\item Depletions → angular avoidance due to constraints or repulsion.
\end{DoxyItemize}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (float, double, ...) \\
\hline
{\em N} & Dimension of points (N \texorpdfstring{$>$}{>}= 2) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of points \\
\hline
{\em bin\+\_\+width} & Width of angle bins (in radians) \\
\hline
{\em k\+\_\+neighbors} & Number of neighbors used for angle calculation (default\+: 8) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::pair\texorpdfstring{$<$}{<}std\+::vector$<$\+T$>$, std\+::vector$<$\+T$>$\texorpdfstring{$>$}{>}
\begin{DoxyItemize}
\item First\+: bin centers (angles in radians)
\item Second\+: normalized ADF values
\end{DoxyItemize}
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md8}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md8}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<double,\ 2>>\ pts\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.0,\ 0.0\},\ \{1.0,\ 0.0\},\ \{0.0,\ 1.0\},\ \{1.0,\ 1.0\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ [theta,\ g\_theta]\ =\ \mbox{\hyperlink{namespaceps_ae96771d03336a56988d82df95e8a797a}{angle\_distribution\_neighbors}}(pts,\ 0.1,\ 6);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ theta.size();\ ++i)\ std::cout\ <<\ \textcolor{stringliteral}{"{}θ="{}}\ <<\ theta[i]\ <<\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{\textcolor{stringliteral}{g(θ)="{}}\ <<\ g\_theta[i]\ <<\ std::endl;}

\end{DoxyCode}
 \Hypertarget{namespaceps_adb0bd4806c7e79eddef0e1263740ae28}\label{namespaceps_adb0bd4806c7e79eddef0e1263740ae28} 
\index{ps@{ps}!clamp@{clamp}}
\index{clamp@{clamp}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{clamp()}{clamp()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::clamp (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{min\+\_\+val,  }\item[{T}]{max\+\_\+val }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11}\label{namespaceps_ac0b74f22d427d199ab0df8f6942d3b11} 
\index{ps@{ps}!distance@{distance}}
\index{distance@{distance}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance()}{distance()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::distance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94}\label{namespaceps_ad1f4a1110a40bf1c6a687182db6b4b94} 
\index{ps@{ps}!distance\_rejection\_filter@{distance\_rejection\_filter}}
\index{distance\_rejection\_filter@{distance\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_rejection\_filter()}{distance\_rejection\_filter()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::distance\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{T}]{min\+\_\+dist }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_af23d114903fd5cb3ccb19d3e64183632}\label{namespaceps_af23d114903fd5cb3ccb19d3e64183632} 
\index{ps@{ps}!distance\_rejection\_filter\_warped@{distance\_rejection\_filter\_warped}}
\index{distance\_rejection\_filter\_warped@{distance\_rejection\_filter\_warped}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_rejection\_filter\_warped()}{distance\_rejection\_filter\_warped()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N, typename Scale\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::distance\+\_\+rejection\+\_\+filter\+\_\+warped (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{Scale\+Fn}]{scale\+\_\+fn }\end{DoxyParamCaption})}



Filters points based on spatially-\/varying minimal distance constraints. 

A scale function is used to modulate the minimum allowed distance for each point. The base distance {\ttfamily base\+\_\+min\+\_\+dist} is scaled by the value returned by {\ttfamily scale\+\_\+fn(p)}, allowing for adaptive sampling densities.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Scale\+Fn} & Callable returning a scalar scale factor for a given point\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of candidate points \\
\hline
{\em base\+\_\+min\+\_\+dist} & Base minimum allowed distance \\
\hline
{\em scale\+\_\+fn} & Function providing a local scale factor per point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A filtered set of points with variable spacing
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md0}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md0}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ scale\_fn\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0.5f\ +\ 0.5f\ *\ std::sin(p[0]\ *\ 3.1415f);\ \textcolor{comment}{//\ Varies\ between\ 0.5\ and}}
\DoxyCodeLine{1}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<Point<float,\ 2>>\ pts\ =\ ps::random<float,\ 2>(1000,\ \{\{0,1\},\{0,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ \mbox{\hyperlink{namespaceps_af23d114903fd5cb3ccb19d3e64183632}{ps::distance\_rejection\_filter\_warped}}(pts,\ 0.05f,\ scale\_fn);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808}\label{namespaceps_aecf2b150ec16bf286e6a7b462c4d5808} 
\index{ps@{ps}!distance\_squared@{distance\_squared}}
\index{distance\_squared@{distance\_squared}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_squared()}{distance\_squared()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::distance\+\_\+squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a9a824a8963ef7b15c01da0f1f9c90eee}\label{namespaceps_a9a824a8963ef7b15c01da0f1f9c90eee} 
\index{ps@{ps}!distance\_to\_boundary@{distance\_to\_boundary}}
\index{distance\_to\_boundary@{distance\_to\_boundary}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{distance\_to\_boundary()}{distance\_to\_boundary()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ T $>$ ps\+::distance\+\_\+to\+\_\+boundary (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges }\end{DoxyParamCaption})}



Compute the distance of each point to the domain boundary. 

The domain is defined by axis-\/aligned ranges in each dimension. For each point, the returned distance is the smallest Euclidean distance to any boundary plane of the domain.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Floating point type. \\
\hline
{\em N} & Dimensionality of the points. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of points to evaluate. \\
\hline
{\em axis\+\_\+ranges} & Vector of size N, where each element is a std\+::pair\texorpdfstring{$<$}{<}min, max\texorpdfstring{$>$}{>} defining the domain limits in that dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+T$>$ Distances of each point to the nearest domain boundary.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This assumes the domain is a rectangular box aligned with the coordinate axes.
\end{DoxyNote}
{\bfseries{Example\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<double,\ 2>>\ pts\ =\ \{\ \{0.2,\ 0.8\},\ \{0.9,\ 0.1\}\ \};}
\DoxyCodeLine{std::vector<std::pair<double,\ double>>\ ranges\ =\ \{\ \{0.0,\ 1.0\},\ \{0.0,\ 1.0\}\ \};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ distances\ =\ \mbox{\hyperlink{namespaceps_a9a824a8963ef7b15c01da0f1f9c90eee}{distance\_to\_boundary}}(pts,\ ranges);}
\DoxyCodeLine{\textcolor{comment}{//\ distances[0]\ -\/>\ 0.2}}
\DoxyCodeLine{\textcolor{comment}{//\ distances[1]\ -\/>\ 0.1}}

\end{DoxyCode}
 \Hypertarget{namespaceps_ace7642868199df621df9139e5179767b}\label{namespaceps_ace7642868199df621df9139e5179767b} 
\index{ps@{ps}!dot@{dot}}
\index{dot@{dot}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::dot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a5350b843397a5bf2a748115108ffa21a}\label{namespaceps_a5350b843397a5bf2a748115108ffa21a} 
\index{ps@{ps}!filter\_points\_function@{filter\_points\_function}}
\index{filter\_points\_function@{filter\_points\_function}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{filter\_points\_function()}{filter\_points\_function()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N, typename Func $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::filter\+\_\+points\+\_\+function (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{Func}]{fn }\end{DoxyParamCaption})}



Filters points using a user-\/provided function. 

Keeps only the points for which the provided function {\ttfamily fn(p)} does not return zero. This can be used to apply custom masks, implicit surface functions, etc.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates. \\
\hline
{\em N} & Number of dimensions. \\
\hline
{\em Func} & Callable that takes a Point$<$\+T, N$>$ and returns a value convertible to T.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of input points. \\
\hline
{\em fn} & Unary function that returns a non-\/zero value if the point should be kept.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of filtered points.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\},\ \{2.f,\ 2.f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ ps::filter\_points\_function<float,\ 2>(pts,\ [](\textcolor{keyword}{const}}
\DoxyCodeLine{Point<float,\ 2>\ \&p)\ \{\ \textcolor{keywordflow}{return}\ (p[0]\ +\ p[1]\ <\ 2.5f)\ ?\ 1.f\ :\ 0.f;\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ Keeps\ only\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\}\ \}}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df}\label{namespaceps_a9c8c5679d987d3023b9d3beffd81e6df} 
\index{ps@{ps}!filter\_points\_in\_range@{filter\_points\_in\_range}}
\index{filter\_points\_in\_range@{filter\_points\_in\_range}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{filter\_points\_in\_range()}{filter\_points\_in\_range()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::filter\+\_\+points\+\_\+in\+\_\+range (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges }\end{DoxyParamCaption})}



Filters points that lie within the specified axis-\/aligned bounding box. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of input points to filter. \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box ranges for each dimension (inclusive).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector containing only the points that lie within all specified axis ranges.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argumentifaxis\+\_\+rangesareill-\/formed(e.\+g.,min} & \texorpdfstring{$>$}{>} max).\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.5f,\ 0.5f\},\ \{2.f,\ 3.f\},\ \{-\/1.f,}
\DoxyCodeLine{0.f\}\ \};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ filtered\ =\ ps::filter\_points\_in\_range<float,\ 2>(pts,\ \{\ \{\{0.f,\ 1.f\},}
\DoxyCodeLine{\{0.f,\ 1.f\}\}\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ filtered\ now\ contains\ only\ \{\ \{0.5f,\ 0.5f\}\ \}}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a91a0bac33731ed899845c6081c117db2}\label{namespaceps_a91a0bac33731ed899845c6081c117db2} 
\index{ps@{ps}!first\_neighbor\_distance\_squared@{first\_neighbor\_distance\_squared}}
\index{first\_neighbor\_distance\_squared@{first\_neighbor\_distance\_squared}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{first\_neighbor\_distance\_squared()}{first\_neighbor\_distance\_squared()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ T $>$ ps\+::first\+\_\+neighbor\+\_\+distance\+\_\+squared (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points }\end{DoxyParamCaption})}



Computes the squared distance to the nearest neighbor for each point. 

This function builds a KD-\/tree from a given set of N-\/dimensional points and computes, for each point, the squared distance to its closest neighbor.

The KD-\/tree search uses {\ttfamily nanoflann} for efficient nearest neighbor queries.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of N-\/dimensional points. Note\+:\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} This vector is passed by non-\/const reference because the KD-\/tree adaptor may require mutable access, but the function does not modify the contents.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector containing the squared distances to the first neighbor for each point, in the same order as the input points.
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Example\ usage:}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <array>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using\ }Point3f\ =\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 3>}};}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<Point3f>\ points\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.0f,\ 0.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{1.0f,\ 0.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{0.0f,\ 1.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{1.0f,\ 1.0f,\ 0.0f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<float>\ distances\_sq\ =\ \mbox{\hyperlink{namespaceps_a91a0bac33731ed899845c6081c117db2}{first\_neighbor\_distance\_squared}}(points);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ distances\_sq[i]\ contains\ the\ squared\ distance\ to\ the\ closest\ neighbor\ of}}
\DoxyCodeLine{points[i].}

\end{DoxyCode}
 \Hypertarget{namespaceps_a0e4055582214237ee9f21369133e6194}\label{namespaceps_a0e4055582214237ee9f21369133e6194} 
\index{ps@{ps}!function\_rejection\_filter@{function\_rejection\_filter}}
\index{function\_rejection\_filter@{function\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{function\_rejection\_filter()}{function\_rejection\_filter()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::function\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Filters points based on a spatial probability (density) function. 

Each point is accepted with a probability given by {\ttfamily density\+\_\+fn(p)}, which should return a value in \mbox{[}0, 1\mbox{]}. This is useful for sampling from a non-\/uniform spatial distribution.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Density\+Fn} & Callable type with signature {\ttfamily T(const \doxylink{structps_1_1Point}{Point}\texorpdfstring{$<$}{<}T, N\texorpdfstring{$>$}{>}\&)} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input candidate points \\
\hline
{\em density\+\_\+fn} & Function returning acceptance probability for each point \\
\hline
{\em seed} & Optional random seed for reproducibility \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ of accepted points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ field\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ 0.5f\ +\ 0.5f\ *\ std::sin(p[0]\ *\ 10.0f);\ \textcolor{comment}{//\ Spatial\ density}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ accepted\ =\ \mbox{\hyperlink{namespaceps_a0e4055582214237ee9f21369133e6194}{ps::function\_rejection\_filter}}(pts,\ field);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d}\label{namespaceps_a0efaff8017d5a171ffdf0ed0201bd65d} 
\index{ps@{ps}!gaussian\_clusters@{gaussian\_clusters}}
\index{gaussian\_clusters@{gaussian\_clusters}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{gaussian\_clusters()}{gaussian\_clusters()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::gaussian\+\_\+clusters (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{cluster\+\_\+count,  }\item[{size\+\_\+t}]{points\+\_\+per\+\_\+cluster,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{T}]{spread,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates clustered points around random centers uniformly sampled in a bounding box. 

Cluster centers are randomly sampled within the provided {\ttfamily axis\+\_\+ranges}, and each cluster then has {\ttfamily points\+\_\+per\+\_\+cluster} points sampled from a Gaussian distribution centered at the cluster\textquotesingle{}s location, with a specified standard deviation {\ttfamily spread}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cluster\+\_\+count} & Number of cluster centers to generate \\
\hline
{\em points\+\_\+per\+\_\+cluster} & Number of points per cluster \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box ranges for each dimension \\
\hline
{\em spread} & Standard deviation of the Gaussian spread \\
\hline
{\em seed} & Optional random seed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of clustered points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md2}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md2}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ clustered\ =\ ps::gaussian\_clusters<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 5,\ 100,}
\DoxyCodeLine{\ \ \ \ \{\{\{0,1\},\ \{0,1\}\}\},\ 0.03f}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}\label{namespaceps_a913ab9d687ee42d04488e5eb0373e23a} 
\index{ps@{ps}!gaussian\_clusters@{gaussian\_clusters}}
\index{gaussian\_clusters@{gaussian\_clusters}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{gaussian\_clusters()}{gaussian\_clusters()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::gaussian\+\_\+clusters (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$}]{cluster\+\_\+centers,  }\item[{size\+\_\+t}]{points\+\_\+per\+\_\+cluster,  }\item[{T}]{spread,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates clustered points around provided cluster centers using a Gaussian distribution. 

For each cluster center, this function generates {\ttfamily points\+\_\+per\+\_\+cluster} points where each coordinate is sampled from a normal distribution centered at the coordinate of the cluster center with standard deviation {\ttfamily spread}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cluster\+\_\+centers} & A vector of cluster center points \\
\hline
{\em points\+\_\+per\+\_\+cluster} & Number of points to generate per cluster \\
\hline
{\em spread} & Standard deviation of the Gaussian spread \\
\hline
{\em seed} & Optional random seed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of clustered points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md1}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md1}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ centers\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.2f,\ 0.2f\},}
\DoxyCodeLine{\ \ \ \ \{0.8f,\ 0.8f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ clustered\ =\ \mbox{\hyperlink{namespaceps_a913ab9d687ee42d04488e5eb0373e23a}{ps::gaussian\_clusters}}(centers,\ 100,\ 0.05f);}

\end{DoxyCode}
 \Hypertarget{namespaceps_a898bca65491a14a41bfdd50fdc6230b8}\label{namespaceps_a898bca65491a14a41bfdd50fdc6230b8} 
\index{ps@{ps}!generate\_random\_point\_around@{generate\_random\_point\_around}}
\index{generate\_random\_point\_around@{generate\_random\_point\_around}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{generate\_random\_point\_around()}{generate\_random\_point\_around()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::generate\+\_\+random\+\_\+point\+\_\+around (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{center,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{std\+::mt19937 \&}]{gen,  }\item[{std\+::function$<$ T(const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&)$>$}]{scale\+\_\+fn }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a81b18395a05f0bb4d483406e79aa9524}\label{namespaceps_a81b18395a05f0bb4d483406e79aa9524} 
\index{ps@{ps}!halton@{halton}}
\index{halton@{halton}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{halton()}{halton()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::halton (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a set of quasi-\/random points using the Halton sequence in N dimensions. 

This function generates {\ttfamily count} points in the unit hypercube using the Halton sequence, then rescales them to fit within the specified axis-\/aligned bounding box. An optional {\ttfamily seed} is used as a starting index offset (i.\+e., a shift) in the sequence to decorrelate multiple calls.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box for each dimension, as min/max pairs \\
\hline
{\em seed} & Optional seed that offsets the sequence start index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The generated Halton points rescaled to the bounding box
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md3}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md3}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ points\ =\ ps::halton<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 1000,}
\DoxyCodeLine{\ \ \ \ \{\{\{0,\ 1\},\ \{0,\ 1\}\}\},\ 42}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aa8c3b3b3367276f9a194938599d2463b}\label{namespaceps_aa8c3b3b3367276f9a194938599d2463b} 
\index{ps@{ps}!halton\_sequence@{halton\_sequence}}
\index{halton\_sequence@{halton\_sequence}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{halton\_sequence()}{halton\_sequence()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::halton\+\_\+sequence (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{shift }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6}\label{namespaceps_aad0cc7bc81f7cac9f0be26177b9986a6} 
\index{ps@{ps}!hammersley@{hammersley}}
\index{hammersley@{hammersley}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{hammersley()}{hammersley()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::hammersley (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a set of quasi-\/random points using the Hammersley sequence in N dimensions. 

This function generates {\ttfamily count} points in the unit hypercube using the Hammersley sequence, then rescales them to fit within the specified axis-\/aligned bounding box. An optional {\ttfamily seed} can be used as a starting index offset (i.\+e., a shift) to decorrelate multiple calls or introduce variation.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box for each dimension, as min/max pairs \\
\hline
{\em seed} & Optional seed that offsets the sequence start index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The generated Hammersley points rescaled to the bounding box
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md4}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ points\ =\ ps::hammersley<float,\ 3>(}
\DoxyCodeLine{\ \ \ \ 512,}
\DoxyCodeLine{\ \ \ \ \{\{\{-\/1,\ 1\},\ \{-\/1,\ 1\},\ \{0,\ 1\}\}\},\ 7}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3}\label{namespaceps_ae21a8c51533330ead4ebe76eed3e72b3} 
\index{ps@{ps}!hammersley\_sequence@{hammersley\_sequence}}
\index{hammersley\_sequence@{hammersley\_sequence}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{hammersley\_sequence()}{hammersley\_sequence()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::hammersley\+\_\+sequence (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{shift }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a932640b18d76a7e336fc760e9cf5511b}\label{namespaceps_a932640b18d76a7e336fc760e9cf5511b} 
\index{ps@{ps}!importance\_resampling@{importance\_resampling}}
\index{importance\_resampling@{importance\_resampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{importance\_resampling()}{importance\_resampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::importance\+\_\+resampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{size\+\_\+t}]{oversampling\+\_\+ratio,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a point set via importance resampling from a quasi-\/random oversampled grid. 

This function uses a Halton sequence to create an oversampled set of candidate points in the domain. Each point is assigned a weight based on the provided density function. A discrete distribution is then used to resample {\ttfamily count} points according to these weights.

The higher the {\ttfamily oversampling\+\_\+ratio}, the better the approximation to the target density, at the cost of performance.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
{\em Density\+Fn} & A callable with signature {\ttfamily T(const \doxylink{structps_1_1Point}{Point}\texorpdfstring{$<$}{<}T, N\texorpdfstring{$>$}{>}\&)} returning a non-\/negative density value \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to return after resampling \\
\hline
{\em oversampling\+\_\+ratio} & Number of candidate points to generate as a multiple of {\ttfamily count} \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the domain of the points \\
\hline
{\em density\+\_\+fn} & Function mapping a point to a (non-\/negative) density value \\
\hline
{\em seed} & Optional seed to control the random number generator \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ The resulting resampled point set
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md5}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ \textcolor{keyword}{auto}\ density\ =\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\ \&p)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::exp(-\/10.0f\ *\ (p[0]*p[0]\ +\ p[1]*p[1]));}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ points\ =\ ps::importance\_resampling<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 500,\ 5,}
\DoxyCodeLine{\ \ \ \ \{\{\{-\/1,\ 1\},\ \{-\/1,\ 1\}\}\},\ density,\ 42}
\DoxyCodeLine{);}

\end{DoxyCode}
 \Hypertarget{namespaceps_aedb5908eae325f054e4f3dd6b9b223af}\label{namespaceps_aedb5908eae325f054e4f3dd6b9b223af} 
\index{ps@{ps}!in\_neighborhood@{in\_neighborhood}}
\index{in\_neighborhood@{in\_neighborhood}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{in\_neighborhood()}{in\_neighborhood()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ \\
bool ps\+::in\+\_\+neighborhood (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1GridND}{Grid\+ND}}$<$ T, N $>$ \&}]{grid,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{Scale\+Fn}]{scale\+\_\+fn }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ad8525c124fef24618bf574b9b7b1ece8}\label{namespaceps_ad8525c124fef24618bf574b9b7b1ece8} 
\index{ps@{ps}!jittered\_grid@{jittered\_grid}}
\index{jittered\_grid@{jittered\_grid}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{jittered\_grid()}{jittered\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::jittered\+\_\+grid (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{const std\+::array$<$ T, N $>$ \&}]{jitter\+\_\+amount,  }\item[{const std\+::array$<$ T, N $>$ \&}]{stagger\+\_\+ratio,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a point set on a jittered and optionally staggered grid. 

This function divides the domain into a grid and places one point in each selected cell. Each point is jittered within its cell, and staggered offsets may be applied depending on the index of higher-\/dimensional axes. The result is a semi-\/regular sampling pattern with randomness.

Jittering prevents aliasing, and staggering introduces a controlled shift between alternating cells to improve uniformity and avoid alignment artifacts.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of output points (best effort, may be capped by total available cells) \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the sampling domain \\
\hline
{\em jitter\+\_\+amount} & Per-\/dimension jitter factor ∈ \mbox{[}0, 1\mbox{]}. A value of 1.\+0 means full jitter in the cell. \\
\hline
{\em stagger\+\_\+ratio} & Per-\/dimension stagger ratio, indicating how much to offset points based on higher dimension parity \\
\hline
{\em seed} & Optional seed for deterministic jittering and shuffling \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ Sampled points
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md6}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::array<std::pair<float,\ float>,\ 2>\ bounds\ =\ \{\{\{0.0f,\ 1.0f\},\ \{0.0f,}
\DoxyCodeLine{1.0f\}\}\};}
\DoxyCodeLine{std::array<float,\ 2>\ jitter\ =\ \{0.8f,\ 0.8f\};}
\DoxyCodeLine{std::array<float,\ 2>\ stagger\ =\ \{0.2f,\ 0.0f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ samples\ =\ ps::jittered\_grid<float,\ 2>(256,\ bounds,\ jitter,\ stagger,\ 42);}

\end{DoxyCode}
 \Hypertarget{namespaceps_ae90df8db8e751ff4b61298114f092714}\label{namespaceps_ae90df8db8e751ff4b61298114f092714} 
\index{ps@{ps}!jittered\_grid@{jittered\_grid}}
\index{jittered\_grid@{jittered\_grid}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{jittered\_grid()}{jittered\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::jittered\+\_\+grid (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a jittered grid of points with full jitter and no stagger. 

This overload defaults to jittering each dimension fully within its cell and applies no staggering. It is equivalent to calling the full version with {\ttfamily jitter\+\_\+amount} filled with 1.\+0 and {\ttfamily stagger\+\_\+ratio} filled with 0.\+0.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Number of points to generate \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned bounding box defining the sampling domain \\
\hline
{\em seed} & Optional seed for deterministic jittering \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ Jittered point samples
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md7}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md7}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::array<std::pair<double,\ double>,\ 3>\ bounds\ =\ \{\{\{0,\ 1\},\ \{0,\ 1\},\ \{0,}
\DoxyCodeLine{1\}\}\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ points\ =\ ps::jittered\_grid<double,\ 3>(1000,\ bounds,\ 1234);}

\end{DoxyCode}
 \Hypertarget{namespaceps_ac0a1fb7adf634a6a0137cd041c54b0a3}\label{namespaceps_ac0a1fb7adf634a6a0137cd041c54b0a3} 
\index{ps@{ps}!kmeans\_cluster@{kmeans\_cluster}}
\index{kmeans\_cluster@{kmeans\_cluster}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{kmeans\_cluster()}{kmeans\_cluster()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::pair$<$ std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$, std\+::vector$<$ size\+\_\+t $>$ $>$ ps\+::kmeans\+\_\+cluster (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{size\+\_\+t}]{k\+\_\+clusters,  }\item[{bool}]{normalize\+\_\+data = {\ttfamily true},  }\item[{size\+\_\+t}]{max\+\_\+iterations = {\ttfamily 100} }\end{DoxyParamCaption})}



Perform k-\/means clustering on a set of points. 

Uses the {\ttfamily dkm} library to cluster points into {\ttfamily k} groups.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Floating point type. \\
\hline
{\em N} & Dimensionality of the points. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of points to cluster. \\
\hline
{\em k\+\_\+clusters} & Number of clusters. \\
\hline
{\em max\+\_\+iterations} & Maximum number of iterations for k-\/means. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::pair\texorpdfstring{$<$}{<} std\+::vector$<$\+Point$<$\+T, N$>$$>$, std\+::vector$<$size\+\_\+t$>$ \texorpdfstring{$>$}{>}
\begin{DoxyItemize}
\item First element\+: vector of cluster centroids.
\item Second element\+: cluster index assignment for each point.
\end{DoxyItemize}
\end{DoxyReturn}
{\bfseries{Example\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.1f,\ 0.2f\},\ \{0.15f,\ 0.22f\},\ \{0.8f,\ 0.75f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{auto}\ [centroids,\ labels]\ =\ \mbox{\hyperlink{namespaceps_ac0a1fb7adf634a6a0137cd041c54b0a3}{kmeans\_cluster}}(pts,\ 2);}
\DoxyCodeLine{\textcolor{comment}{//\ centroids.size()\ ==\ 2}}
\DoxyCodeLine{\textcolor{comment}{//\ labels.size()\ ==\ pts.size()}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0}\label{namespaceps_a9ca14831de223ff62a6c3ec93e96a7c0} 
\index{ps@{ps}!latin\_hypercube\_sampling@{latin\_hypercube\_sampling}}
\index{latin\_hypercube\_sampling@{latin\_hypercube\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{latin\_hypercube\_sampling()}{latin\_hypercube\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::latin\+\_\+hypercube\+\_\+sampling (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{sample\+\_\+count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746}\label{namespaceps_a38d89dd8b52a63eabb39ef5e425d5746} 
\index{ps@{ps}!length@{length}}
\index{length@{length}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{length()}{length()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::length (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a7c3e161560ad3000aa4e2218291b169c}\label{namespaceps_a7c3e161560ad3000aa4e2218291b169c} 
\index{ps@{ps}!length\_squared@{length\_squared}}
\index{length\_squared@{length\_squared}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{length\_squared()}{length\_squared()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
T ps\+::length\+\_\+squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa}\label{namespaceps_a79914e9fc2dd02bacd38e9bd32e21baa} 
\index{ps@{ps}!lerp@{lerp}}
\index{lerp@{lerp}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{lerp()}{lerp()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::lerp (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b,  }\item[{T}]{t }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a677f90d97b1dcfeaa2ecc299ee37f5bf}\label{namespaceps_a677f90d97b1dcfeaa2ecc299ee37f5bf} 
\index{ps@{ps}!merge\_by\_dimension@{merge\_by\_dimension}}
\index{merge\_by\_dimension@{merge\_by\_dimension}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{merge\_by\_dimension()}{merge\_by\_dimension()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::merge\+\_\+by\+\_\+dimension (\begin{DoxyParamCaption}\item[{const std\+::array$<$ std\+::vector$<$ T $>$, N $>$ \&}]{components }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_ac29744e12116f882d8a620a3fd02d72d}\label{namespaceps_ac29744e12116f882d8a620a3fd02d72d} 
\index{ps@{ps}!nearest\_neighbors\_indices@{nearest\_neighbors\_indices}}
\index{nearest\_neighbors\_indices@{nearest\_neighbors\_indices}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{nearest\_neighbors\_indices()}{nearest\_neighbors\_indices()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ ps\+::nearest\+\_\+neighbors\+\_\+indices (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{size\+\_\+t}]{k\+\_\+neighbors = {\ttfamily 8} }\end{DoxyParamCaption})}



Finds the nearest neighbors for each point in a set. 

This function uses a KD-\/tree to search for the k nearest neighbors of each point in the input set, returning their indices. The search excludes the query point itself.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of N-\/dimensional points. \\
\hline
{\em k\+\_\+neighbors} & Number of nearest neighbors to return for each point.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector where each element is a vector of indices representing the nearest neighbors of the corresponding point in {\ttfamily points}.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The KD-\/tree is rebuilt internally for the search.
\end{DoxyNote}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 3>>\ points\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.0f,\ 0.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{1.0f,\ 0.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{0.0f,\ 1.0f,\ 0.0f\},}
\DoxyCodeLine{\ \ \ \ \{1.0f,\ 1.0f,\ 0.0f\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ neighbors\ =\ \mbox{\hyperlink{namespaceps_ac29744e12116f882d8a620a3fd02d72d}{nearest\_neighbors\_indices}}(points,\ 2);}
\DoxyCodeLine{\textcolor{comment}{//\ neighbors[0]\ might\ contain\ \{1,\ 2\}}}
\DoxyCodeLine{\textcolor{comment}{//\ neighbors[1]\ might\ contain\ \{0,\ 3\}}}

\end{DoxyCode}
 
\end{DoxyParagraph}
\Hypertarget{namespaceps_a172358f05108b5cabdac4e43ab309ab2}\label{namespaceps_a172358f05108b5cabdac4e43ab309ab2} 
\index{ps@{ps}!normalize\_points@{normalize\_points}}
\index{normalize\_points@{normalize\_points}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{normalize\_points()}{normalize\_points()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::normalize\+\_\+points (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points }\end{DoxyParamCaption})}



Normalize the coordinates of a set of points along each axis to the range \mbox{[}0, 1\mbox{]}. 

This function finds the minimum and maximum value for each axis across all points and rescales each coordinate so that the minimum becomes 0 and the maximum becomes 1.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type of the coordinates (e.\+g., float, double). \\
\hline
{\em N} & Number of dimensions in each point. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of points to normalize. The points are modified in place.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If all points have the same value along a given axis, the corresponding normalized coordinate will be set to 0 for that axis.
\end{DoxyNote}
{\bfseries{Example usage\+:}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 3>>\ points\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{\{1.0f,\ 5.0f,\ 10.0f\}\},}
\DoxyCodeLine{\ \ \ \ \{\{3.0f,\ 15.0f,\ 20.0f\}\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\mbox{\hyperlink{namespaceps_a172358f05108b5cabdac4e43ab309ab2}{normalize\_points}}(points);}
\DoxyCodeLine{\textcolor{comment}{//\ Now\ points\ coordinates\ are\ scaled\ in\ [0,\ 1]\ along\ each\ axis}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a7de6090e2c8291401816be9bc6cda914}\label{namespaceps_a7de6090e2c8291401816be9bc6cda914} 
\index{ps@{ps}!normalized@{normalized}}
\index{normalized@{normalized}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{normalized()}{normalized()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::normalized (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b}\label{namespaceps_a6fd3a6df3727a04f9baba3b8b87a903b} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_acd4dc781f43ba8a50daa139682846d4b}\label{namespaceps_acd4dc781f43ba8a50daa139682846d4b} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4}\label{namespaceps_abfd6fe71db1c4df607bfdace9dffb5b4} 
\index{ps@{ps}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}\item[{T}]{scalar,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0}\label{namespaceps_af9ee1cf5d335276b7fabe6f1daddf1b0} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a366ef094d65da865384b6fb77aac5d5f}\label{namespaceps_a366ef094d65da865384b6fb77aac5d5f} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_afe774cb61bde6358f8a7024c42db9804}\label{namespaceps_afe774cb61bde6358f8a7024c42db9804} 
\index{ps@{ps}!operator+@{operator+}}
\index{operator+@{operator+}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator+ (\begin{DoxyParamCaption}\item[{T}]{scalar,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1}\label{namespaceps_aa369956286bc3f09dfdc146a5b2a49f1} 
\index{ps@{ps}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f}\label{namespaceps_a79196b5b8a95ad9d3bc2ad698425944f} 
\index{ps@{ps}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a585704d3f738c5eb899810fc9308a60e}\label{namespaceps_a585704d3f738c5eb899810fc9308a60e} 
\index{ps@{ps}!operator/@{operator/}}
\index{operator/@{operator/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{a,  }\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580}\label{namespaceps_a6663b4f1e9c5ee48e2bf6e1896430580} 
\index{ps@{ps}!operator/@{operator/}}
\index{operator/@{operator/}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{operator/()}{operator/()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
\mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ ps\+::operator/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ \&}]{p,  }\item[{T}]{scalar }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8}\label{namespaceps_a5b1e932ba8a20e05cd8c113179aa77c8} 
\index{ps@{ps}!poisson\_disk\_sampling@{poisson\_disk\_sampling}}
\index{poisson\_disk\_sampling@{poisson\_disk\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{poisson\_disk\_sampling()}{poisson\_disk\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Scale\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::poisson\+\_\+disk\+\_\+sampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{Scale\+Fn}]{scale\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt},  }\item[{size\+\_\+t}]{new\+\_\+points\+\_\+attempts = {\ttfamily 30} }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e}\label{namespaceps_a6f7ab76c5d0a395aa78b85bad488e94e} 
\index{ps@{ps}!poisson\_disk\_sampling\_uniform@{poisson\_disk\_sampling\_uniform}}
\index{poisson\_disk\_sampling\_uniform@{poisson\_disk\_sampling\_uniform}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{poisson\_disk\_sampling\_uniform()}{poisson\_disk\_sampling\_uniform()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::poisson\+\_\+disk\+\_\+sampling\+\_\+uniform (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges,  }\item[{T}]{base\+\_\+min\+\_\+dist,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt},  }\item[{size\+\_\+t}]{new\+\_\+points\+\_\+attempts = {\ttfamily 30} }\end{DoxyParamCaption})}

\Hypertarget{namespaceps_a8d80a56ea4774726e748b48e1ecf0a8d}\label{namespaceps_a8d80a56ea4774726e748b48e1ecf0a8d} 
\index{ps@{ps}!radial\_distribution@{radial\_distribution}}
\index{radial\_distribution@{radial\_distribution}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{radial\_distribution()}{radial\_distribution()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::pair$<$ std\+::vector$<$ T $>$, std\+::vector$<$ T $>$ $>$ ps\+::radial\+\_\+distribution (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{T}]{bin\+\_\+width,  }\item[{T}]{max\+\_\+distance }\end{DoxyParamCaption})}



Compute the normalized radial distribution function g(r). 

The radial distribution function (RDF) describes how the density of points varies as a function of distance from a reference point.


\begin{DoxyItemize}
\item g(r) ≈ 1 → uniform / random distribution at distance r
\item g(r) \texorpdfstring{$>$}{>} 1 → clustering / aggregation (excess probability of finding neighbors)
\item g(r) \texorpdfstring{$<$}{<} 1 → depletion / exclusion (points repel or avoid each other)
\end{DoxyItemize}

This function normalizes the observed pair distances against the expected density in the domain (given by axis\+\_\+ranges).


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (float, double, ...) \\
\hline
{\em N} & Dimension of points \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of points \\
\hline
{\em axis\+\_\+ranges} & Axis-\/aligned domain ranges for each dimension \\
\hline
{\em bin\+\_\+width} & Width of distance bins \\
\hline
{\em max\+\_\+distance} & Maximum distance to consider \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::pair\texorpdfstring{$<$}{<}std\+::vector$<$\+T$>$, std\+::vector$<$\+T$>$\texorpdfstring{$>$}{>}
\begin{DoxyItemize}
\item First\+: radii (bin centers)
\item Second\+: normalized RDF values g(r)
\end{DoxyItemize}
\end{DoxyReturn}
\hypertarget{namespaceps_autotoc_md9}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md9}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<double,\ 2>>\ pts\ =\ \{}
\DoxyCodeLine{\ \ \ \ \{0.0,\ 0.0\},\ \{1.0,\ 0.0\},\ \{0.0,\ 1.0\},\ \{1.0,\ 1.0\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{std::array<std::pair<double,double>,2>\ ranges\ =\ \{}
\DoxyCodeLine{\ \ \ \ std::make\_pair(0.0,\ 1.0),\ std::make\_pair(0.0,\ 1.0)}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ [r,\ g]\ =\ \mbox{\hyperlink{namespaceps_a8d80a56ea4774726e748b48e1ecf0a8d}{radial\_distribution}}(pts,\ ranges,\ 0.1,\ 2.0);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ r.size();\ ++i)\ std::cout\ <<\ \textcolor{stringliteral}{"{}r="{}}\ <<\ r[i]\ <<\ \textcolor{stringliteral}{"{}\ g(r)="{}}}
\DoxyCodeLine{<<\ g[i]\ <<\ std::endl;}

\end{DoxyCode}
 \Hypertarget{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69}\label{namespaceps_a10763ef2a872aa9eddb48ea341cd6f69} 
\index{ps@{ps}!random@{random}}
\index{random@{random}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random()}{random()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates a specified number of uniformly distributed random points in N-\/dimensional space. 

This function creates {\ttfamily count} random points where each coordinate is independently sampled from a uniform distribution defined by {\ttfamily axis\+\_\+ranges} per dimension.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The numeric type for coordinates (e.\+g., float, double). \\
\hline
{\em N} & The dimensionality of the points.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & The number of random points to generate. \\
\hline
{\em axis\+\_\+ranges} & An array of N pairs specifying the min and max range for each axis. \\
\hline
{\em seed} & Optional seed for the random number generator. If not provided, a nondeterministic random seed is used.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector containing {\ttfamily count} randomly generated points within the specified axis ranges.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument\+Ifanyaxisrangehasmin$>$max.} & \\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
The points are generated independently per axis using uniform\+\_\+real\+\_\+distribution.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{random_8hpp}{point\_sampler/random.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ dim\ =\ 3;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{size\_t}\ count\ =\ 5;}
\DoxyCodeLine{\ \ std::array<std::pair<float,\ float>,\ dim>\ ranges\ =\ \{\{\{0.f,\ 1.f\},\ \{0.f,\ 2.f\},}
\DoxyCodeLine{\{-\/1.f,\ 1.f\}\}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Generate\ points\ with\ a\ fixed\ seed\ for\ reproducibility\ auto\ points\ =}}
\DoxyCodeLine{ps::random<float,\ dim>(count,\ ranges,\ 42);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ p\ :\ points)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ dim;\ ++i)\ std::cout\ <<\ p[i]\ <<\ \textcolor{charliteral}{'\ '};}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a66183362443c104da098224df9bcd2a1}\label{namespaceps_a66183362443c104da098224df9bcd2a1} 
\index{ps@{ps}!random\_rejection\_filter@{random\_rejection\_filter}}
\index{random\_rejection\_filter@{random\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random\_rejection\_filter()}{random\_rejection\_filter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{float}]{keep\+\_\+fraction }\end{DoxyParamCaption})}



Randomly retains a fraction of the input points. 

This is a convenience overload of {\ttfamily random\+\_\+rejection\+\_\+filter} that accepts a floating-\/point {\ttfamily keep\+\_\+fraction} instead of an absolute count. Internally, it computes the number of points to retain and calls the count-\/based version.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input vector of points \\
\hline
{\em keep\+\_\+fraction} & Fraction of points to retain (between 0.\+0 and 1.\+0) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ containing {\ttfamily keep\+\_\+fraction \texorpdfstring{$\ast$}{*} points.\+size()} randomly selected points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<double,\ 3>>\ cloud\ =\ ps::random<double,\ 3>(10000,}
\DoxyCodeLine{\{\{-\/1,1\},\{-\/1,1\},\{-\/1,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ sparse\ =\ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{ps::random\_rejection\_filter}}(cloud,\ 0.25);\ \textcolor{comment}{//\ Keep\ 25\%\ of\ the}}
\DoxyCodeLine{points}

\end{DoxyCode}
 \Hypertarget{namespaceps_ab818126518017939773c8a43bd92fc42}\label{namespaceps_ab818126518017939773c8a43bd92fc42} 
\index{ps@{ps}!random\_rejection\_filter@{random\_rejection\_filter}}
\index{random\_rejection\_filter@{random\_rejection\_filter}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{random\_rejection\_filter()}{random\_rejection\_filter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::size\+\_\+t N$>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::random\+\_\+rejection\+\_\+filter (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{std\+::size\+\_\+t}]{target\+\_\+count }\end{DoxyParamCaption})}



Randomly retains a fixed number of points from the input set. 

This function returns a subset of the input points of size {\ttfamily target\+\_\+count}, selected uniformly at random without replacement. If {\ttfamily target\+\_\+count} is greater than or equal to the number of input points, the full input is returned.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float or double) \\
\hline
{\em N} & Dimensionality of the space \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Input vector of points \\
\hline
{\em target\+\_\+count} & Desired number of points in the output (≤ points.\+size()) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ containing {\ttfamily target\+\_\+count} randomly selected points
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ ps::random<float,\ 2>(1000,}
\DoxyCodeLine{\{\{0,1\},\{0,1\}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ reduced\ =\ \mbox{\hyperlink{namespaceps_ab818126518017939773c8a43bd92fc42}{ps::random\_rejection\_filter}}(pts,\ 300);\ \textcolor{comment}{//\ Keep\ 300\ points}}

\end{DoxyCode}
 \Hypertarget{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862}\label{namespaceps_a2b8197901114d1c4fd6cfe19efcd3862} 
\index{ps@{ps}!refit\_points\_to\_range@{refit\_points\_to\_range}}
\index{refit\_points\_to\_range@{refit\_points\_to\_range}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{refit\_points\_to\_range()}{refit\_points\_to\_range()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::refit\+\_\+points\+\_\+to\+\_\+range (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{target\+\_\+ranges }\end{DoxyParamCaption})}



Linearly remap a set of points to fit within the specified axis-\/aligned ranges. 

This function computes the axis-\/aligned bounding box (AABB) of the input points and linearly rescales each point so that all dimensions lie in the given {\ttfamily target\+\_\+ranges}.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & Vector of input points to modify in-\/place. \\
\hline
\mbox{\texttt{ in}}  & {\em target\+\_\+ranges} & Desired output min/max per dimension.\\
\hline
\end{DoxyParams}
\hypertarget{namespaceps_autotoc_md10}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md10}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ generate\_random\_points<float,}
\DoxyCodeLine{2>(100,\ \{\ \{}
\DoxyCodeLine{\{0.f,\ 1.f\},\ \{0.f,\ 1.f\}\ \}\ \},\ 42);}
\DoxyCodeLine{\textcolor{comment}{//\ Refit\ to\ a\ new\ range:\ [10,\ 20]\ ×\ [50,\ 100]\ refit\_points\_to\_range<float,}}
\DoxyCodeLine{2>(pts,\ \{\ \{\ \{10.f,\ 20.f\},\ \{50.f,\ 100.f\}\ \}\ \});}

\end{DoxyCode}


\begin{DoxyNote}{Note}
If a dimension has constant value (min == max), the center of the target range is used. 
\end{DoxyNote}
\Hypertarget{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527}\label{namespaceps_a29ab0a94bbe26a22cb87bf8f44703527} 
\index{ps@{ps}!rejection\_sampling@{rejection\_sampling}}
\index{rejection\_sampling@{rejection\_sampling}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{rejection\_sampling()}{rejection\_sampling()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Density\+Fn $>$ \\
std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ ps\+::rejection\+\_\+sampling (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{axis\+\_\+ranges,  }\item[{Density\+Fn}]{density\+\_\+fn,  }\item[{std\+::optional$<$ unsigned int $>$}]{seed = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})}



Generates random points using rejection sampling based on a user-\/defined density function. 

This function uniformly samples candidate points within the given axis-\/aligned bounds and retains them based on the output of a user-\/provided density function. The {\ttfamily density\+\_\+fn} should return a probability in the range \mbox{[}0, 1\mbox{]} for each point.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions. \\
\hline
{\em Density\+Fn} & Callable with signature T(\+Point$<$\+T, N$>$) returning a probability in \mbox{[}0, 1\mbox{]}.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em count} & Desired number of accepted points. \\
\hline
{\em axis\+\_\+ranges} & Ranges for each axis in the form of an array of (min, max) pairs. \\
\hline
{\em density\+\_\+fn} & Function that returns a probability for accepting a point. \\
\hline
{\em seed} & Optional seed for reproducibility.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$\+Point$<$\+T, N$>$$>$ A vector of accepted points based on rejection sampling.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argumentifanyaxisrangeisinvalid(min$>$max).} & \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceps_autotoc_md11}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md11}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{rejection__sampling_8hpp}{point\_sampler/rejection\_sampling.hpp}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{float}\ radial\_density(\textcolor{keyword}{const}\ \mbox{\hyperlink{structps_1_1Point}{Point<float,\ 2>}}\&\ p)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{float}\ r2\ =\ p[0]\ *\ p[0]\ +\ p[1]\ *\ p[1];}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::exp(-\/r2);\ \textcolor{comment}{//\ higher\ near\ origin,\ drops\ with\ radius}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main()\ \{}
\DoxyCodeLine{\ \ \ \ std::array<std::pair<float,\ float>,\ 2>\ bounds\ =\ \{\ \{\ \{-\/2.0f,\ 2.0f\},}
\DoxyCodeLine{\{-\/2.0f,\ 2.0f\}\ \}\ \};}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ pts\ =\ ps::rejection\_sampling<float,\ 2>(1000,\ bounds,\ radial\_density,}
\DoxyCodeLine{42);}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Generated\ "{}}\ <<\ pts.size()\ <<\ \textcolor{stringliteral}{"{}\ points.\(\backslash\)n"{}};}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Rejection sampling can be inefficient if {\ttfamily density\+\_\+fn} returns low values over most of the domain, as many candidate samples will be discarded. 
\end{DoxyNote}
\Hypertarget{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18}\label{namespaceps_aed8a3217a801c5b5706f4bcc3306bb18} 
\index{ps@{ps}!relaxation\_ktree@{relaxation\_ktree}}
\index{relaxation\_ktree@{relaxation\_ktree}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{relaxation\_ktree()}{relaxation\_ktree()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::relaxation\+\_\+ktree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{size\+\_\+t}]{k\+\_\+neighbors = {\ttfamily 8},  }\item[{T}]{step\+\_\+size = {\ttfamily T(0.1)},  }\item[{size\+\_\+t}]{iterations = {\ttfamily 10} }\end{DoxyParamCaption})}



Relax a point set using a k-\/nearest neighbor repulsion algorithm with a KD-\/tree. 

This function performs iterative relaxation on a set of N-\/dimensional points by pushing each point away from its nearest neighbors. It uses a KD-\/tree for efficient neighbor lookup. The goal is to reduce clustering and obtain a more uniform or blue-\/noise-\/like distribution.

Each point is offset based on inverse-\/distance-\/weighted repulsion from its k-\/nearest neighbors, normalized and scaled by a step size. The point set is updated over a number of iterations.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type for coordinates (e.\+g., float or double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & The point set to relax. This vector will be modified in place. \\
\hline
\mbox{\texttt{ in}}  & {\em k\+\_\+neighbors} & Number of neighbors to consider (default is 8). \\
\hline
\mbox{\texttt{ in}}  & {\em step\+\_\+size} & How far to move a point per iteration (default is 0.\+1). \\
\hline
\mbox{\texttt{ in}}  & {\em iterations} & Number of relaxation iterations (default is 10).\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The KD-\/tree is rebuilt on each iteration to reflect the updated positions.
\end{DoxyNote}
\hypertarget{namespaceps_autotoc_md12}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{namespaceps_autotoc_md12}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{relaxation_8hpp}{point\_sampler/relaxation.hpp}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<Point<float,\ 2>>\ pts\ =\ generate\_random\_points<float,\ 2>(}
\DoxyCodeLine{\ \ \ \ 1000,\ \{\ \{\ \{0.f,\ 1.f\},\ \{0.f,\ 1.f\}\ \}\ \},\ 42);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Apply\ 10\ iterations\ of\ relaxation\ relaxation\_ktree<float,\ 2>(pts,\ 8,\ 0.1f,}}
\DoxyCodeLine{10);}

\end{DoxyCode}
\hypertarget{namespaceps_autotoc_md13}{}\doxysubsubsubsection{\texorpdfstring{How it works\+:}{How it works:}}\label{namespaceps_autotoc_md13}

\begin{DoxyItemize}
\item For each point\+:
\begin{DoxyItemize}
\item Find its {\ttfamily k\+\_\+neighbors} nearest neighbors using a KD-\/tree.
\item Compute offset vectors from the current point to each neighbor.
\item Weight the vectors by the inverse square distance (stronger push from closer neighbors).
\item Accumulate the offset, normalize, and scale by {\ttfamily step\+\_\+size}.
\item Apply the movement to each point.
\end{DoxyItemize}
\item Repeat for {\ttfamily iterations} steps. 
\end{DoxyItemize}\Hypertarget{namespaceps_a7addf1455112b7895f8de7c475eed850}\label{namespaceps_a7addf1455112b7895f8de7c475eed850} 
\index{ps@{ps}!rescale\_points@{rescale\_points}}
\index{rescale\_points@{rescale\_points}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{rescale\_points()}{rescale\_points()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
void ps\+::rescale\+\_\+points (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{const std\+::array$<$ std\+::pair$<$ T, T $>$, N $>$ \&}]{ranges }\end{DoxyParamCaption})}



Rescales normalized points (in \mbox{[}0, 1\mbox{]}) to specified axis-\/aligned ranges. 

Each coordinate in every point is mapped from \mbox{[}0, 1\mbox{]} to a new range defined per axis. This is useful after generating normalized samples (e.\+g., Poisson disk, jittered grid).


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Numeric type (e.\+g., float, double). \\
\hline
{\em N} & Number of dimensions.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em points} & Vector of normalized points to be modified in-\/place. \\
\hline
\mbox{\texttt{ in}}  & {\em ranges} & Target value ranges for each dimension.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<Point<float,\ 2>>\ pts\ =\ \{\ \{0.f,\ 0.f\},\ \{1.f,\ 1.f\},\ \{0.5f,}
\DoxyCodeLine{0.5f\}\ \};}
\DoxyCodeLine{ps::rescale\_points<float,\ 2>(pts,\ \{\ \{\ \{10.f,\ 20.f\},\ \{100.f,\ 200.f\}\ \}\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ pts\ is\ now\ \{\ \{10.f,\ 100.f\},\ \{20.f,\ 200.f\},\ \{15.f,\ 150.f\}\ \}}}

\end{DoxyCode}


\begin{DoxyNote}{Note}
Assumes points are in \mbox{[}0, 1\mbox{]}\texorpdfstring{$^\wedge$}{\string^}N. Does not check bounds. 
\end{DoxyNote}
\Hypertarget{namespaceps_a802637e81218193c0e65266c8075f002}\label{namespaceps_a802637e81218193c0e65266c8075f002} 
\index{ps@{ps}!save\_points\_to\_csv@{save\_points\_to\_csv}}
\index{save\_points\_to\_csv@{save\_points\_to\_csv}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{save\_points\_to\_csv()}{save\_points\_to\_csv()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
bool ps\+::save\+\_\+points\+\_\+to\+\_\+csv (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points,  }\item[{bool}]{write\+\_\+header = {\ttfamily true} }\end{DoxyParamCaption})}



Save a set of N-\/dimensional points to a CSV file. 

The output file will contain one point per line, with each coordinate separated by commas. Optionally, a header row ("{}x0,x1,...,x\+N"{}) can be written as the first line.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em filename} & Path to the output CSV file. \\
\hline
{\em points} & Vector of points to be saved. \\
\hline
{\em write\+\_\+header} & If true, writes a header row with column names ("{}x0,x1,..."{}).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the file was successfully written, false otherwise. 
\end{DoxyReturn}
\Hypertarget{namespaceps_a5b92b660faab5030374ba2dee9f89810}\label{namespaceps_a5b92b660faab5030374ba2dee9f89810} 
\index{ps@{ps}!save\_vector\_to\_csv@{save\_vector\_to\_csv}}
\index{save\_vector\_to\_csv@{save\_vector\_to\_csv}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{save\_vector\_to\_csv()}{save\_vector\_to\_csv()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool ps\+::save\+\_\+vector\+\_\+to\+\_\+csv (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const std\+::vector$<$ T $>$ \&}]{values,  }\item[{bool}]{write\+\_\+header = {\ttfamily true},  }\item[{const std\+::string \&}]{header\+\_\+name = {\ttfamily "{}value"{}} }\end{DoxyParamCaption})}



Save a 1D vector of values to a CSV file. 

This function writes a sequence of values to a CSV file with one value per row. The column name can be customized via the {\ttfamily header\+\_\+name} parameter.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the values (must be streamable to std\+::ostream). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em filename} & Path to the output CSV file. \\
\hline
{\em values} & The vector of values to write. \\
\hline
{\em write\+\_\+header} & If true, writes a header line at the top of the file. \\
\hline
{\em header\+\_\+name} & Name of the column header (only used if {\ttfamily write\+\_\+header} is true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the file was successfully written, false otherwise.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The file will be overwritten if it already exists.
\end{DoxyNote}
{\bfseries{Example}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::vector<double>\ data\ =\ \{1.0,\ 2.5,\ 3.7\};}
\DoxyCodeLine{\mbox{\hyperlink{namespaceps_a5b92b660faab5030374ba2dee9f89810}{save\_vector\_to\_csv}}(\textcolor{stringliteral}{"{}data.csv"{}},\ data,\ \textcolor{keyword}{true},\ \textcolor{stringliteral}{"{}measurement"{}});}
\DoxyCodeLine{\textcolor{comment}{//\ data.csv\ content:}}
\DoxyCodeLine{\textcolor{comment}{//\ measurement}}
\DoxyCodeLine{\textcolor{comment}{//\ 1.0}}
\DoxyCodeLine{\textcolor{comment}{//\ 2.5}}
\DoxyCodeLine{\textcolor{comment}{//\ 3.7}}

\end{DoxyCode}
 \Hypertarget{namespaceps_af6737277b9cc05d5f2ab248f17baea3b}\label{namespaceps_af6737277b9cc05d5f2ab248f17baea3b} 
\index{ps@{ps}!split\_by\_dimension@{split\_by\_dimension}}
\index{split\_by\_dimension@{split\_by\_dimension}!ps@{ps}}
\doxysubsubsection{\texorpdfstring{split\_by\_dimension()}{split\_by\_dimension()}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::array$<$ std\+::vector$<$ T $>$, N $>$ ps\+::split\+\_\+by\+\_\+dimension (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structps_1_1Point}{Point}}$<$ T, N $>$ $>$ \&}]{points }\end{DoxyParamCaption})}



Rearranges a list of N-\/dimensional points into N separate coordinate vectors. 

This function decomposes a vector of N-\/dimensional points into N vectors, where each vector contains all the values from one coordinate dimension. Useful for plotting or statistical analysis.

For example, given 3D points\+: \mbox{[}(1,2,3), (4,5,6), (7,8,9)\mbox{]}, the result will be\+:
\begin{DoxyItemize}
\item dimension 0\+: \mbox{[}1, 4, 7\mbox{]}
\item dimension 1\+: \mbox{[}2, 5, 8\mbox{]}
\item dimension 2\+: \mbox{[}3, 6, 9\mbox{]}
\end{DoxyItemize}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Scalar type (e.\+g., float, double). \\
\hline
{\em N} & Dimension of each point.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em points} & Vector of N-\/dimensional points.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of N vectors, each containing the values for one coordinate axis. 
\end{DoxyReturn}
