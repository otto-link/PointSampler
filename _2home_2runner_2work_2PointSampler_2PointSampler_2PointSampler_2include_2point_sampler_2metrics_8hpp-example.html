<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PointSampler library (C++): /home/runner/work/PointSampler/PointSampler/PointSampler/include/point_sampler/metrics.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PointSampler library (C++)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_2home_2runner_2work_2PointSampler_2PointSampler_2PointSampler_2include_2point_sampler_2metrics_8hpp-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">/home/runner/work/PointSampler/PointSampler/PointSampler/include/point_sampler/metrics.hpp</div></div>
</div><!--header-->
<div class="contents">
<p>Compute the angular distribution function (ADF) using nearest neighbors.</p>
<p>Compute the angular distribution function (ADF) using nearest neighbors.The angular distribution function (ADF) measures the distribution of bond angles formed by a point and pairs of its nearest neighbors.</p>
<ul>
<li>Flat distribution → random uniform points.</li>
<li>Peaks at characteristic angles → local order (e.g. hexagonal lattice peaks at 60°).</li>
<li>Depletions → angular avoidance due to constraints or repulsion.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (float, double, ...) </td></tr>
    <tr><td class="paramname">N</td><td>Dimension of points (N &gt;= 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Vector of points </td></tr>
    <tr><td class="paramname">bin_width</td><td>Width of angle bins (in radians) </td></tr>
    <tr><td class="paramname">k_neighbors</td><td>Number of neighbors used for angle calculation (default: 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt;<ul>
<li>First: bin centers (angles in radians)</li>
<li>Second: normalized ADF values</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;double, 2&gt;&gt; pts = {</div>
<div class="line">    {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [theta, g_theta] = angle_distribution_neighbors(pts, 0.1, 6);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta.size(); ++i)</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;θ=&quot;</span> &lt;&lt; theta[i] &lt;&lt; <span class="stringliteral">&quot;g(θ)=&quot;</span> &lt;&lt; g_theta[i] &lt;&lt; std::endl;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Copyright (c) 2025 Otto Link. Distributed under the terms of the GNU General</span></div>
<div class="line"><span class="comment">   Public License. The full license is in the file LICENSE, distributed with</span></div>
<div class="line"><span class="comment">   this software. */</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="nanoflann__adaptator_8hpp.html">point_sampler/internal/nanoflann_adaptator.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="point_8hpp.html">point_sampler/point.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceps.html">ps</a></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt; <a id="a0" name="a0"></a><a class="code hl_function" href="namespaceps.html#ae96771d03336a56988d82df95e8a797a">angle_distribution_neighbors</a>(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;T, N&gt;&gt; &amp;points,</div>
<div class="line">    T                               bin_width,</div>
<div class="line">    <span class="keywordtype">size_t</span>                          k_neighbors = 8)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (N &lt; 2)</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Angle distribution requires dimension &gt;= 2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span>         num_bins = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(std::ceil(M_PI / bin_width));</div>
<div class="line">  std::vector&lt;T&gt; angles(num_bins);</div>
<div class="line">  std::vector&lt;T&gt; g_theta(num_bins, T(0));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Precompute bin centers</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_bins; ++i)</div>
<div class="line">    angles[i] = (i + T(0.5)) * bin_width;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get nearest neighbors once</span></div>
<div class="line">  <span class="keyword">auto</span> neighbors = <a id="a1" name="a1"></a><a class="code hl_function" href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">nearest_neighbors_indices</a>(points, k_neighbors);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Loop over all points</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;nbrs = neighbors[i];</div>
<div class="line">    <span class="keywordtype">size_t</span>      n_nbrs = nbrs.size();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Compute angles between all neighbor pairs</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> a = 0; a &lt; n_nbrs; ++a)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> b = a + 1; b &lt; n_nbrs; ++b)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">size_t</span> j = nbrs[a];</div>
<div class="line">        <span class="keywordtype">size_t</span> k = nbrs[b];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Vectors from center i to j and k</span></div>
<div class="line">        std::array&lt;T, N&gt; v1, v2;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">        {</div>
<div class="line">          v1[d] = points[j][d] - points[i][d];</div>
<div class="line">          v2[d] = points[k][d] - points[i][d];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Compute angle</span></div>
<div class="line">        T <a id="a2" name="a2"></a><a class="code hl_function" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> = T(0), norm1 = T(0), norm2 = T(0);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">        {</div>
<div class="line">          <a class="code hl_function" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> += v1[d] * v2[d];</div>
<div class="line">          norm1 += v1[d] * v1[d];</div>
<div class="line">          norm2 += v2[d] * v2[d];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (norm1 &gt; T(0) &amp;&amp; norm2 &gt; T(0))</div>
<div class="line">        {</div>
<div class="line">          T cos_theta = std::clamp(<a class="code hl_function" href="namespaceps.html#ace7642868199df621df9139e5179767b">dot</a> / (std::sqrt(norm1) * std::sqrt(norm2)),</div>
<div class="line">                                   T(-1),</div>
<div class="line">                                   T(1));</div>
<div class="line">          T theta = std::acos(cos_theta);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordtype">size_t</span> bin = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(theta / bin_width);</div>
<div class="line">          <span class="keywordflow">if</span> (bin &lt; num_bins)</div>
<div class="line">            g_theta[bin] += T(1);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Normalize histogram</span></div>
<div class="line">  T total = std::accumulate(g_theta.begin(), g_theta.end(), T(0));</div>
<div class="line">  <span class="keywordflow">if</span> (total &gt; T(0))</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;val : g_theta)</div>
<div class="line">      val /= total;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {angles, g_theta};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::vector&lt;T&gt; <a id="a3" name="a3"></a><a class="code hl_function" href="namespaceps.html#a9a824a8963ef7b15c01da0f1f9c90eee">distance_to_boundary</a>(<span class="keyword">const</span> std::vector&lt;Point&lt;T, N&gt;&gt;       &amp;points,</div>
<div class="line">                                    <span class="keyword">const</span> std::array&lt;std::pair&lt;T, T&gt;, N&gt; &amp;axis_ranges)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;T&gt; distances;</div>
<div class="line">  distances.reserve(points.size());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Find min distance to a boundary plane</span></div>
<div class="line">    T min_dist = std::numeric_limits&lt;T&gt;::max();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">    {</div>
<div class="line">      T dist_to_min = std::abs(p[d] - axis_ranges[d].first);</div>
<div class="line">      T dist_to_max = std::abs(axis_ranges[d].second - p[d]);</div>
<div class="line"> </div>
<div class="line">      min_dist = std::min({min_dist, dist_to_min, dist_to_max});</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    distances.push_back(min_dist);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> distances;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::vector&lt;T&gt; <a id="a4" name="a4"></a><a class="code hl_function" href="namespaceps.html#a91a0bac33731ed899845c6081c117db2">first_neighbor_distance_squared</a>(std::vector&lt;Point&lt;T, N&gt;&gt; &amp;points)</div>
<div class="line">{</div>
<div class="line">  PointCloudAdaptor&lt;T, N&gt; adaptor(points);</div>
<div class="line">  KDTree&lt;T, N&gt;            index(N, adaptor);</div>
<div class="line">  index.buildIndex();</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;T&gt; distance_sq;</div>
<div class="line">  distance_sq.reserve(points.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// first neighbor search only</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> k_neighbors = 1;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;p = points[i];</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;size_t&gt; ret_indexes(k_neighbors + 1);</div>
<div class="line">    std::vector&lt;T&gt;      out_dists_sqr(k_neighbors + 1);</div>
<div class="line"> </div>
<div class="line">    nanoflann::KNNResultSet&lt;T&gt; result_set(k_neighbors + 1);</div>
<div class="line">    result_set.init(ret_indexes.data(), out_dists_sqr.data());</div>
<div class="line"> </div>
<div class="line">    std::array&lt;T, N&gt; query;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">      query[d] = p[d];</div>
<div class="line"> </div>
<div class="line">    index.findNeighbors(result_set, query.data(), nanoflann::SearchParameters());</div>
<div class="line"> </div>
<div class="line">    T dist_sq = 0.f;</div>
<div class="line">    <span class="keywordflow">if</span> (ret_indexes.size() &gt; 1)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q = points[ret_indexes[1]];</div>
<div class="line">      <span class="keyword">auto</span>        delta = p - q;</div>
<div class="line">      dist_sq = <a id="a5" name="a5"></a><a class="code hl_function" href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">length_squared</a>(delta) + T(1e-6);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    distance_sq.push_back(dist_sq);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> distance_sq;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::vector&lt;T&gt; <a id="a6" name="a6"></a><a class="code hl_function" href="namespaceps.html#accc008d79bdad63b0acf9a4e627cc479">local_density_knn</a>(<span class="keyword">const</span> std::vector&lt;Point&lt;T, N&gt;&gt; &amp;points, <span class="keywordtype">size_t</span> k = 8)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> neighbors = <a class="code hl_function" href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">nearest_neighbors_indices</a>(points, k);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;T&gt; densities(points.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute unit N-ball volume using gamma function</span></div>
<div class="line">  T volume_unit_ball = std::pow(M_PI, T(N) / 2) / std::tgamma(T(N) / 2 + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Distance to k-th nearest neighbor</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;nk_idx = neighbors[i].back();</div>
<div class="line">    T           dist2 = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">    {</div>
<div class="line">      T diff = points[i][d] - points[nk_idx][d];</div>
<div class="line">      dist2 += diff * diff;</div>
<div class="line">    }</div>
<div class="line">    T r = std::sqrt(dist2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Density = k / (V_N * r^N)</span></div>
<div class="line">    T volume = volume_unit_ball * std::pow(r, T(N));</div>
<div class="line">    densities[i] = k / volume;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> densities;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::vector&lt;std::vector&lt;size_t&gt;&gt; <a class="code hl_function" href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">nearest_neighbors_indices</a>(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;T, N&gt;&gt; &amp;points,</div>
<div class="line">    <span class="keywordtype">size_t</span>                          k_neighbors = 8)</div>
<div class="line">{</div>
<div class="line">  PointCloudAdaptor&lt;T, N&gt; adaptor(points);</div>
<div class="line">  KDTree&lt;T, N&gt;            index(N, adaptor);</div>
<div class="line">  index.buildIndex();</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::vector&lt;size_t&gt;&gt; all_neighbors;</div>
<div class="line">  all_neighbors.resize(points.size());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;p = points[i];</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;size_t&gt; ret_indexes(k_neighbors + 1);</div>
<div class="line">    std::vector&lt;T&gt;      out_dists_sqr(k_neighbors + 1);</div>
<div class="line"> </div>
<div class="line">    nanoflann::KNNResultSet&lt;T&gt; result_set(k_neighbors + 1);</div>
<div class="line">    result_set.init(ret_indexes.data(), out_dists_sqr.data());</div>
<div class="line"> </div>
<div class="line">    std::array&lt;T, N&gt; query;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; N; ++d)</div>
<div class="line">      query[d] = p[d];</div>
<div class="line"> </div>
<div class="line">    index.findNeighbors(result_set, query.data(), nanoflann::SearchParameters());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Skip self at index 0</span></div>
<div class="line">    all_neighbors[i].assign(ret_indexes.begin() + 1, ret_indexes.end());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> all_neighbors;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">std::pair&lt;std::vector&lt;T&gt;, std::vector&lt;T&gt;&gt; <a id="a7" name="a7"></a><a class="code hl_function" href="namespaceps.html#a8d80a56ea4774726e748b48e1ecf0a8d">radial_distribution</a>(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;T, N&gt;&gt;       &amp;points,</div>
<div class="line">    <span class="keyword">const</span> std::array&lt;std::pair&lt;T, T&gt;, N&gt; &amp;axis_ranges,</div>
<div class="line">    T                                     bin_width,</div>
<div class="line">    T                                     max_distance)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span>         num_bins = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(std::ceil(max_distance / bin_width));</div>
<div class="line">  std::vector&lt;T&gt; radii(num_bins);</div>
<div class="line">  std::vector&lt;T&gt; g(num_bins, T(0));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Precompute bin centers</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_bins; ++i)</div>
<div class="line">    radii[i] = (i + T(0.5)) * bin_width;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute volume of domain</span></div>
<div class="line">  T volume = T(1);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;range : axis_ranges)</div>
<div class="line">    volume *= (range.second - range.first);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span> n_points = points.size();</div>
<div class="line">  T      density = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(n_points) / volume;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Histogram of pair distances</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n_points; ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i + 1; j &lt; n_points; ++j)</div>
<div class="line">    {</div>
<div class="line">      T dist = <a id="a8" name="a8"></a><a class="code hl_function" href="namespaceps.html#ac0b74f22d427d199ab0df8f6942d3b11">distance</a>(points[i], points[j]);</div>
<div class="line">      <span class="keywordflow">if</span> (dist &lt; max_distance)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">size_t</span> bin = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(dist / bin_width);</div>
<div class="line">        <span class="keywordflow">if</span> (bin &lt; num_bins)</div>
<div class="line">          g[bin] += T(2); <span class="comment">// count both i→j and</span></div>
<div class="line">                          <span class="comment">// j→i</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Normalize</span></div>
<div class="line">  T norm_factor = (T)n_points * density;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Volume of spherical shell between r1 and r2 in N dimensions</span></div>
<div class="line">  <span class="keyword">auto</span> sphere_volume = [](T radius)</div>
<div class="line">  { <span class="keywordflow">return</span> std::pow(M_PI, N / 2.0) / std::tgamma(N / 2.0 + 1.0) * std::pow(radius, N); };</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_bins; ++i)</div>
<div class="line">  {</div>
<div class="line">    T r_inner = i * bin_width;</div>
<div class="line">    T r_outer = (i + 1) * bin_width;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Volume of spherical shell</span></div>
<div class="line">    T shell_vol = sphere_volume(r_outer) - sphere_volume(r_inner);</div>
<div class="line">    g[i] /= norm_factor * shell_vol;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {radii, g};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace ps</span></div>
<div class="ttc" id="anamespaceps_html"><div class="ttname"><a href="namespaceps.html">ps</a></div><div class="ttdef"><b>Definition</b> dbscan_clustering.hpp:11</div></div>
<div class="ttc" id="anamespaceps_html_a7c3e161560ad3000aa4e2218291b169c"><div class="ttname"><a href="namespaceps.html#a7c3e161560ad3000aa4e2218291b169c">ps::length_squared</a></div><div class="ttdeci">T length_squared(const Point&lt; T, N &gt; &amp;a)</div><div class="ttdef"><b>Definition</b> point.hpp:204</div></div>
<div class="ttc" id="anamespaceps_html_a8d80a56ea4774726e748b48e1ecf0a8d"><div class="ttname"><a href="namespaceps.html#a8d80a56ea4774726e748b48e1ecf0a8d">ps::radial_distribution</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt; radial_distribution(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges, T bin_width, T max_distance)</div><div class="ttdef"><b>Definition</b> metrics.hpp:431</div></div>
<div class="ttc" id="anamespaceps_html_a91a0bac33731ed899845c6081c117db2"><div class="ttname"><a href="namespaceps.html#a91a0bac33731ed899845c6081c117db2">ps::first_neighbor_distance_squared</a></div><div class="ttdeci">std::vector&lt; T &gt; first_neighbor_distance_squared(std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points)</div><div class="ttdoc">Computes the squared distance to the nearest neighbor for each point.</div><div class="ttdef"><b>Definition</b> metrics.hpp:216</div></div>
<div class="ttc" id="anamespaceps_html_a9a824a8963ef7b15c01da0f1f9c90eee"><div class="ttname"><a href="namespaceps.html#a9a824a8963ef7b15c01da0f1f9c90eee">ps::distance_to_boundary</a></div><div class="ttdeci">std::vector&lt; T &gt; distance_to_boundary(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, const std::array&lt; std::pair&lt; T, T &gt;, N &gt; &amp;axis_ranges)</div><div class="ttdoc">Compute the distance of each point to the domain boundary.</div><div class="ttdef"><b>Definition</b> metrics.hpp:152</div></div>
<div class="ttc" id="anamespaceps_html_ac0b74f22d427d199ab0df8f6942d3b11"><div class="ttname"><a href="namespaceps.html#ac0b74f22d427d199ab0df8f6942d3b11">ps::distance</a></div><div class="ttdeci">T distance(const Point&lt; T, N &gt; &amp;a, const Point&lt; T, N &gt; &amp;b)</div><div class="ttdef"><b>Definition</b> point.hpp:229</div></div>
<div class="ttc" id="anamespaceps_html_ac29744e12116f882d8a620a3fd02d72d"><div class="ttname"><a href="namespaceps.html#ac29744e12116f882d8a620a3fd02d72d">ps::nearest_neighbors_indices</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; size_t &gt; &gt; nearest_neighbors_indices(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, size_t k_neighbors=8)</div><div class="ttdoc">Finds the nearest neighbors for each point in a set.</div><div class="ttdef"><b>Definition</b> metrics.hpp:356</div></div>
<div class="ttc" id="anamespaceps_html_accc008d79bdad63b0acf9a4e627cc479"><div class="ttname"><a href="namespaceps.html#accc008d79bdad63b0acf9a4e627cc479">ps::local_density_knn</a></div><div class="ttdeci">std::vector&lt; T &gt; local_density_knn(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, size_t k=8)</div><div class="ttdef"><b>Definition</b> metrics.hpp:293</div></div>
<div class="ttc" id="anamespaceps_html_ace7642868199df621df9139e5179767b"><div class="ttname"><a href="namespaceps.html#ace7642868199df621df9139e5179767b">ps::dot</a></div><div class="ttdeci">T dot(const Point&lt; T, N &gt; &amp;a, const Point&lt; T, N &gt; &amp;b)</div><div class="ttdef"><b>Definition</b> point.hpp:196</div></div>
<div class="ttc" id="anamespaceps_html_ae96771d03336a56988d82df95e8a797a"><div class="ttname"><a href="namespaceps.html#ae96771d03336a56988d82df95e8a797a">ps::angle_distribution_neighbors</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt; angle_distribution_neighbors(const std::vector&lt; Point&lt; T, N &gt; &gt; &amp;points, T bin_width, size_t k_neighbors=8)</div><div class="ttdef"><b>Definition</b> metrics.hpp:49</div></div>
<div class="ttc" id="ananoflann__adaptator_8hpp_html"><div class="ttname"><a href="nanoflann__adaptator_8hpp.html">nanoflann_adaptator.hpp</a></div></div>
<div class="ttc" id="apoint_8hpp_html"><div class="ttname"><a href="point_8hpp.html">point.hpp</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
